"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_sanity_next-loader_dist__chunks-es_PresentationComlink_js"],{

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/defer.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defer: function() { return /* binding */ defer; }\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n\n\nfunction defer(observableFactory) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function(subscriber) {\n        (0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(observableFactory()).subscribe(subscriber);\n    });\n} //# sourceMappingURL=defer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2RlZmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUNIO0FBQ2pDLFNBQVNFLE1BQU1DLGlCQUFpQjtJQUNuQyxPQUFPLElBQUlILG1EQUFVQSxDQUFDLFNBQVVJLFVBQVU7UUFDdENILHFEQUFTQSxDQUFDRSxxQkFBcUJFLFNBQVMsQ0FBQ0Q7SUFDN0M7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9kZWZlci5qcz83ZDAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4vaW5uZXJGcm9tJztcbmV4cG9ydCBmdW5jdGlvbiBkZWZlcihvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpbm5lckZyb20ob2JzZXJ2YWJsZUZhY3RvcnkoKSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwIl0sIm5hbWVzIjpbIk9ic2VydmFibGUiLCJpbm5lckZyb20iLCJkZWZlciIsIm9ic2VydmFibGVGYWN0b3J5Iiwic3Vic2NyaWJlciIsInN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js":
/*!******************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/empty.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EMPTY: function() { return /* binding */ EMPTY; },\n/* harmony export */   empty: function() { return /* binding */ empty; }\n/* harmony export */ });\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n\nvar EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function(subscriber) {\n    return subscriber.complete();\n});\nfunction empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function(subscriber) {\n        return scheduler.schedule(function() {\n            return subscriber.complete();\n        });\n    });\n} //# sourceMappingURL=empty.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUNwQyxJQUFJQyxRQUFRLElBQUlELG1EQUFVQSxDQUFDLFNBQVVFLFVBQVU7SUFBSSxPQUFPQSxXQUFXQyxRQUFRO0FBQUksR0FBRztBQUNwRixTQUFTQyxNQUFNQyxTQUFTO0lBQzNCLE9BQU9BLFlBQVlDLGVBQWVELGFBQWFKO0FBQ25EO0FBQ0EsU0FBU0ssZUFBZUQsU0FBUztJQUM3QixPQUFPLElBQUlMLG1EQUFVQSxDQUFDLFNBQVVFLFVBQVU7UUFBSSxPQUFPRyxVQUFVRSxRQUFRLENBQUM7WUFBYyxPQUFPTCxXQUFXQyxRQUFRO1FBQUk7SUFBSTtBQUM1SCxFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb2JzZXJ2YWJsZS9lbXB0eS5qcz80OTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmV4cG9ydCB2YXIgRU1QVFkgPSBuZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KTtcbmV4cG9ydCBmdW5jdGlvbiBlbXB0eShzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVyID8gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSA6IEVNUFRZO1xufVxuZnVuY3Rpb24gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpOyB9KTsgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXAiXSwibmFtZXMiOlsiT2JzZXJ2YWJsZSIsIkVNUFRZIiwic3Vic2NyaWJlciIsImNvbXBsZXRlIiwiZW1wdHkiLCJzY2hlZHVsZXIiLCJlbXB0eVNjaGVkdWxlZCIsInNjaGVkdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromEvent: function() { return /* binding */ fromEvent; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Observable */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _operators_mergeMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../operators/mergeMap */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/isArrayLike */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n/* harmony import */ var _util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mapOneOrManyArgs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js\");\n\n\n\n\n\n\n\nvar nodeEventEmitterMethods = [\n    \"addListener\",\n    \"removeListener\"\n];\nvar eventTargetMethods = [\n    \"addEventListener\",\n    \"removeEventListener\"\n];\nvar jqueryMethods = [\n    \"on\",\n    \"off\"\n];\nfunction fromEvent(target, eventName, options, resultSelector) {\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe((0,_util_mapOneOrManyArgs__WEBPACK_IMPORTED_MODULE_1__.mapOneOrManyArgs)(resultSelector));\n    }\n    var _a = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__read)(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {\n        return function(handler) {\n            return target[methodName](eventName, handler, options);\n        };\n    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];\n    if (!add) {\n        if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_3__.isArrayLike)(target)) {\n            return (0,_operators_mergeMap__WEBPACK_IMPORTED_MODULE_4__.mergeMap)(function(subTarget) {\n                return fromEvent(subTarget, eventName, options);\n            })((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_5__.innerFrom)(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError(\"Invalid event target\");\n    }\n    return new _Observable__WEBPACK_IMPORTED_MODULE_6__.Observable(function(subscriber) {\n        var handler = function() {\n            var args = [];\n            for(var _i = 0; _i < arguments.length; _i++){\n                args[_i] = arguments[_i];\n            }\n            return subscriber.next(1 < args.length ? args : args[0]);\n        };\n        add(handler);\n        return function() {\n            return remove(handler);\n        };\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return function(methodName) {\n        return function(handler) {\n            return target[methodName](eventName, handler);\n        };\n    };\n}\nfunction isNodeStyleEventEmitter(target) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.addListener) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.on) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.off);\n}\nfunction isEventTarget(target) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.addEventListener) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target.removeEventListener);\n} //# sourceMappingURL=fromEvent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQjtBQUNxQjtBQUNUO0FBQ007QUFDQztBQUNGO0FBQ1k7QUFDNUQsSUFBSU8sMEJBQTBCO0lBQUM7SUFBZTtDQUFpQjtBQUMvRCxJQUFJQyxxQkFBcUI7SUFBQztJQUFvQjtDQUFzQjtBQUNwRSxJQUFJQyxnQkFBZ0I7SUFBQztJQUFNO0NBQU07QUFDMUIsU0FBU0MsVUFBVUMsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsY0FBYztJQUNoRSxJQUFJVCw0REFBVUEsQ0FBQ1EsVUFBVTtRQUNyQkMsaUJBQWlCRDtRQUNqQkEsVUFBVUU7SUFDZDtJQUNBLElBQUlELGdCQUFnQjtRQUNoQixPQUFPSixVQUFVQyxRQUFRQyxXQUFXQyxTQUFTRyxJQUFJLENBQUNWLHdFQUFnQkEsQ0FBQ1E7SUFDdkU7SUFDQSxJQUFJRyxLQUFLakIsNkNBQU1BLENBQUNrQixjQUFjUCxVQUN4QkgsbUJBQW1CVyxHQUFHLENBQUMsU0FBVUMsVUFBVTtRQUFJLE9BQU8sU0FBVUMsT0FBTztZQUFJLE9BQU9WLE1BQU0sQ0FBQ1MsV0FBVyxDQUFDUixXQUFXUyxTQUFTUjtRQUFVO0lBQUcsS0FFcElTLHdCQUF3QlgsVUFDbEJKLHdCQUF3QlksR0FBRyxDQUFDSSx3QkFBd0JaLFFBQVFDLGNBQzVEWSwwQkFBMEJiLFVBQ3RCRixjQUFjVSxHQUFHLENBQUNJLHdCQUF3QlosUUFBUUMsY0FDbEQsRUFBRSxFQUFFLElBQUlhLE1BQU1SLEVBQUUsQ0FBQyxFQUFFLEVBQUVTLFNBQVNULEVBQUUsQ0FBQyxFQUFFO0lBQ3JELElBQUksQ0FBQ1EsS0FBSztRQUNOLElBQUlyQiw4REFBV0EsQ0FBQ08sU0FBUztZQUNyQixPQUFPUiw2REFBUUEsQ0FBQyxTQUFVd0IsU0FBUztnQkFBSSxPQUFPakIsVUFBVWlCLFdBQVdmLFdBQVdDO1lBQVUsR0FBR1osZ0VBQVNBLENBQUNVO1FBQ3pHO0lBQ0o7SUFDQSxJQUFJLENBQUNjLEtBQUs7UUFDTixNQUFNLElBQUlHLFVBQVU7SUFDeEI7SUFDQSxPQUFPLElBQUkxQixtREFBVUEsQ0FBQyxTQUFVMkIsVUFBVTtRQUN0QyxJQUFJUixVQUFVO1lBQ1YsSUFBSVMsT0FBTyxFQUFFO1lBQ2IsSUFBSyxJQUFJQyxLQUFLLEdBQUdBLEtBQUtDLFVBQVVDLE1BQU0sRUFBRUYsS0FBTTtnQkFDMUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHQyxTQUFTLENBQUNELEdBQUc7WUFDNUI7WUFDQSxPQUFPRixXQUFXSyxJQUFJLENBQUMsSUFBSUosS0FBS0csTUFBTSxHQUFHSCxPQUFPQSxJQUFJLENBQUMsRUFBRTtRQUMzRDtRQUNBTCxJQUFJSjtRQUNKLE9BQU87WUFBYyxPQUFPSyxPQUFPTDtRQUFVO0lBQ2pEO0FBQ0o7QUFDQSxTQUFTRSx3QkFBd0JaLE1BQU0sRUFBRUMsU0FBUztJQUM5QyxPQUFPLFNBQVVRLFVBQVU7UUFBSSxPQUFPLFNBQVVDLE9BQU87WUFBSSxPQUFPVixNQUFNLENBQUNTLFdBQVcsQ0FBQ1IsV0FBV1M7UUFBVTtJQUFHO0FBQ2pIO0FBQ0EsU0FBU0Msd0JBQXdCWCxNQUFNO0lBQ25DLE9BQU9OLDREQUFVQSxDQUFDTSxPQUFPd0IsV0FBVyxLQUFLOUIsNERBQVVBLENBQUNNLE9BQU95QixjQUFjO0FBQzdFO0FBQ0EsU0FBU1osMEJBQTBCYixNQUFNO0lBQ3JDLE9BQU9OLDREQUFVQSxDQUFDTSxPQUFPMEIsRUFBRSxLQUFLaEMsNERBQVVBLENBQUNNLE9BQU8yQixHQUFHO0FBQ3pEO0FBQ0EsU0FBU3BCLGNBQWNQLE1BQU07SUFDekIsT0FBT04sNERBQVVBLENBQUNNLE9BQU80QixnQkFBZ0IsS0FBS2xDLDREQUFVQSxDQUFDTSxPQUFPNkIsbUJBQW1CO0FBQ3ZGLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcz85N2NkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVhZCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWVyZ2VNYXAgfSBmcm9tICcuLi9vcGVyYXRvcnMvbWVyZ2VNYXAnO1xuaW1wb3J0IHsgaXNBcnJheUxpa2UgfSBmcm9tICcuLi91dGlsL2lzQXJyYXlMaWtlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgbWFwT25lT3JNYW55QXJncyB9IGZyb20gJy4uL3V0aWwvbWFwT25lT3JNYW55QXJncyc7XG52YXIgbm9kZUV2ZW50RW1pdHRlck1ldGhvZHMgPSBbJ2FkZExpc3RlbmVyJywgJ3JlbW92ZUxpc3RlbmVyJ107XG52YXIgZXZlbnRUYXJnZXRNZXRob2RzID0gWydhZGRFdmVudExpc3RlbmVyJywgJ3JlbW92ZUV2ZW50TGlzdGVuZXInXTtcbnZhciBqcXVlcnlNZXRob2RzID0gWydvbicsICdvZmYnXTtcbmV4cG9ydCBmdW5jdGlvbiBmcm9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIG9wdGlvbnMsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZyb21FdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgb3B0aW9ucykucGlwZShtYXBPbmVPck1hbnlBcmdzKHJlc3VsdFNlbGVjdG9yKSk7XG4gICAgfVxuICAgIHZhciBfYSA9IF9fcmVhZChpc0V2ZW50VGFyZ2V0KHRhcmdldClcbiAgICAgICAgPyBldmVudFRhcmdldE1ldGhvZHMubWFwKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gdGFyZ2V0W21ldGhvZE5hbWVdKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7IH07IH0pXG4gICAgICAgIDpcbiAgICAgICAgICAgIGlzTm9kZVN0eWxlRXZlbnRFbWl0dGVyKHRhcmdldClcbiAgICAgICAgICAgICAgICA/IG5vZGVFdmVudEVtaXR0ZXJNZXRob2RzLm1hcCh0b0NvbW1vbkhhbmRsZXJSZWdpc3RyeSh0YXJnZXQsIGV2ZW50TmFtZSkpXG4gICAgICAgICAgICAgICAgOiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgPyBqcXVlcnlNZXRob2RzLm1hcCh0b0NvbW1vbkhhbmRsZXJSZWdpc3RyeSh0YXJnZXQsIGV2ZW50TmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIDogW10sIDIpLCBhZGQgPSBfYVswXSwgcmVtb3ZlID0gX2FbMV07XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZU1hcChmdW5jdGlvbiAoc3ViVGFyZ2V0KSB7IHJldHVybiBmcm9tRXZlbnQoc3ViVGFyZ2V0LCBldmVudE5hbWUsIG9wdGlvbnMpOyB9KShpbm5lckZyb20odGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0YXJnZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIubmV4dCgxIDwgYXJncy5sZW5ndGggPyBhcmdzIDogYXJnc1swXSk7XG4gICAgICAgIH07XG4gICAgICAgIGFkZChoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShoYW5kbGVyKTsgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRvQ29tbW9uSGFuZGxlclJlZ2lzdHJ5KHRhcmdldCwgZXZlbnROYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7IHJldHVybiBmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gdGFyZ2V0W21ldGhvZE5hbWVdKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07IH07XG59XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcih0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbih0YXJnZXQuYWRkTGlzdGVuZXIpICYmIGlzRnVuY3Rpb24odGFyZ2V0LnJlbW92ZUxpc3RlbmVyKTtcbn1cbmZ1bmN0aW9uIGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odGFyZ2V0Lm9uKSAmJiBpc0Z1bmN0aW9uKHRhcmdldC5vZmYpO1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNGdW5jdGlvbih0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikgJiYgaXNGdW5jdGlvbih0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnQuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVhZCIsImlubmVyRnJvbSIsIk9ic2VydmFibGUiLCJtZXJnZU1hcCIsImlzQXJyYXlMaWtlIiwiaXNGdW5jdGlvbiIsIm1hcE9uZU9yTWFueUFyZ3MiLCJub2RlRXZlbnRFbWl0dGVyTWV0aG9kcyIsImV2ZW50VGFyZ2V0TWV0aG9kcyIsImpxdWVyeU1ldGhvZHMiLCJmcm9tRXZlbnQiLCJ0YXJnZXQiLCJldmVudE5hbWUiLCJvcHRpb25zIiwicmVzdWx0U2VsZWN0b3IiLCJ1bmRlZmluZWQiLCJwaXBlIiwiX2EiLCJpc0V2ZW50VGFyZ2V0IiwibWFwIiwibWV0aG9kTmFtZSIsImhhbmRsZXIiLCJpc05vZGVTdHlsZUV2ZW50RW1pdHRlciIsInRvQ29tbW9uSGFuZGxlclJlZ2lzdHJ5IiwiaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlciIsImFkZCIsInJlbW92ZSIsInN1YlRhcmdldCIsIlR5cGVFcnJvciIsInN1YnNjcmliZXIiLCJhcmdzIiwiX2kiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJuZXh0IiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIm9uIiwib2ZmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufferCount: function() { return /* binding */ bufferCount; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(app-pages-browser)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/arrRemove */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/arrRemove.js\");\n\n\n\n\nfunction bufferCount(bufferSize, startBufferEvery) {\n    if (startBufferEvery === void 0) {\n        startBufferEvery = null;\n    }\n    startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function(source, subscriber) {\n        var buffers = [];\n        var count = 0;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function(value) {\n            var e_1, _a, e_2, _b;\n            var toEmit = null;\n            if (count++ % startBufferEvery === 0) {\n                buffers.push([]);\n            }\n            try {\n                for(var buffers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__values)(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()){\n                    var buffer = buffers_1_1.value;\n                    buffer.push(value);\n                    if (bufferSize <= buffer.length) {\n                        toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];\n                        toEmit.push(buffer);\n                    }\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            if (toEmit) {\n                try {\n                    for(var toEmit_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__values)(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()){\n                        var buffer = toEmit_1_1.value;\n                        (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(buffers, buffer);\n                        subscriber.next(buffer);\n                    }\n                } catch (e_2_1) {\n                    e_2 = {\n                        error: e_2_1\n                    };\n                } finally{\n                    try {\n                        if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);\n                    } finally{\n                        if (e_2) throw e_2.error;\n                    }\n                }\n            }\n        }, function() {\n            var e_3, _a;\n            try {\n                for(var buffers_2 = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__values)(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()){\n                    var buffer = buffers_2_1.value;\n                    subscriber.next(buffer);\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n            subscriber.complete();\n        }, undefined, function() {\n            buffers = null;\n        }));\n    });\n} //# sourceMappingURL=bufferCount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBaUM7QUFDTTtBQUN5QjtBQUNsQjtBQUN2QyxTQUFTSSxZQUFZQyxVQUFVLEVBQUVDLGdCQUFnQjtJQUNwRCxJQUFJQSxxQkFBcUIsS0FBSyxHQUFHO1FBQUVBLG1CQUFtQjtJQUFNO0lBQzVEQSxtQkFBbUJBLHFCQUFxQixRQUFRQSxxQkFBcUIsS0FBSyxJQUFJQSxtQkFBbUJEO0lBQ2pHLE9BQU9KLG1EQUFPQSxDQUFDLFNBQVVNLE1BQU0sRUFBRUMsVUFBVTtRQUN2QyxJQUFJQyxVQUFVLEVBQUU7UUFDaEIsSUFBSUMsUUFBUTtRQUNaSCxPQUFPSSxTQUFTLENBQUNULDZFQUF3QkEsQ0FBQ00sWUFBWSxTQUFVSSxLQUFLO1lBQ2pFLElBQUlDLEtBQUtDLElBQUlDLEtBQUtDO1lBQ2xCLElBQUlDLFNBQVM7WUFDYixJQUFJUCxVQUFVSixxQkFBcUIsR0FBRztnQkFDbENHLFFBQVFTLElBQUksQ0FBQyxFQUFFO1lBQ25CO1lBQ0EsSUFBSTtnQkFDQSxJQUFLLElBQUlDLFlBQVluQiwrQ0FBUUEsQ0FBQ1MsVUFBVVcsY0FBY0QsVUFBVUUsSUFBSSxJQUFJLENBQUNELFlBQVlFLElBQUksRUFBRUYsY0FBY0QsVUFBVUUsSUFBSSxHQUFJO29CQUN2SCxJQUFJRSxTQUFTSCxZQUFZUixLQUFLO29CQUM5QlcsT0FBT0wsSUFBSSxDQUFDTjtvQkFDWixJQUFJUCxjQUFja0IsT0FBT0MsTUFBTSxFQUFFO3dCQUM3QlAsU0FBU0EsV0FBVyxRQUFRQSxXQUFXLEtBQUssSUFBSUEsU0FBUyxFQUFFO3dCQUMzREEsT0FBT0MsSUFBSSxDQUFDSztvQkFDaEI7Z0JBQ0o7WUFDSixFQUNBLE9BQU9FLE9BQU87Z0JBQUVaLE1BQU07b0JBQUVhLE9BQU9EO2dCQUFNO1lBQUcsU0FDaEM7Z0JBQ0osSUFBSTtvQkFDQSxJQUFJTCxlQUFlLENBQUNBLFlBQVlFLElBQUksSUFBS1IsQ0FBQUEsS0FBS0ssVUFBVVEsTUFBTSxHQUFHYixHQUFHYyxJQUFJLENBQUNUO2dCQUM3RSxTQUNRO29CQUFFLElBQUlOLEtBQUssTUFBTUEsSUFBSWEsS0FBSztnQkFBRTtZQUN4QztZQUNBLElBQUlULFFBQVE7Z0JBQ1IsSUFBSTtvQkFDQSxJQUFLLElBQUlZLFdBQVc3QiwrQ0FBUUEsQ0FBQ2lCLFNBQVNhLGFBQWFELFNBQVNSLElBQUksSUFBSSxDQUFDUyxXQUFXUixJQUFJLEVBQUVRLGFBQWFELFNBQVNSLElBQUksR0FBSTt3QkFDaEgsSUFBSUUsU0FBU08sV0FBV2xCLEtBQUs7d0JBQzdCVCwwREFBU0EsQ0FBQ00sU0FBU2M7d0JBQ25CZixXQUFXYSxJQUFJLENBQUNFO29CQUNwQjtnQkFDSixFQUNBLE9BQU9RLE9BQU87b0JBQUVoQixNQUFNO3dCQUFFVyxPQUFPSztvQkFBTTtnQkFBRyxTQUNoQztvQkFDSixJQUFJO3dCQUNBLElBQUlELGNBQWMsQ0FBQ0EsV0FBV1IsSUFBSSxJQUFLTixDQUFBQSxLQUFLYSxTQUFTRixNQUFNLEdBQUdYLEdBQUdZLElBQUksQ0FBQ0M7b0JBQzFFLFNBQ1E7d0JBQUUsSUFBSWQsS0FBSyxNQUFNQSxJQUFJVyxLQUFLO29CQUFFO2dCQUN4QztZQUNKO1FBQ0osR0FBRztZQUNDLElBQUlNLEtBQUtsQjtZQUNULElBQUk7Z0JBQ0EsSUFBSyxJQUFJbUIsWUFBWWpDLCtDQUFRQSxDQUFDUyxVQUFVeUIsY0FBY0QsVUFBVVosSUFBSSxJQUFJLENBQUNhLFlBQVlaLElBQUksRUFBRVksY0FBY0QsVUFBVVosSUFBSSxHQUFJO29CQUN2SCxJQUFJRSxTQUFTVyxZQUFZdEIsS0FBSztvQkFDOUJKLFdBQVdhLElBQUksQ0FBQ0U7Z0JBQ3BCO1lBQ0osRUFDQSxPQUFPWSxPQUFPO2dCQUFFSCxNQUFNO29CQUFFTixPQUFPUztnQkFBTTtZQUFHLFNBQ2hDO2dCQUNKLElBQUk7b0JBQ0EsSUFBSUQsZUFBZSxDQUFDQSxZQUFZWixJQUFJLElBQUtSLENBQUFBLEtBQUttQixVQUFVTixNQUFNLEdBQUdiLEdBQUdjLElBQUksQ0FBQ0s7Z0JBQzdFLFNBQ1E7b0JBQUUsSUFBSUQsS0FBSyxNQUFNQSxJQUFJTixLQUFLO2dCQUFFO1lBQ3hDO1lBQ0FsQixXQUFXNEIsUUFBUTtRQUN2QixHQUFHQyxXQUFXO1lBQ1Y1QixVQUFVO1FBQ2Q7SUFDSjtBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvYnVmZmVyQ291bnQuanM/ZTNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3ZhbHVlcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBhcnJSZW1vdmUgfSBmcm9tICcuLi91dGlsL2FyclJlbW92ZSc7XG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyQ291bnQoYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSkge1xuICAgIGlmIChzdGFydEJ1ZmZlckV2ZXJ5ID09PSB2b2lkIDApIHsgc3RhcnRCdWZmZXJFdmVyeSA9IG51bGw7IH1cbiAgICBzdGFydEJ1ZmZlckV2ZXJ5ID0gc3RhcnRCdWZmZXJFdmVyeSAhPT0gbnVsbCAmJiBzdGFydEJ1ZmZlckV2ZXJ5ICE9PSB2b2lkIDAgPyBzdGFydEJ1ZmZlckV2ZXJ5IDogYnVmZmVyU2l6ZTtcbiAgICByZXR1cm4gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBidWZmZXJzID0gW107XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgICAgICB2YXIgdG9FbWl0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb3VudCsrICUgc3RhcnRCdWZmZXJFdmVyeSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ1ZmZlcnNfMSA9IF9fdmFsdWVzKGJ1ZmZlcnMpLCBidWZmZXJzXzFfMSA9IGJ1ZmZlcnNfMS5uZXh0KCk7ICFidWZmZXJzXzFfMS5kb25lOyBidWZmZXJzXzFfMSA9IGJ1ZmZlcnNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJTaXplIDw9IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvRW1pdCA9IHRvRW1pdCAhPT0gbnVsbCAmJiB0b0VtaXQgIT09IHZvaWQgMCA/IHRvRW1pdCA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9FbWl0LnB1c2goYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyc18xXzEgJiYgIWJ1ZmZlcnNfMV8xLmRvbmUgJiYgKF9hID0gYnVmZmVyc18xLnJldHVybikpIF9hLmNhbGwoYnVmZmVyc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvRW1pdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRvRW1pdF8xID0gX192YWx1ZXModG9FbWl0KSwgdG9FbWl0XzFfMSA9IHRvRW1pdF8xLm5leHQoKTsgIXRvRW1pdF8xXzEuZG9uZTsgdG9FbWl0XzFfMSA9IHRvRW1pdF8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRvRW1pdF8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJSZW1vdmUoYnVmZmVycywgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9FbWl0XzFfMSAmJiAhdG9FbWl0XzFfMS5kb25lICYmIChfYiA9IHRvRW1pdF8xLnJldHVybikpIF9iLmNhbGwodG9FbWl0XzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBidWZmZXJzXzIgPSBfX3ZhbHVlcyhidWZmZXJzKSwgYnVmZmVyc18yXzEgPSBidWZmZXJzXzIubmV4dCgpOyAhYnVmZmVyc18yXzEuZG9uZTsgYnVmZmVyc18yXzEgPSBidWZmZXJzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXJzXzJfMSAmJiAhYnVmZmVyc18yXzEuZG9uZSAmJiAoX2EgPSBidWZmZXJzXzIucmV0dXJuKSkgX2EuY2FsbChidWZmZXJzXzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYnVmZmVycyA9IG51bGw7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1ZmZlckNvdW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX3ZhbHVlcyIsIm9wZXJhdGUiLCJjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIiLCJhcnJSZW1vdmUiLCJidWZmZXJDb3VudCIsImJ1ZmZlclNpemUiLCJzdGFydEJ1ZmZlckV2ZXJ5Iiwic291cmNlIiwic3Vic2NyaWJlciIsImJ1ZmZlcnMiLCJjb3VudCIsInN1YnNjcmliZSIsInZhbHVlIiwiZV8xIiwiX2EiLCJlXzIiLCJfYiIsInRvRW1pdCIsInB1c2giLCJidWZmZXJzXzEiLCJidWZmZXJzXzFfMSIsIm5leHQiLCJkb25lIiwiYnVmZmVyIiwibGVuZ3RoIiwiZV8xXzEiLCJlcnJvciIsInJldHVybiIsImNhbGwiLCJ0b0VtaXRfMSIsInRvRW1pdF8xXzEiLCJlXzJfMSIsImVfMyIsImJ1ZmZlcnNfMiIsImJ1ZmZlcnNfMl8xIiwiZV8zXzEiLCJjb21wbGV0ZSIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concatMap: function() { return /* binding */ concatMap; }\n/* harmony export */ });\n/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergeMap */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\nfunction concatMap(project, resultSelector) {\n    return (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resultSelector) ? (0,_mergeMap__WEBPACK_IMPORTED_MODULE_1__.mergeMap)(project, resultSelector, 1) : (0,_mergeMap__WEBPACK_IMPORTED_MODULE_1__.mergeMap)(project, 1);\n} //# sourceMappingURL=concatMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzQztBQUNVO0FBQ3pDLFNBQVNFLFVBQVVDLE9BQU8sRUFBRUMsY0FBYztJQUM3QyxPQUFPSCw0REFBVUEsQ0FBQ0csa0JBQWtCSixtREFBUUEsQ0FBQ0csU0FBU0MsZ0JBQWdCLEtBQUtKLG1EQUFRQSxDQUFDRyxTQUFTO0FBQ2pHLEVBQ0EscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvY29uY2F0TWFwLmpzPzVkMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVyZ2VNYXAgfSBmcm9tICcuL21lcmdlTWFwJztcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdE1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSA/IG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCAxKSA6IG1lcmdlTWFwKHByb2plY3QsIDEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uY2F0TWFwLmpzLm1hcCJdLCJuYW1lcyI6WyJtZXJnZU1hcCIsImlzRnVuY3Rpb24iLCJjb25jYXRNYXAiLCJwcm9qZWN0IiwicmVzdWx0U2VsZWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeInternals: function() { return /* binding */ mergeInternals; }\n/* harmony export */ });\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/executeSchedule */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    var buffer = [];\n    var active = 0;\n    var index = 0;\n    var isComplete = false;\n    var checkComplete = function() {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    var outerNext = function(value) {\n        return active < concurrent ? doInnerSub(value) : buffer.push(value);\n    };\n    var doInnerSub = function(value) {\n        expand && subscriber.next(value);\n        active++;\n        var innerComplete = false;\n        (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_0__.innerFrom)(project(value, index++)).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function(innerValue) {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            } else {\n                subscriber.next(innerValue);\n            }\n        }, function() {\n            innerComplete = true;\n        }, undefined, function() {\n            if (innerComplete) {\n                try {\n                    active--;\n                    var _loop_1 = function() {\n                        var bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            (0,_util_executeSchedule__WEBPACK_IMPORTED_MODULE_2__.executeSchedule)(subscriber, innerSubScheduler, function() {\n                                return doInnerSub(bufferedValue);\n                            });\n                        } else {\n                            doInnerSub(bufferedValue);\n                        }\n                    };\n                    while(buffer.length && active < concurrent){\n                        _loop_1();\n                    }\n                    checkComplete();\n                } catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, outerNext, function() {\n        isComplete = true;\n        checkComplete();\n    }));\n    return function() {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n} //# sourceMappingURL=mergeInternals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VJbnRlcm5hbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDtBQUNNO0FBQ007QUFDekQsU0FBU0csZUFBZUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUVDLG1CQUFtQjtJQUNoSSxJQUFJQyxTQUFTLEVBQUU7SUFDZixJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsUUFBUTtJQUNaLElBQUlDLGFBQWE7SUFDakIsSUFBSUMsZ0JBQWdCO1FBQ2hCLElBQUlELGNBQWMsQ0FBQ0gsT0FBT0ssTUFBTSxJQUFJLENBQUNKLFFBQVE7WUFDekNSLFdBQVdhLFFBQVE7UUFDdkI7SUFDSjtJQUNBLElBQUlDLFlBQVksU0FBVUMsS0FBSztRQUFJLE9BQVFQLFNBQVNOLGFBQWFjLFdBQVdELFNBQVNSLE9BQU9VLElBQUksQ0FBQ0Y7SUFBUztJQUMxRyxJQUFJQyxhQUFhLFNBQVVELEtBQUs7UUFDNUJYLFVBQVVKLFdBQVdrQixJQUFJLENBQUNIO1FBQzFCUDtRQUNBLElBQUlXLGdCQUFnQjtRQUNwQnhCLGdFQUFTQSxDQUFDTSxRQUFRYyxPQUFPTixVQUFVVyxTQUFTLENBQUN2Qiw2RUFBd0JBLENBQUNHLFlBQVksU0FBVXFCLFVBQVU7WUFDbEdsQixpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWFrQjtZQUN6RSxJQUFJakIsUUFBUTtnQkFDUlUsVUFBVU87WUFDZCxPQUNLO2dCQUNEckIsV0FBV2tCLElBQUksQ0FBQ0c7WUFDcEI7UUFDSixHQUFHO1lBQ0NGLGdCQUFnQjtRQUNwQixHQUFHRyxXQUFXO1lBQ1YsSUFBSUgsZUFBZTtnQkFDZixJQUFJO29CQUNBWDtvQkFDQSxJQUFJZSxVQUFVO3dCQUNWLElBQUlDLGdCQUFnQmpCLE9BQU9rQixLQUFLO3dCQUNoQyxJQUFJcEIsbUJBQW1COzRCQUNuQlQsc0VBQWVBLENBQUNJLFlBQVlLLG1CQUFtQjtnQ0FBYyxPQUFPVyxXQUFXUTs0QkFBZ0I7d0JBQ25HLE9BQ0s7NEJBQ0RSLFdBQVdRO3dCQUNmO29CQUNKO29CQUNBLE1BQU9qQixPQUFPSyxNQUFNLElBQUlKLFNBQVNOLFdBQVk7d0JBQ3pDcUI7b0JBQ0o7b0JBQ0FaO2dCQUNKLEVBQ0EsT0FBT2UsS0FBSztvQkFDUjFCLFdBQVcyQixLQUFLLENBQUNEO2dCQUNyQjtZQUNKO1FBQ0o7SUFDSjtJQUNBM0IsT0FBT3FCLFNBQVMsQ0FBQ3ZCLDZFQUF3QkEsQ0FBQ0csWUFBWWMsV0FBVztRQUM3REosYUFBYTtRQUNiQztJQUNKO0lBQ0EsT0FBTztRQUNITCx3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSSxLQUFLLElBQUlBO0lBQzlFO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9tZXJnZUludGVybmFscy5qcz81NDVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IGV4ZWN1dGVTY2hlZHVsZSB9IGZyb20gJy4uL3V0aWwvZXhlY3V0ZVNjaGVkdWxlJztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUludGVybmFscyhzb3VyY2UsIHN1YnNjcmliZXIsIHByb2plY3QsIGNvbmN1cnJlbnQsIG9uQmVmb3JlTmV4dCwgZXhwYW5kLCBpbm5lclN1YlNjaGVkdWxlciwgYWRkaXRpb25hbEZpbmFsaXplcikge1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICB2YXIgYWN0aXZlID0gMDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdmFyIGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0NvbXBsZXRlICYmICFidWZmZXIubGVuZ3RoICYmICFhY3RpdmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIG91dGVyTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gKGFjdGl2ZSA8IGNvbmN1cnJlbnQgPyBkb0lubmVyU3ViKHZhbHVlKSA6IGJ1ZmZlci5wdXNoKHZhbHVlKSk7IH07XG4gICAgdmFyIGRvSW5uZXJTdWIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgZXhwYW5kICYmIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGFjdGl2ZSsrO1xuICAgICAgICB2YXIgaW5uZXJDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBpbm5lckZyb20ocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpLnN1YnNjcmliZShjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKGlubmVyVmFsdWUpIHtcbiAgICAgICAgICAgIG9uQmVmb3JlTmV4dCA9PT0gbnVsbCB8fCBvbkJlZm9yZU5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQmVmb3JlTmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICAgICAgICBvdXRlck5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlubmVyQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbm5lckNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkVmFsdWUgPSBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbm5lclN1YlNjaGVkdWxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVTY2hlZHVsZShzdWJzY3JpYmVyLCBpbm5lclN1YlNjaGVkdWxlciwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9Jbm5lclN1YihidWZmZXJlZFZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb0lubmVyU3ViKGJ1ZmZlcmVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCAmJiBhY3RpdmUgPCBjb25jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIG91dGVyTmV4dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgY2hlY2tDb21wbGV0ZSgpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRpdGlvbmFsRmluYWxpemVyID09PSBudWxsIHx8IGFkZGl0aW9uYWxGaW5hbGl6ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxGaW5hbGl6ZXIoKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VJbnRlcm5hbHMuanMubWFwIl0sIm5hbWVzIjpbImlubmVyRnJvbSIsImV4ZWN1dGVTY2hlZHVsZSIsImNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciIsIm1lcmdlSW50ZXJuYWxzIiwic291cmNlIiwic3Vic2NyaWJlciIsInByb2plY3QiLCJjb25jdXJyZW50Iiwib25CZWZvcmVOZXh0IiwiZXhwYW5kIiwiaW5uZXJTdWJTY2hlZHVsZXIiLCJhZGRpdGlvbmFsRmluYWxpemVyIiwiYnVmZmVyIiwiYWN0aXZlIiwiaW5kZXgiLCJpc0NvbXBsZXRlIiwiY2hlY2tDb21wbGV0ZSIsImxlbmd0aCIsImNvbXBsZXRlIiwib3V0ZXJOZXh0IiwidmFsdWUiLCJkb0lubmVyU3ViIiwicHVzaCIsIm5leHQiLCJpbm5lckNvbXBsZXRlIiwic3Vic2NyaWJlIiwiaW5uZXJWYWx1ZSIsInVuZGVmaW5lZCIsIl9sb29wXzEiLCJidWZmZXJlZFZhbHVlIiwic2hpZnQiLCJlcnIiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js":
/*!********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mergeMap: function() { return /* binding */ mergeMap; }\n/* harmony export */ });\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _mergeInternals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mergeInternals */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js\");\n/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/isFunction */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/isFunction.js\");\n\n\n\n\n\nfunction mergeMap(project, resultSelector, concurrent) {\n    if (concurrent === void 0) {\n        concurrent = Infinity;\n    }\n    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resultSelector)) {\n        return mergeMap(function(a, i) {\n            return (0,_map__WEBPACK_IMPORTED_MODULE_1__.map)(function(b, ii) {\n                return resultSelector(a, b, i, ii);\n            })((0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(project(a, i)));\n        }, concurrent);\n    } else if (typeof resultSelector === \"number\") {\n        concurrent = resultSelector;\n    }\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_3__.operate)(function(source, subscriber) {\n        return (0,_mergeInternals__WEBPACK_IMPORTED_MODULE_4__.mergeInternals)(source, subscriber, project, concurrent);\n    });\n} //# sourceMappingURL=mergeMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvbWVyZ2VNYXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRCO0FBQ3dCO0FBQ2I7QUFDVztBQUNGO0FBQ3pDLFNBQVNLLFNBQVNDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxVQUFVO0lBQ3hELElBQUlBLGVBQWUsS0FBSyxHQUFHO1FBQUVBLGFBQWFDO0lBQVU7SUFDcEQsSUFBSUwsNERBQVVBLENBQUNHLGlCQUFpQjtRQUM1QixPQUFPRixTQUFTLFNBQVVLLENBQUMsRUFBRUMsQ0FBQztZQUFJLE9BQU9YLHlDQUFHQSxDQUFDLFNBQVVZLENBQUMsRUFBRUMsRUFBRTtnQkFBSSxPQUFPTixlQUFlRyxHQUFHRSxHQUFHRCxHQUFHRTtZQUFLLEdBQUdaLGdFQUFTQSxDQUFDSyxRQUFRSSxHQUFHQztRQUFNLEdBQUdIO0lBQ3pJLE9BQ0ssSUFBSSxPQUFPRCxtQkFBbUIsVUFBVTtRQUN6Q0MsYUFBYUQ7SUFDakI7SUFDQSxPQUFPTCxtREFBT0EsQ0FBQyxTQUFVWSxNQUFNLEVBQUVDLFVBQVU7UUFBSSxPQUFPWiwrREFBY0EsQ0FBQ1csUUFBUUMsWUFBWVQsU0FBU0U7SUFBYTtBQUNuSCxFQUNBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL21lcmdlTWFwLmpzPzM3YzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9tYXAnO1xuaW1wb3J0IHsgaW5uZXJGcm9tIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9pbm5lckZyb20nO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBtZXJnZUludGVybmFscyB9IGZyb20gJy4vbWVyZ2VJbnRlcm5hbHMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXNGdW5jdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBJbmZpbml0eTsgfVxuICAgIGlmIChpc0Z1bmN0aW9uKHJlc3VsdFNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VNYXAoZnVuY3Rpb24gKGEsIGkpIHsgcmV0dXJuIG1hcChmdW5jdGlvbiAoYiwgaWkpIHsgcmV0dXJuIHJlc3VsdFNlbGVjdG9yKGEsIGIsIGksIGlpKTsgfSkoaW5uZXJGcm9tKHByb2plY3QoYSwgaSkpKTsgfSwgY29uY3VycmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7IHJldHVybiBtZXJnZUludGVybmFscyhzb3VyY2UsIHN1YnNjcmliZXIsIHByb2plY3QsIGNvbmN1cnJlbnQpOyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcCJdLCJuYW1lcyI6WyJtYXAiLCJpbm5lckZyb20iLCJvcGVyYXRlIiwibWVyZ2VJbnRlcm5hbHMiLCJpc0Z1bmN0aW9uIiwibWVyZ2VNYXAiLCJwcm9qZWN0IiwicmVzdWx0U2VsZWN0b3IiLCJjb25jdXJyZW50IiwiSW5maW5pdHkiLCJhIiwiaSIsImIiLCJpaSIsInNvdXJjZSIsInN1YnNjcmliZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/take.js":
/*!****************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/take.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   take: function() { return /* binding */ take; }\n/* harmony export */ });\n/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/empty */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n\n\n\nfunction take(count) {\n    return count <= 0 ? function() {\n        return _observable_empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY;\n    } : (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function(source, subscriber) {\n        var seen = 0;\n        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function(value) {\n            if (++seen <= count) {\n                subscriber.next(value);\n                if (count <= seen) {\n                    subscriber.complete();\n                }\n            }\n        }));\n    });\n} //# sourceMappingURL=take.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ0w7QUFDeUI7QUFDekQsU0FBU0csS0FBS0MsS0FBSztJQUN0QixPQUFPQSxTQUFTLElBRVI7UUFBYyxPQUFPSixvREFBS0E7SUFBRSxJQUM5QkMsbURBQU9BLENBQUMsU0FBVUksTUFBTSxFQUFFQyxVQUFVO1FBQ2xDLElBQUlDLE9BQU87UUFDWEYsT0FBT0csU0FBUyxDQUFDTiw2RUFBd0JBLENBQUNJLFlBQVksU0FBVUcsS0FBSztZQUNqRSxJQUFJLEVBQUVGLFFBQVFILE9BQU87Z0JBQ2pCRSxXQUFXSSxJQUFJLENBQUNEO2dCQUNoQixJQUFJTCxTQUFTRyxNQUFNO29CQUNmRCxXQUFXSyxRQUFRO2dCQUN2QjtZQUNKO1FBQ0o7SUFDSjtBQUNSLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZS5qcz8zYjBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVNUFRZIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9lbXB0eSc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiB0YWtlKGNvdW50KSB7XG4gICAgcmV0dXJuIGNvdW50IDw9IDBcbiAgICAgICAgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gRU1QVFk7IH1cbiAgICAgICAgOiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWVuID0gMDtcbiAgICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgrK3NlZW4gPD0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50IDw9IHNlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcCJdLCJuYW1lcyI6WyJFTVBUWSIsIm9wZXJhdGUiLCJjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIiLCJ0YWtlIiwiY291bnQiLCJzb3VyY2UiLCJzdWJzY3JpYmVyIiwic2VlbiIsInN1YnNjcmliZSIsInZhbHVlIiwibmV4dCIsImNvbXBsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/take.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   takeUntil: function() { return /* binding */ takeUntil; }\n/* harmony export */ });\n/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/lift.js\");\n/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js\");\n/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../observable/innerFrom */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js\");\n/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/noop */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/noop.js\");\n\n\n\n\nfunction takeUntil(notifier) {\n    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function(source, subscriber) {\n        (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_1__.innerFrom)(notifier).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function() {\n            return subscriber.complete();\n        }, _util_noop__WEBPACK_IMPORTED_MODULE_3__.noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n} //# sourceMappingURL=takeUntil.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvdGFrZVVudGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ3lCO0FBQ1o7QUFDaEI7QUFDN0IsU0FBU0ksVUFBVUMsUUFBUTtJQUM5QixPQUFPTCxtREFBT0EsQ0FBQyxTQUFVTSxNQUFNLEVBQUVDLFVBQVU7UUFDdkNMLGdFQUFTQSxDQUFDRyxVQUFVRyxTQUFTLENBQUNQLDZFQUF3QkEsQ0FBQ00sWUFBWTtZQUFjLE9BQU9BLFdBQVdFLFFBQVE7UUFBSSxHQUFHTiw0Q0FBSUE7UUFDdEgsQ0FBQ0ksV0FBV0csTUFBTSxJQUFJSixPQUFPRSxTQUFTLENBQUNEO0lBQzNDO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlVW50aWwuanM/YmJiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmltcG9ydCB7IGlubmVyRnJvbSB9IGZyb20gJy4uL29ic2VydmFibGUvaW5uZXJGcm9tJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL25vb3AnO1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgaW5uZXJGcm9tKG5vdGlmaWVyKS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTsgfSwgbm9vcCkpO1xuICAgICAgICAhc3Vic2NyaWJlci5jbG9zZWQgJiYgc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VVbnRpbC5qcy5tYXAiXSwibmFtZXMiOlsib3BlcmF0ZSIsImNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciIsImlubmVyRnJvbSIsIm5vb3AiLCJ0YWtlVW50aWwiLCJub3RpZmllciIsInNvdXJjZSIsInN1YnNjcmliZXIiLCJzdWJzY3JpYmUiLCJjb21wbGV0ZSIsImNsb3NlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/xstate/actors/dist/xstate-actors.development.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyActor: function() { return /* binding */ createEmptyActor; },\n/* harmony export */   fromCallback: function() { return /* binding */ fromCallback; },\n/* harmony export */   fromEventObservable: function() { return /* binding */ fromEventObservable; },\n/* harmony export */   fromObservable: function() { return /* binding */ fromObservable; },\n/* harmony export */   fromPromise: function() { return /* binding */ fromPromise; },\n/* harmony export */   fromTransition: function() { return /* binding */ fromTransition; }\n/* harmony export */ });\n/* harmony import */ var _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/raise-1db27a82.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dev/dist/xstate-dev.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */ /**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromTransition(transition, initialContext) {\n    return {\n        config: transition,\n        transition: (snapshot, event, actorScope)=>{\n            return {\n                ...snapshot,\n                context: transition(snapshot.context, event, actorScope)\n            };\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: typeof initialContext === \"function\" ? initialContext({\n                    input\n                }) : initialContext\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n}\nconst instanceStates = /* #__PURE__ */ new WeakMap();\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */ /**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromCallback(callback) {\n    const logic = {\n        config: callback,\n        start: (state, actorScope)=>{\n            const { self, system, emit } = actorScope;\n            const callbackState = {\n                receivers: undefined,\n                dispose: undefined\n            };\n            instanceStates.set(self, callbackState);\n            callbackState.dispose = callback({\n                input: state.input,\n                system,\n                self,\n                sendBack: (event)=>{\n                    if (self.getSnapshot().status === \"stopped\") {\n                        return;\n                    }\n                    if (self._parent) {\n                        system._relay(self, self._parent, event);\n                    }\n                },\n                receive: (listener)=>{\n                    var _callbackState;\n                    var _receivers;\n                    (_receivers = (_callbackState = callbackState).receivers) !== null && _receivers !== void 0 ? _receivers : _callbackState.receivers = new Set();\n                    callbackState.receivers.add(listener);\n                },\n                emit\n            });\n        },\n        transition: (state, event, actorScope)=>{\n            var _callbackState_receivers;\n            const callbackState = instanceStates.get(actorScope.self);\n            if (event.type === _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X) {\n                var _callbackState_dispose;\n                state = {\n                    ...state,\n                    status: \"stopped\",\n                    error: undefined\n                };\n                (_callbackState_dispose = callbackState.dispose) === null || _callbackState_dispose === void 0 ? void 0 : _callbackState_dispose.call(callbackState);\n                return state;\n            }\n            (_callbackState_receivers = callbackState.receivers) === null || _callbackState_receivers === void 0 ? void 0 : _callbackState_receivers.forEach((receiver)=>receiver(event));\n            return state;\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = \"xstate.observable.next\";\nconst XSTATE_OBSERVABLE_ERROR = \"xstate.observable.error\";\nconst XSTATE_OBSERVABLE_COMPLETE = \"xstate.observable.complete\";\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */ /**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */ function fromObservable(observableCreator) {\n    // TODO: add event types\n    const logic = {\n        config: observableCreator,\n        transition: (snapshot, event)=>{\n            if (snapshot.status !== \"active\") {\n                return snapshot;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_NEXT:\n                    {\n                        const newSnapshot = {\n                            ...snapshot,\n                            context: event.data\n                        };\n                        return newSnapshot;\n                    }\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...snapshot,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...snapshot,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    snapshot._subscription.unsubscribe();\n                    return {\n                        ...snapshot,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return snapshot;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, param)=>{\n            let { self, system, emit } = param;\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = observableCreator({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_NEXT,\n                        data: value\n                    });\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: (param)=>{\n            let { _subscription, ...state } = param;\n            return state;\n        },\n        restoreSnapshot: (state)=>({\n                ...state,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */ function fromEventObservable(lazyObservable) {\n    // TODO: event types\n    const logic = {\n        config: lazyObservable,\n        transition: (state, event)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_OBSERVABLE_ERROR:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case XSTATE_OBSERVABLE_COMPLETE:\n                    return {\n                        ...state,\n                        status: \"done\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                case _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    state._subscription.unsubscribe();\n                    return {\n                        ...state,\n                        status: \"stopped\",\n                        input: undefined,\n                        _subscription: undefined\n                    };\n                default:\n                    return state;\n            }\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                context: undefined,\n                input,\n                _subscription: undefined\n            };\n        },\n        start: (state, param)=>{\n            let { self, system, emit } = param;\n            if (state.status === \"done\") {\n                // Do not restart a completed observable\n                return;\n            }\n            state._subscription = lazyObservable({\n                input: state.input,\n                system,\n                self,\n                emit\n            }).subscribe({\n                next: (value)=>{\n                    if (self._parent) {\n                        system._relay(self, self._parent, value);\n                    }\n                },\n                error: (err)=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_ERROR,\n                        data: err\n                    });\n                },\n                complete: ()=>{\n                    system._relay(self, self, {\n                        type: XSTATE_OBSERVABLE_COMPLETE\n                    });\n                }\n            });\n        },\n        getPersistedSnapshot: (param)=>{\n            let { _subscription, ...snapshot } = param;\n            return snapshot;\n        },\n        restoreSnapshot: (snapshot)=>({\n                ...snapshot,\n                _subscription: undefined\n            })\n    };\n    return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = \"xstate.promise.resolve\";\nconst XSTATE_PROMISE_REJECT = \"xstate.promise.reject\";\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */ const controllerMap = new WeakMap();\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */ function fromPromise(promiseCreator) {\n    const logic = {\n        config: promiseCreator,\n        transition: (state, event, scope)=>{\n            if (state.status !== \"active\") {\n                return state;\n            }\n            switch(event.type){\n                case XSTATE_PROMISE_RESOLVE:\n                    {\n                        const resolvedValue = event.data;\n                        return {\n                            ...state,\n                            status: \"done\",\n                            output: resolvedValue,\n                            input: undefined\n                        };\n                    }\n                case XSTATE_PROMISE_REJECT:\n                    return {\n                        ...state,\n                        status: \"error\",\n                        error: event.data,\n                        input: undefined\n                    };\n                case _dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.X:\n                    {\n                        var _controllerMap_get;\n                        (_controllerMap_get = controllerMap.get(scope.self)) === null || _controllerMap_get === void 0 ? void 0 : _controllerMap_get.abort();\n                        return {\n                            ...state,\n                            status: \"stopped\",\n                            input: undefined\n                        };\n                    }\n                default:\n                    return state;\n            }\n        },\n        start: (state, param)=>{\n            let { self, system, emit } = param;\n            // TODO: determine how to allow customizing this so that promises\n            // can be restarted if necessary\n            if (state.status !== \"active\") {\n                return;\n            }\n            const controller = new AbortController();\n            controllerMap.set(self, controller);\n            const resolvedPromise = Promise.resolve(promiseCreator({\n                input: state.input,\n                system,\n                self,\n                signal: controller.signal,\n                emit\n            }));\n            resolvedPromise.then((response)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_RESOLVE,\n                    data: response\n                });\n            }, (errorData)=>{\n                if (self.getSnapshot().status !== \"active\") {\n                    return;\n                }\n                controllerMap.delete(self);\n                system._relay(self, self, {\n                    type: XSTATE_PROMISE_REJECT,\n                    data: errorData\n                });\n            });\n        },\n        getInitialSnapshot: (_, input)=>{\n            return {\n                status: \"active\",\n                output: undefined,\n                error: undefined,\n                input\n            };\n        },\n        getPersistedSnapshot: (snapshot)=>snapshot,\n        restoreSnapshot: (snapshot)=>snapshot\n    };\n    return logic;\n}\nconst emptyLogic = fromTransition((_)=>undefined, undefined);\nfunction createEmptyActor() {\n    return (0,_dist_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(emptyLogic);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvYWN0b3JzL2Rpc3QveHN0YXRlLWFjdG9ycy5kZXZlbG9wbWVudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0c7QUFDNUM7QUFFdEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlEQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeUVDLEdBQ0QsU0FBU0ksZUFBZUMsVUFBVSxFQUFFQyxjQUFjO0lBQ2hELE9BQU87UUFDTEMsUUFBUUY7UUFDUkEsWUFBWSxDQUFDRyxVQUFVQyxPQUFPQztZQUM1QixPQUFPO2dCQUNMLEdBQUdGLFFBQVE7Z0JBQ1hHLFNBQVNOLFdBQVdHLFNBQVNHLE9BQU8sRUFBRUYsT0FBT0M7WUFDL0M7UUFDRjtRQUNBRSxvQkFBb0IsQ0FBQ0MsR0FBR0M7WUFDdEIsT0FBTztnQkFDTEMsUUFBUTtnQkFDUkMsUUFBUUM7Z0JBQ1JDLE9BQU9EO2dCQUNQTixTQUFTLE9BQU9MLG1CQUFtQixhQUFhQSxlQUFlO29CQUM3RFE7Z0JBQ0YsS0FBS1I7WUFDUDtRQUNGO1FBQ0FhLHNCQUFzQlgsQ0FBQUEsV0FBWUE7UUFDbENZLGlCQUFpQlosQ0FBQUEsV0FBWUE7SUFDL0I7QUFDRjtBQUVBLE1BQU1hLGlCQUFpQixhQUFhLEdBQUUsSUFBSUM7QUFFMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlDQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlFQyxHQUNELFNBQVNDLGFBQWFDLFFBQVE7SUFDNUIsTUFBTUMsUUFBUTtRQUNabEIsUUFBUWlCO1FBQ1JFLE9BQU8sQ0FBQ0MsT0FBT2pCO1lBQ2IsTUFBTSxFQUNKa0IsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLElBQUksRUFDTCxHQUFHcEI7WUFDSixNQUFNcUIsZ0JBQWdCO2dCQUNwQkMsV0FBV2Y7Z0JBQ1hnQixTQUFTaEI7WUFDWDtZQUNBSSxlQUFlYSxHQUFHLENBQUNOLE1BQU1HO1lBQ3pCQSxjQUFjRSxPQUFPLEdBQUdULFNBQVM7Z0JBQy9CVixPQUFPYSxNQUFNYixLQUFLO2dCQUNsQmU7Z0JBQ0FEO2dCQUNBTyxVQUFVMUIsQ0FBQUE7b0JBQ1IsSUFBSW1CLEtBQUtRLFdBQVcsR0FBR3JCLE1BQU0sS0FBSyxXQUFXO3dCQUMzQztvQkFDRjtvQkFDQSxJQUFJYSxLQUFLUyxPQUFPLEVBQUU7d0JBQ2hCUixPQUFPUyxNQUFNLENBQUNWLE1BQU1BLEtBQUtTLE9BQU8sRUFBRTVCO29CQUNwQztnQkFDRjtnQkFDQThCLFNBQVNDLENBQUFBO3dCQUNQVDs7b0JBQUFBLGVBQUFBLGlCQUFBQSxlQUFjQyw0REFBZEQsZUFBY0MsWUFBYyxJQUFJUztvQkFDaENWLGNBQWNDLFNBQVMsQ0FBQ1UsR0FBRyxDQUFDRjtnQkFDOUI7Z0JBQ0FWO1lBQ0Y7UUFDRjtRQUNBekIsWUFBWSxDQUFDc0IsT0FBT2xCLE9BQU9DO2dCQVd6QnFCO1lBVkEsTUFBTUEsZ0JBQWdCVixlQUFlc0IsR0FBRyxDQUFDakMsV0FBV2tCLElBQUk7WUFDeEQsSUFBSW5CLE1BQU1tQyxJQUFJLEtBQUszQyxzRUFBV0EsRUFBRTtvQkFNOUI4QjtnQkFMQUosUUFBUTtvQkFDTixHQUFHQSxLQUFLO29CQUNSWixRQUFRO29CQUNSRyxPQUFPRDtnQkFDVDtpQkFDQWMseUJBQUFBLGNBQWNFLE9BQU8sY0FBckJGLDZDQUFBQSw0QkFBQUE7Z0JBQ0EsT0FBT0o7WUFDVDthQUNBSSwyQkFBQUEsY0FBY0MsU0FBUyxjQUF2QkQsK0NBQUFBLHlCQUF5QmMsT0FBTyxDQUFDQyxDQUFBQSxXQUFZQSxTQUFTckM7WUFDdEQsT0FBT2tCO1FBQ1Q7UUFDQWYsb0JBQW9CLENBQUNDLEdBQUdDO1lBQ3RCLE9BQU87Z0JBQ0xDLFFBQVE7Z0JBQ1JDLFFBQVFDO2dCQUNSQyxPQUFPRDtnQkFDUEg7WUFDRjtRQUNGO1FBQ0FLLHNCQUFzQlgsQ0FBQUEsV0FBWUE7UUFDbENZLGlCQUFpQlosQ0FBQUEsV0FBWUE7SUFDL0I7SUFDQSxPQUFPaUI7QUFDVDtBQUVBLE1BQU1zQix5QkFBeUI7QUFDL0IsTUFBTUMsMEJBQTBCO0FBQ2hDLE1BQU1DLDZCQUE2QjtBQUVuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQStCQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBMkNDLEdBQ0QsU0FBU0MsZUFBZUMsaUJBQWlCO0lBQ3ZDLHdCQUF3QjtJQUN4QixNQUFNMUIsUUFBUTtRQUNabEIsUUFBUTRDO1FBQ1I5QyxZQUFZLENBQUNHLFVBQVVDO1lBQ3JCLElBQUlELFNBQVNPLE1BQU0sS0FBSyxVQUFVO2dCQUNoQyxPQUFPUDtZQUNUO1lBQ0EsT0FBUUMsTUFBTW1DLElBQUk7Z0JBQ2hCLEtBQUtHO29CQUNIO3dCQUNFLE1BQU1LLGNBQWM7NEJBQ2xCLEdBQUc1QyxRQUFROzRCQUNYRyxTQUFTRixNQUFNNEMsSUFBSTt3QkFDckI7d0JBQ0EsT0FBT0Q7b0JBQ1Q7Z0JBQ0YsS0FBS0o7b0JBQ0gsT0FBTzt3QkFDTCxHQUFHeEMsUUFBUTt3QkFDWE8sUUFBUTt3QkFDUkcsT0FBT1QsTUFBTTRDLElBQUk7d0JBQ2pCdkMsT0FBT0c7d0JBQ1BxQyxlQUFlckM7b0JBQ2pCO2dCQUNGLEtBQUtnQztvQkFDSCxPQUFPO3dCQUNMLEdBQUd6QyxRQUFRO3dCQUNYTyxRQUFRO3dCQUNSRCxPQUFPRzt3QkFDUHFDLGVBQWVyQztvQkFDakI7Z0JBQ0YsS0FBS2hCLHNFQUFXQTtvQkFDZE8sU0FBUzhDLGFBQWEsQ0FBQ0MsV0FBVztvQkFDbEMsT0FBTzt3QkFDTCxHQUFHL0MsUUFBUTt3QkFDWE8sUUFBUTt3QkFDUkQsT0FBT0c7d0JBQ1BxQyxlQUFlckM7b0JBQ2pCO2dCQUNGO29CQUNFLE9BQU9UO1lBQ1g7UUFDRjtRQUNBSSxvQkFBb0IsQ0FBQ0MsR0FBR0M7WUFDdEIsT0FBTztnQkFDTEMsUUFBUTtnQkFDUkMsUUFBUUM7Z0JBQ1JDLE9BQU9EO2dCQUNQTixTQUFTTTtnQkFDVEg7Z0JBQ0F3QyxlQUFlckM7WUFDakI7UUFDRjtRQUNBUyxPQUFPLENBQUNDO2dCQUFPLEVBQ2JDLElBQUksRUFDSkMsTUFBTSxFQUNOQyxJQUFJLEVBQ0w7WUFDQyxJQUFJSCxNQUFNWixNQUFNLEtBQUssUUFBUTtnQkFDM0Isd0NBQXdDO2dCQUN4QztZQUNGO1lBQ0FZLE1BQU0yQixhQUFhLEdBQUdILGtCQUFrQjtnQkFDdENyQyxPQUFPYSxNQUFNYixLQUFLO2dCQUNsQmU7Z0JBQ0FEO2dCQUNBRTtZQUNGLEdBQUcwQixTQUFTLENBQUM7Z0JBQ1hDLE1BQU1DLENBQUFBO29CQUNKN0IsT0FBT1MsTUFBTSxDQUFDVixNQUFNQSxNQUFNO3dCQUN4QmdCLE1BQU1HO3dCQUNOTSxNQUFNSztvQkFDUjtnQkFDRjtnQkFDQXhDLE9BQU95QyxDQUFBQTtvQkFDTDlCLE9BQU9TLE1BQU0sQ0FBQ1YsTUFBTUEsTUFBTTt3QkFDeEJnQixNQUFNSTt3QkFDTkssTUFBTU07b0JBQ1I7Z0JBQ0Y7Z0JBQ0FDLFVBQVU7b0JBQ1IvQixPQUFPUyxNQUFNLENBQUNWLE1BQU1BLE1BQU07d0JBQ3hCZ0IsTUFBTUs7b0JBQ1I7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0E5QixzQkFBc0I7Z0JBQUMsRUFDckJtQyxhQUFhLEVBQ2IsR0FBRzNCLE9BQ0o7bUJBQUtBOztRQUNOUCxpQkFBaUJPLENBQUFBLFFBQVU7Z0JBQ3pCLEdBQUdBLEtBQUs7Z0JBQ1IyQixlQUFlckM7WUFDakI7SUFDRjtJQUNBLE9BQU9RO0FBQ1Q7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrREMsR0FDRCxTQUFTb0Msb0JBQW9CQyxjQUFjO0lBQ3pDLG9CQUFvQjtJQUNwQixNQUFNckMsUUFBUTtRQUNabEIsUUFBUXVEO1FBQ1J6RCxZQUFZLENBQUNzQixPQUFPbEI7WUFDbEIsSUFBSWtCLE1BQU1aLE1BQU0sS0FBSyxVQUFVO2dCQUM3QixPQUFPWTtZQUNUO1lBQ0EsT0FBUWxCLE1BQU1tQyxJQUFJO2dCQUNoQixLQUFLSTtvQkFDSCxPQUFPO3dCQUNMLEdBQUdyQixLQUFLO3dCQUNSWixRQUFRO3dCQUNSRyxPQUFPVCxNQUFNNEMsSUFBSTt3QkFDakJ2QyxPQUFPRzt3QkFDUHFDLGVBQWVyQztvQkFDakI7Z0JBQ0YsS0FBS2dDO29CQUNILE9BQU87d0JBQ0wsR0FBR3RCLEtBQUs7d0JBQ1JaLFFBQVE7d0JBQ1JELE9BQU9HO3dCQUNQcUMsZUFBZXJDO29CQUNqQjtnQkFDRixLQUFLaEIsc0VBQVdBO29CQUNkMEIsTUFBTTJCLGFBQWEsQ0FBQ0MsV0FBVztvQkFDL0IsT0FBTzt3QkFDTCxHQUFHNUIsS0FBSzt3QkFDUlosUUFBUTt3QkFDUkQsT0FBT0c7d0JBQ1BxQyxlQUFlckM7b0JBQ2pCO2dCQUNGO29CQUNFLE9BQU9VO1lBQ1g7UUFDRjtRQUNBZixvQkFBb0IsQ0FBQ0MsR0FBR0M7WUFDdEIsT0FBTztnQkFDTEMsUUFBUTtnQkFDUkMsUUFBUUM7Z0JBQ1JDLE9BQU9EO2dCQUNQTixTQUFTTTtnQkFDVEg7Z0JBQ0F3QyxlQUFlckM7WUFDakI7UUFDRjtRQUNBUyxPQUFPLENBQUNDO2dCQUFPLEVBQ2JDLElBQUksRUFDSkMsTUFBTSxFQUNOQyxJQUFJLEVBQ0w7WUFDQyxJQUFJSCxNQUFNWixNQUFNLEtBQUssUUFBUTtnQkFDM0Isd0NBQXdDO2dCQUN4QztZQUNGO1lBQ0FZLE1BQU0yQixhQUFhLEdBQUdRLGVBQWU7Z0JBQ25DaEQsT0FBT2EsTUFBTWIsS0FBSztnQkFDbEJlO2dCQUNBRDtnQkFDQUU7WUFDRixHQUFHMEIsU0FBUyxDQUFDO2dCQUNYQyxNQUFNQyxDQUFBQTtvQkFDSixJQUFJOUIsS0FBS1MsT0FBTyxFQUFFO3dCQUNoQlIsT0FBT1MsTUFBTSxDQUFDVixNQUFNQSxLQUFLUyxPQUFPLEVBQUVxQjtvQkFDcEM7Z0JBQ0Y7Z0JBQ0F4QyxPQUFPeUMsQ0FBQUE7b0JBQ0w5QixPQUFPUyxNQUFNLENBQUNWLE1BQU1BLE1BQU07d0JBQ3hCZ0IsTUFBTUk7d0JBQ05LLE1BQU1NO29CQUNSO2dCQUNGO2dCQUNBQyxVQUFVO29CQUNSL0IsT0FBT1MsTUFBTSxDQUFDVixNQUFNQSxNQUFNO3dCQUN4QmdCLE1BQU1LO29CQUNSO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBOUIsc0JBQXNCO2dCQUFDLEVBQ3JCbUMsYUFBYSxFQUNiLEdBQUc5QyxVQUNKO21CQUFLQTs7UUFDTlksaUJBQWlCWixDQUFBQSxXQUFhO2dCQUM1QixHQUFHQSxRQUFRO2dCQUNYOEMsZUFBZXJDO1lBQ2pCO0lBQ0Y7SUFDQSxPQUFPUTtBQUNUO0FBRUEsTUFBTXNDLHlCQUF5QjtBQUMvQixNQUFNQyx3QkFBd0I7QUFFOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBZ0NDLEdBRUQsTUFBTUMsZ0JBQWdCLElBQUkzQztBQUUxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWlEQyxHQUNELFNBQVM0QyxZQUFZQyxjQUFjO0lBQ2pDLE1BQU0xQyxRQUFRO1FBQ1psQixRQUFRNEQ7UUFDUjlELFlBQVksQ0FBQ3NCLE9BQU9sQixPQUFPMkQ7WUFDekIsSUFBSXpDLE1BQU1aLE1BQU0sS0FBSyxVQUFVO2dCQUM3QixPQUFPWTtZQUNUO1lBQ0EsT0FBUWxCLE1BQU1tQyxJQUFJO2dCQUNoQixLQUFLbUI7b0JBQ0g7d0JBQ0UsTUFBTU0sZ0JBQWdCNUQsTUFBTTRDLElBQUk7d0JBQ2hDLE9BQU87NEJBQ0wsR0FBRzFCLEtBQUs7NEJBQ1JaLFFBQVE7NEJBQ1JDLFFBQVFxRDs0QkFDUnZELE9BQU9HO3dCQUNUO29CQUNGO2dCQUNGLEtBQUsrQztvQkFDSCxPQUFPO3dCQUNMLEdBQUdyQyxLQUFLO3dCQUNSWixRQUFRO3dCQUNSRyxPQUFPVCxNQUFNNEMsSUFBSTt3QkFDakJ2QyxPQUFPRztvQkFDVDtnQkFDRixLQUFLaEIsc0VBQVdBO29CQUNkOzRCQUNFZ0U7eUJBQUFBLHFCQUFBQSxjQUFjdEIsR0FBRyxDQUFDeUIsTUFBTXhDLElBQUksZUFBNUJxQyx5Q0FBQUEsbUJBQStCSyxLQUFLO3dCQUNwQyxPQUFPOzRCQUNMLEdBQUczQyxLQUFLOzRCQUNSWixRQUFROzRCQUNSRCxPQUFPRzt3QkFDVDtvQkFDRjtnQkFDRjtvQkFDRSxPQUFPVTtZQUNYO1FBQ0Y7UUFDQUQsT0FBTyxDQUFDQztnQkFBTyxFQUNiQyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsSUFBSSxFQUNMO1lBQ0MsaUVBQWlFO1lBQ2pFLGdDQUFnQztZQUNoQyxJQUFJSCxNQUFNWixNQUFNLEtBQUssVUFBVTtnQkFDN0I7WUFDRjtZQUNBLE1BQU13RCxhQUFhLElBQUlDO1lBQ3ZCUCxjQUFjL0IsR0FBRyxDQUFDTixNQUFNMkM7WUFDeEIsTUFBTUUsa0JBQWtCQyxRQUFRQyxPQUFPLENBQUNSLGVBQWU7Z0JBQ3JEckQsT0FBT2EsTUFBTWIsS0FBSztnQkFDbEJlO2dCQUNBRDtnQkFDQWdELFFBQVFMLFdBQVdLLE1BQU07Z0JBQ3pCOUM7WUFDRjtZQUNBMkMsZ0JBQWdCSSxJQUFJLENBQUNDLENBQUFBO2dCQUNuQixJQUFJbEQsS0FBS1EsV0FBVyxHQUFHckIsTUFBTSxLQUFLLFVBQVU7b0JBQzFDO2dCQUNGO2dCQUNBa0QsY0FBY2MsTUFBTSxDQUFDbkQ7Z0JBQ3JCQyxPQUFPUyxNQUFNLENBQUNWLE1BQU1BLE1BQU07b0JBQ3hCZ0IsTUFBTW1CO29CQUNOVixNQUFNeUI7Z0JBQ1I7WUFDRixHQUFHRSxDQUFBQTtnQkFDRCxJQUFJcEQsS0FBS1EsV0FBVyxHQUFHckIsTUFBTSxLQUFLLFVBQVU7b0JBQzFDO2dCQUNGO2dCQUNBa0QsY0FBY2MsTUFBTSxDQUFDbkQ7Z0JBQ3JCQyxPQUFPUyxNQUFNLENBQUNWLE1BQU1BLE1BQU07b0JBQ3hCZ0IsTUFBTW9CO29CQUNOWCxNQUFNMkI7Z0JBQ1I7WUFDRjtRQUNGO1FBQ0FwRSxvQkFBb0IsQ0FBQ0MsR0FBR0M7WUFDdEIsT0FBTztnQkFDTEMsUUFBUTtnQkFDUkMsUUFBUUM7Z0JBQ1JDLE9BQU9EO2dCQUNQSDtZQUNGO1FBQ0Y7UUFDQUssc0JBQXNCWCxDQUFBQSxXQUFZQTtRQUNsQ1ksaUJBQWlCWixDQUFBQSxXQUFZQTtJQUMvQjtJQUNBLE9BQU9pQjtBQUNUO0FBRUEsTUFBTXdELGFBQWE3RSxlQUFlUyxDQUFBQSxJQUFLSSxXQUFXQTtBQUNsRCxTQUFTaUU7SUFDUCxPQUFPL0UsMEVBQVdBLENBQUM4RTtBQUNyQjtBQUU0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveHN0YXRlL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzPzJiZjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWCBhcyBYU1RBVEVfU1RPUCwgQSBhcyBjcmVhdGVBY3RvciB9IGZyb20gJy4uLy4uL2Rpc3QvcmFpc2UtMWRiMjdhODIuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVRyYW5zaXRpb25gLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtcbiAqICAgZnJvbVRyYW5zaXRpb24sXG4gKiAgIGNyZWF0ZUFjdG9yLFxuICogICB0eXBlIEFueUFjdG9yU3lzdGVtXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogLy8qIFRoZSBhY3RvcidzIHN0b3JlZCBjb250ZXh0LlxuICogdHlwZSBDb250ZXh0ID0ge1xuICogICAvLyBUaGUgY3VycmVudCBjb3VudC5cbiAqICAgY291bnQ6IG51bWJlcjtcbiAqICAgLy8gVGhlIGFtb3VudCB0byBpbmNyZWFzZSBgY291bnRgIGJ5LlxuICogICBzdGVwOiBudW1iZXI7XG4gKiB9O1xuICogLy8gVGhlIGV2ZW50cyB0aGUgYWN0b3IgcmVjZWl2ZXMuXG4gKiB0eXBlIEV2ZW50ID0geyB0eXBlOiAnaW5jcmVtZW50JyB9O1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBzdGVwPzogbnVtYmVyIH07XG4gKlxuICogLy8gQWN0b3IgbG9naWMgdGhhdCBpbmNyZW1lbnRzIGBjb3VudGAgYnkgYHN0ZXBgIHdoZW4gaXQgcmVjZWl2ZXMgYW4gZXZlbnQgb2ZcbiAqIC8vIHR5cGUgYGluY3JlbWVudGAuXG4gKiBjb25zdCBsb2dpYyA9IGZyb21UcmFuc2l0aW9uPENvbnRleHQsIEV2ZW50LCBBbnlBY3RvclN5c3RlbSwgSW5wdXQ+KFxuICogICAoc3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlKSA9PiB7XG4gKiAgICAgYWN0b3JTY29wZS5zZWxmO1xuICogICAgIC8vICAgICAgICAgXj8gVHJhbnNpdGlvbkFjdG9yUmVmPENvbnRleHQsIEV2ZW50PlxuICpcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2luY3JlbWVudCcpIHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIC4uLnN0YXRlLFxuICogICAgICAgICBjb3VudDogc3RhdGUuY291bnQgKyBzdGF0ZS5zdGVwXG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgICByZXR1cm4gc3RhdGU7XG4gKiAgIH0sXG4gKiAgICh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgICBzZWxmO1xuICogICAgIC8vIF4/IFRyYW5zaXRpb25BY3RvclJlZjxDb250ZXh0LCBFdmVudD5cbiAqXG4gKiAgICAgcmV0dXJuIHtcbiAqICAgICAgIGNvdW50OiAwLFxuICogICAgICAgc3RlcDogaW5wdXQuc3RlcCA/PyAxXG4gKiAgICAgfTtcbiAqICAgfVxuICogKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IHN0ZXA6IDEwIH0gfSk7XG4gKiAvLyAgICBePyBUcmFuc2l0aW9uQWN0b3JSZWY8Q29udGV4dCwgRXZlbnQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tVHJhbnNpdGlvbn1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYWN0b3IgbG9naWMgZ2l2ZW4gYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGFuZCBpdHMgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBBIOKAnHRyYW5zaXRpb24gZnVuY3Rpb27igJ0gaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kXG4gKiByZWNlaXZlZCBgZXZlbnRgIG9iamVjdCBhcyBhcmd1bWVudHMsIGFuZCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlLCBzaW1pbGFyIHRvXG4gKiBhIHJlZHVjZXIuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSB0cmFuc2l0aW9uIGxvZ2ljICjigJx0cmFuc2l0aW9uIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gUmVjZWl2ZSBldmVudHNcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgaXRzIHN0YXRlXG4gKlxuICogVGhlIHRyYW5zaXRpb24gZnVuY3Rpb27igJlzIGBzdGF0ZWAgaXMgdXNlZCBhcyBpdHMgdHJhbnNpdGlvbiBhY3RvcuKAmXNcbiAqIGBjb250ZXh0YC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIFwic3RhdGVcIiBmb3IgYSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIGJ5IHRoZSBpbml0aWFsXG4gKiBzdGF0ZSBhcmd1bWVudCwgYW5kIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgU3RhdGUgb2JqZWN0IG9mIGFuIGFjdG9yIG9yIGFcbiAqIHN0YXRlIHdpdGhpbiBhIG1hY2hpbmUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCB0cmFuc2l0aW9uTG9naWMgPSBmcm9tVHJhbnNpdGlvbihcbiAqICAgKHN0YXRlLCBldmVudCkgPT4ge1xuICogICAgIGlmIChldmVudC50eXBlID09PSAnaW5jcmVtZW50Jykge1xuICogICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgLi4uc3RhdGUsXG4gKiAgICAgICAgIGNvdW50OiBzdGF0ZS5jb3VudCArIDFcbiAqICAgICAgIH07XG4gKiAgICAgfVxuICogICAgIHJldHVybiBzdGF0ZTtcbiAqICAgfSxcbiAqICAgeyBjb3VudDogMCB9XG4gKiApO1xuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25BY3RvciA9IGNyZWF0ZUFjdG9yKHRyYW5zaXRpb25Mb2dpYyk7XG4gKiB0cmFuc2l0aW9uQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHRyYW5zaXRpb25BY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBzdGF0dXM6ICdhY3RpdmUnLFxuICogLy8gICBjb250ZXh0OiB7IGNvdW50OiAwIH0sXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICpcbiAqIHRyYW5zaXRpb25BY3Rvci5zZW5kKHsgdHlwZTogJ2luY3JlbWVudCcgfSk7XG4gKiAvLyA9PiB7XG4gKiAvLyAgIHN0YXR1czogJ2FjdGl2ZScsXG4gKiAvLyAgIGNvbnRleHQ6IHsgY291bnQ6IDEgfSxcbiAqIC8vICAgLi4uXG4gKiAvLyB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHJhbnNpdGlvbiBUaGUgdHJhbnNpdGlvbiBmdW5jdGlvbiB1c2VkIHRvIGRlc2NyaWJlIHRoZSB0cmFuc2l0aW9uXG4gKiAgIGxvZ2ljLiBJdCBzaG91bGQgcmV0dXJuIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBldmVudC5cbiAqICAgSXQgcmVjZWl2ZXMgdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gKlxuICogICAtIGBzdGF0ZWAgLSB0aGUgY3VycmVudCBzdGF0ZS5cbiAqICAgLSBgZXZlbnRgIC0gdGhlIHJlY2VpdmVkIGV2ZW50LlxuICogICAtIGBhY3RvclNjb3BlYCAtIHRoZSBhY3RvciBzY29wZSBvYmplY3QsIHdpdGggcHJvcGVydGllcyBsaWtlIGBzZWxmYCBhbmRcbiAqICAgICAgIGBzeXN0ZW1gLlxuICpcbiAqIEBwYXJhbSBpbml0aWFsQ29udGV4dCBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgdHJhbnNpdGlvbiBmdW5jdGlvbiwgZWl0aGVyIGFuXG4gKiAgIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlLCBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBzdGF0ZSBvYmplY3QuXG4gKiAgIElmIGEgZnVuY3Rpb24sIGl0IHdpbGwgcmVjZWl2ZSBhcyBpdHMgb25seSBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqICAgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGBpbnB1dGAgLSB0aGUgYGlucHV0YCBwcm92aWRlZCB0byBpdHMgcGFyZW50IHRyYW5zaXRpb24gYWN0b3IuXG4gKiAgIC0gYHNlbGZgIC0gYSByZWZlcmVuY2UgdG8gaXRzIHBhcmVudCB0cmFuc2l0aW9uIGFjdG9yLlxuICpcbiAqIEByZXR1cm5zIEFjdG9yIGxvZ2ljXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwgaW5pdGlhbENvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25maWc6IHRyYW5zaXRpb24sXG4gICAgdHJhbnNpdGlvbjogKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgIGNvbnRleHQ6IHRyYW5zaXRpb24oc25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB0eXBlb2YgaW5pdGlhbENvbnRleHQgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsQ29udGV4dCh7XG4gICAgICAgICAgaW5wdXRcbiAgICAgICAgfSkgOiBpbml0aWFsQ29udGV4dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG59XG5cbmNvbnN0IGluc3RhbmNlU3RhdGVzID0gLyogI19fUFVSRV9fICovbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFjdG9yIGNyZWF0ZWQgYnkgYGZyb21DYWxsYmFja2AuXG4gKlxuICogVGhlIHR5cGUgb2YgYHNlbGZgIHdpdGhpbiB0aGUgYWN0b3IncyBsb2dpYy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tQ2FsbGJhY2ssIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgZXZlbnRzIHRoZSBhY3RvciByZWNlaXZlcy5cbiAqIHR5cGUgRXZlbnQgPSB7IHR5cGU6ICdzb21lRXZlbnQnIH07XG4gKiAvLyBUaGUgYWN0b3IncyBpbnB1dC5cbiAqIHR5cGUgSW5wdXQgPSB7IG5hbWU6IHN0cmluZyB9O1xuICpcbiAqIC8vIEFjdG9yIGxvZ2ljIHRoYXQgbG9ncyB3aGVuZXZlciBpdCByZWNlaXZlcyBhbiBldmVudCBvZiB0eXBlIGBzb21lRXZlbnRgLlxuICogY29uc3QgbG9naWMgPSBmcm9tQ2FsbGJhY2s8RXZlbnQsIElucHV0PigoeyBzZWxmLCBpbnB1dCwgcmVjZWl2ZSB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IENhbGxiYWNrQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICpcbiAqICAgcmVjZWl2ZSgoZXZlbnQpID0+IHtcbiAqICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3NvbWVFdmVudCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGAke2lucHV0Lm5hbWV9OiByZWNlaXZlZCBcInNvbWVFdmVudFwiIGV2ZW50YCk7XG4gKiAgICAgICAvLyBsb2dzICdteUFjdG9yOiByZWNlaXZlZCBcInNvbWVFdmVudFwiIGV2ZW50J1xuICogICAgIH1cbiAqICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG5hbWU6ICdteUFjdG9yJyB9IH0pO1xuICogLy8gICAgXj8gQ2FsbGJhY2tBY3RvclJlZjxFdmVudCwgSW5wdXQ+XG4gKiBgYGBcbiAqXG4gKiBAc2VlIHtAbGluayBmcm9tQ2FsbGJhY2t9XG4gKi9cblxuLyoqXG4gKiBBbiBhY3RvciBsb2dpYyBjcmVhdG9yIHdoaWNoIHJldHVybnMgY2FsbGJhY2sgbG9naWMgYXMgZGVmaW5lZCBieSBhIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogVXNlZnVsIGZvciBzdWJzY3JpcHRpb24tYmFzZWQgb3Igb3RoZXIgZnJlZS1mb3JtIGxvZ2ljIHRoYXQgY2FuIHNlbmQgZXZlbnRzXG4gKiBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3IuXG4gKlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBjYWxsYmFjayBsb2dpYyAo4oCcY2FsbGJhY2sgYWN0b3Jz4oCdKSBjYW46XG4gKlxuICogLSBSZWNlaXZlIGV2ZW50cyB2aWEgdGhlIGByZWNlaXZlYCBmdW5jdGlvblxuICogLSBTZW5kIGV2ZW50cyB0byB0aGUgcGFyZW50IGFjdG9yIHZpYSB0aGUgYHNlbmRCYWNrYCBmdW5jdGlvblxuICpcbiAqIENhbGxiYWNrIGFjdG9ycyBhcmUgYSBiaXQgZGlmZmVyZW50IGZyb20gb3RoZXIgYWN0b3JzIGluIHRoYXQgdGhleTpcbiAqXG4gKiAtIERvIG5vdCB3b3JrIHdpdGggYG9uRG9uZWBcbiAqIC0gRG8gbm90IHByb2R1Y2UgYSBzbmFwc2hvdCB1c2luZyBgLmdldFNuYXBzaG90KClgXG4gKiAtIERvIG5vdCBlbWl0IHZhbHVlcyB3aGVuIHVzZWQgd2l0aCBgLnN1YnNjcmliZSgpYFxuICogLSBDYW4gbm90IGJlIHN0b3BwZWQgd2l0aCBgLnN0b3AoKWBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGNhbGxiYWNrTG9naWMgPSBmcm9tQ2FsbGJhY2soKHsgc2VuZEJhY2ssIHJlY2VpdmUgfSkgPT4ge1xuICogICBsZXQgbG9ja1N0YXR1cyA9ICd1bmxvY2tlZCc7XG4gKlxuICogICBjb25zdCBoYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGxvY2tTdGF0dXMgPT09ICdsb2NrZWQnKSB7XG4gKiAgICAgICByZXR1cm47XG4gKiAgICAgfVxuICogICAgIHNlbmRCYWNrKGV2ZW50KTtcbiAqICAgfTtcbiAqXG4gKiAgIHJlY2VpdmUoKGV2ZW50KSA9PiB7XG4gKiAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdsb2NrJykge1xuICogICAgICAgbG9ja1N0YXR1cyA9ICdsb2NrZWQnO1xuICogICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3VubG9jaycpIHtcbiAqICAgICAgIGxvY2tTdGF0dXMgPSAndW5sb2NrZWQnO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gKlxuICogICByZXR1cm4gKCkgPT4ge1xuICogICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAqICAgfTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHVzZWQgdG8gZGVzY3JpYmUgdGhlIGNhbGxiYWNrIGxvZ2ljXG4gKiAgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgcmVjZWl2ZWAgLSBBIGZ1bmN0aW9uIHRoYXQgY2FuIHNlbmQgZXZlbnRzIGJhY2sgdG8gdGhlIHBhcmVudCBhY3RvcjsgdGhlXG4gKiAgICAgICBsaXN0ZW5lciBpcyB0aGVuIGNhbGxlZCB3aGVuZXZlciBldmVudHMgYXJlIHJlY2VpdmVkIGJ5IHRoZSBjYWxsYmFja1xuICogICAgICAgYWN0b3JcbiAqICAgLSBgc2VuZEJhY2tgIC0gQSBmdW5jdGlvbiB0aGF0IGNhbiBzZW5kIGV2ZW50cyBiYWNrIHRvIHRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgY2FsbGJhY2sgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBjYWxsYmFjayBhY3RvclxuICogICAtIGBzeXN0ZW1gIC0gVGhlIGFjdG9yIHN5c3RlbSB0byB3aGljaCB0aGUgY2FsbGJhY2sgYWN0b3IgYmVsb25ncyBUaGUgY2FsbGJhY2tcbiAqICAgICAgIGZ1bmN0aW9uIGNhbiAob3B0aW9uYWxseSkgcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkXG4gKiAgICAgICB3aGVuIHRoZSBhY3RvciBpcyBzdG9wcGVkLlxuICpcbiAqIEByZXR1cm5zIENhbGxiYWNrIGxvZ2ljXG4gKiBAc2VlIHtAbGluayBDYWxsYmFja0xvZ2ljRnVuY3Rpb259IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgaXRzIG9iamVjdCBhcmd1bWVudFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvaW5wdXQgfCBJbnB1dCBkb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBob3cgaW5wdXQgaXMgcGFzc2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21DYWxsYmFjayhjYWxsYmFjaykge1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IGNhbGxiYWNrLFxuICAgIHN0YXJ0OiAoc3RhdGUsIGFjdG9yU2NvcGUpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZixcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBlbWl0XG4gICAgICB9ID0gYWN0b3JTY29wZTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrU3RhdGUgPSB7XG4gICAgICAgIHJlY2VpdmVyczogdW5kZWZpbmVkLFxuICAgICAgICBkaXNwb3NlOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBpbnN0YW5jZVN0YXRlcy5zZXQoc2VsZiwgY2FsbGJhY2tTdGF0ZSk7XG4gICAgICBjYWxsYmFja1N0YXRlLmRpc3Bvc2UgPSBjYWxsYmFjayh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzZW5kQmFjazogZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzID09PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlY2VpdmU6IGxpc3RlbmVyID0+IHtcbiAgICAgICAgICBjYWxsYmFja1N0YXRlLnJlY2VpdmVycyA/Pz0gbmV3IFNldCgpO1xuICAgICAgICAgIGNhbGxiYWNrU3RhdGUucmVjZWl2ZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXRcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogKHN0YXRlLCBldmVudCwgYWN0b3JTY29wZSkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tTdGF0ZSA9IGluc3RhbmNlU3RhdGVzLmdldChhY3RvclNjb3BlLnNlbGYpO1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFhTVEFURV9TVE9QKSB7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgIGVycm9yOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgY2FsbGJhY2tTdGF0ZS5kaXNwb3NlPy4oKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tTdGF0ZS5yZWNlaXZlcnM/LmZvckVhY2gocmVjZWl2ZXIgPT4gcmVjZWl2ZXIoZXZlbnQpKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuICAgIGdldEluaXRpYWxTbmFwc2hvdDogKF8sIGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5wdXRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogc25hcHNob3QgPT4gc25hcHNob3QsXG4gICAgcmVzdG9yZVNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdFxuICB9O1xuICByZXR1cm4gbG9naWM7XG59XG5cbmNvbnN0IFhTVEFURV9PQlNFUlZBQkxFX05FWFQgPSAneHN0YXRlLm9ic2VydmFibGUubmV4dCc7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUiA9ICd4c3RhdGUub2JzZXJ2YWJsZS5lcnJvcic7XG5jb25zdCBYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURSA9ICd4c3RhdGUub2JzZXJ2YWJsZS5jb21wbGV0ZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhY3RvciBjcmVhdGVkIGJ5IGBmcm9tT2JzZXJ2YWJsZWAgb3IgYGZyb21FdmVudE9ic2VydmFibGVgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbU9ic2VydmFibGUsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqIGltcG9ydCB7IGludGVydmFsIH0gZnJvbSAncnhqcyc7XG4gKlxuICogLy8gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIG9ic2VydmVkIGJ5IHRoZSBhY3RvcidzIGxvZ2ljLlxuICogdHlwZSBDb250ZXh0ID0gbnVtYmVyO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBwZXJpb2Q/OiBudW1iZXIgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IG9ic2VydmVzIGEgbnVtYmVyIGluY3JlbWVudGVkIGV2ZXJ5IGBpbnB1dC5wZXJpb2RgXG4gKiAvLyBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDFfMDAwKS5cbiAqIGNvbnN0IGxvZ2ljID0gZnJvbU9ic2VydmFibGU8Q29udGV4dCwgSW5wdXQ+KCh7IGlucHV0LCBzZWxmIH0pID0+IHtcbiAqICAgc2VsZjtcbiAqICAgLy8gXj8gT2JzZXJ2YWJsZUFjdG9yUmVmPEV2ZW50LCBJbnB1dD5cbiAqXG4gKiAgIHJldHVybiBpbnRlcnZhbChpbnB1dC5wZXJpb2QgPz8gMV8wMDApO1xuICogfSk7XG4gKlxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihsb2dpYywgeyBpbnB1dDogeyBwZXJpb2Q6IDJfMDAwIH0gfSk7XG4gKiAvLyAgICBePyBPYnNlcnZhYmxlQWN0b3JSZWY8RXZlbnQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbU9ic2VydmFibGV9XG4gKiBAc2VlIHtAbGluayBmcm9tRXZlbnRPYnNlcnZhYmxlfVxuICovXG5cbi8qKlxuICogT2JzZXJ2YWJsZSBhY3RvciBsb2dpYyBpcyBkZXNjcmliZWQgYnkgYW4gb2JzZXJ2YWJsZSBzdHJlYW0gb2YgdmFsdWVzLiBBY3RvcnNcbiAqIGNyZWF0ZWQgZnJvbSBvYnNlcnZhYmxlIGxvZ2ljICjigJxvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gRW1pdCBzbmFwc2hvdHMgb2YgdGhlIG9ic2VydmFibGXigJlzIGVtaXR0ZWQgdmFsdWVcbiAqXG4gKiBUaGUgb2JzZXJ2YWJsZeKAmXMgZW1pdHRlZCB2YWx1ZSBpcyB1c2VkIGFzIGl0cyBvYnNlcnZhYmxlIGFjdG9y4oCZcyBgY29udGV4dGAuXG4gKlxuICogU2VuZGluZyBldmVudHMgdG8gb2JzZXJ2YWJsZSBhY3RvcnMgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmcm9tT2JzZXJ2YWJsZSwgY3JlYXRlQWN0b3IgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBsb2dpYyA9IGZyb21PYnNlcnZhYmxlKChvYmopID0+IGludGVydmFsKDEwMDApKTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljKTtcbiAqXG4gKiBhY3Rvci5zdWJzY3JpYmUoKHNuYXBzaG90KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90LmNvbnRleHQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc3RhcnQoKTtcbiAqIC8vIEF0IGV2ZXJ5IHNlY29uZDpcbiAqIC8vIExvZ3MgMFxuICogLy8gTG9ncyAxXG4gKiAvLyBMb2dzIDJcbiAqIC8vIC4uLlxuICogYGBgXG4gKlxuICogQHBhcmFtIG9ic2VydmFibGVDcmVhdG9yIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIG9ic2VydmFibGUuIEl0IHJlY2VpdmVzXG4gKiAgIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIG9ic2VydmFibGUgYWN0b3IgYmVsb25nc1xuICpcbiAqICAgSXQgc2hvdWxkIHJldHVybiBhIHtAbGluayBTdWJzY3JpYmFibGV9LCB3aGljaCBpcyBjb21wYXRpYmxlIHdpdGggYW4gUnhKU1xuICogICBPYnNlcnZhYmxlLCBhbHRob3VnaCBSeEpTIGlzIG5vdCByZXF1aXJlZCB0byBjcmVhdGUgdGhlbS5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vcnhqcy5kZXZ9IGZvciBkb2N1bWVudGF0aW9uIG9uIFJ4SlMgT2JzZXJ2YWJsZSBhbmQgb2JzZXJ2YWJsZSBjcmVhdG9ycy5cbiAqIEBzZWUge0BsaW5rIFN1YnNjcmliYWJsZX0gaW50ZXJmYWNlIGluIFhTdGF0ZSwgd2hpY2ggaXMgYmFzZWQgb24gYW5kIGNvbXBhdGlibGUgd2l0aCBSeEpTIE9ic2VydmFibGUuXG4gKi9cbmZ1bmN0aW9uIGZyb21PYnNlcnZhYmxlKG9ic2VydmFibGVDcmVhdG9yKSB7XG4gIC8vIFRPRE86IGFkZCBldmVudCB0eXBlc1xuICBjb25zdCBsb2dpYyA9IHtcbiAgICBjb25maWc6IG9ic2VydmFibGVDcmVhdG9yLFxuICAgIHRyYW5zaXRpb246IChzbmFwc2hvdCwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChzbmFwc2hvdC5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX05FWFQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSB7XG4gICAgICAgICAgICAgIC4uLnNuYXBzaG90LFxuICAgICAgICAgICAgICBjb250ZXh0OiBldmVudC5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc25hcHNob3QsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc25hcHNob3QuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9ORVhULFxuICAgICAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XG4gICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgICB0eXBlOiBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUixcbiAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfQ09NUExFVEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRQZXJzaXN0ZWRTbmFwc2hvdDogKHtcbiAgICAgIF9zdWJzY3JpcHRpb24sXG4gICAgICAuLi5zdGF0ZVxuICAgIH0pID0+IHN0YXRlLFxuICAgIHJlc3RvcmVTbmFwc2hvdDogc3RhdGUgPT4gKHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgX3N1YnNjcmlwdGlvbjogdW5kZWZpbmVkXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIGxvZ2ljO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZXZlbnQgb2JzZXJ2YWJsZSBsb2dpYyB0aGF0IGxpc3RlbnMgdG8gYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiBldmVudCBvYmplY3RzLlxuICpcbiAqIEV2ZW50IG9ic2VydmFibGUgYWN0b3IgbG9naWMgaXMgZGVzY3JpYmVkIGJ5IGFuIG9ic2VydmFibGUgc3RyZWFtIG9mXG4gKiB7QGxpbmsgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvdHJhbnNpdGlvbnMjZXZlbnQtb2JqZWN0cyB8IGV2ZW50IG9iamVjdHN9LlxuICogQWN0b3JzIGNyZWF0ZWQgZnJvbSBldmVudCBvYnNlcnZhYmxlIGxvZ2ljICjigJxldmVudCBvYnNlcnZhYmxlIGFjdG9yc+KAnSkgY2FuOlxuICpcbiAqIC0gSW1wbGljaXRseSBzZW5kIGV2ZW50cyB0byBpdHMgcGFyZW50IGFjdG9yXG4gKiAtIEVtaXQgc25hcHNob3RzIG9mIGl0cyBlbWl0dGVkIGV2ZW50IG9iamVjdHNcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBldmVudCBvYnNlcnZhYmxlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7XG4gKiAgIGZyb21FdmVudE9ic2VydmFibGUsXG4gKiAgIFN1YnNjcmliYWJsZSxcbiAqICAgRXZlbnRPYmplY3QsXG4gKiAgIGNyZWF0ZU1hY2hpbmUsXG4gKiAgIGNyZWF0ZUFjdG9yXG4gKiB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzJztcbiAqXG4gKiBjb25zdCBtb3VzZUNsaWNrTG9naWMgPSBmcm9tRXZlbnRPYnNlcnZhYmxlKFxuICogICAoKSA9PiBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgJ2NsaWNrJykgYXMgU3Vic2NyaWJhYmxlPEV2ZW50T2JqZWN0PlxuICogKTtcbiAqXG4gKiBjb25zdCBjYW52YXNNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGludm9rZToge1xuICogICAgIC8vIFdpbGwgc2VuZCBtb3VzZSBgY2xpY2tgIGV2ZW50cyB0byB0aGUgY2FudmFzIGFjdG9yXG4gKiAgICAgc3JjOiBtb3VzZUNsaWNrTG9naWNcbiAqICAgfVxuICogfSk7XG4gKlxuICogY29uc3QgY2FudmFzQWN0b3IgPSBjcmVhdGVBY3RvcihjYW52YXNNYWNoaW5lKTtcbiAqIGNhbnZhc0FjdG9yLnN0YXJ0KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGF6eU9ic2VydmFibGUgQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzXG4gKiAgIGV2ZW50IG9iamVjdHMuIEl0IHJlY2VpdmVzIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogICBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgaW5wdXRgIC0gRGF0YSB0aGF0IHdhcyBwcm92aWRlZCB0byB0aGUgZXZlbnQgb2JzZXJ2YWJsZSBhY3RvclxuICogICAtIGBzZWxmYCAtIFRoZSBwYXJlbnQgYWN0b3JcbiAqICAgLSBgc3lzdGVtYCAtIFRoZSBhY3RvciBzeXN0ZW0gdG8gd2hpY2ggdGhlIGV2ZW50IG9ic2VydmFibGUgYWN0b3IgYmVsb25ncy5cbiAqXG4gKiAgIEl0IHNob3VsZCByZXR1cm4gYSB7QGxpbmsgU3Vic2NyaWJhYmxlfSwgd2hpY2ggaXMgY29tcGF0aWJsZSB3aXRoIGFuIFJ4SlNcbiAqICAgT2JzZXJ2YWJsZSwgYWx0aG91Z2ggUnhKUyBpcyBub3QgcmVxdWlyZWQgdG8gY3JlYXRlIHRoZW0uXG4gKi9cbmZ1bmN0aW9uIGZyb21FdmVudE9ic2VydmFibGUobGF6eU9ic2VydmFibGUpIHtcbiAgLy8gVE9ETzogZXZlbnQgdHlwZXNcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBsYXp5T2JzZXJ2YWJsZSxcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSBYU1RBVEVfT0JTRVJWQUJMRV9FUlJPUjpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgICBlcnJvcjogZXZlbnQuZGF0YSxcbiAgICAgICAgICAgIGlucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgWFNUQVRFX1NUT1A6XG4gICAgICAgICAgc3RhdGUuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgICAgIHN0YXR1czogJ3N0b3BwZWQnLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBfc3Vic2NyaXB0aW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKHN0YXRlLCB7XG4gICAgICBzZWxmLFxuICAgICAgc3lzdGVtLFxuICAgICAgZW1pdFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgICAgICAvLyBEbyBub3QgcmVzdGFydCBhIGNvbXBsZXRlZCBvYnNlcnZhYmxlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0YXRlLl9zdWJzY3JpcHRpb24gPSBsYXp5T2JzZXJ2YWJsZSh7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBlbWl0XG4gICAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgaWYgKHNlbGYuX3BhcmVudCkge1xuICAgICAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLl9wYXJlbnQsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBlcnIgPT4ge1xuICAgICAgICAgIHN5c3RlbS5fcmVsYXkoc2VsZiwgc2VsZiwge1xuICAgICAgICAgICAgdHlwZTogWFNUQVRFX09CU0VSVkFCTEVfRVJST1IsXG4gICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICBzeXN0ZW0uX3JlbGF5KHNlbGYsIHNlbGYsIHtcbiAgICAgICAgICAgIHR5cGU6IFhTVEFURV9PQlNFUlZBQkxFX0NPTVBMRVRFXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UGVyc2lzdGVkU25hcHNob3Q6ICh7XG4gICAgICBfc3Vic2NyaXB0aW9uLFxuICAgICAgLi4uc25hcHNob3RcbiAgICB9KSA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+ICh7XG4gICAgICAuLi5zbmFwc2hvdCxcbiAgICAgIF9zdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgWFNUQVRFX1BST01JU0VfUkVTT0xWRSA9ICd4c3RhdGUucHJvbWlzZS5yZXNvbHZlJztcbmNvbnN0IFhTVEFURV9QUk9NSVNFX1JFSkVDVCA9ICd4c3RhdGUucHJvbWlzZS5yZWplY3QnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gYWN0b3IgY3JlYXRlZCBieSBgZnJvbVByb21pc2VgLlxuICpcbiAqIFRoZSB0eXBlIG9mIGBzZWxmYCB3aXRoaW4gdGhlIGFjdG9yJ3MgbG9naWMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZnJvbVByb21pc2UsIGNyZWF0ZUFjdG9yIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiAvLyBUaGUgYWN0b3IncyByZXNvbHZlZCBvdXRwdXRcbiAqIHR5cGUgT3V0cHV0ID0gc3RyaW5nO1xuICogLy8gVGhlIGFjdG9yJ3MgaW5wdXQuXG4gKiB0eXBlIElucHV0ID0geyBtZXNzYWdlOiBzdHJpbmcgfTtcbiAqXG4gKiAvLyBBY3RvciBsb2dpYyB0aGF0IGZldGNoZXMgdGhlIHVybCBvZiBhbiBpbWFnZSBvZiBhIGNhdCBzYXlpbmcgYGlucHV0Lm1lc3NhZ2VgLlxuICogY29uc3QgbG9naWMgPSBmcm9tUHJvbWlzZTxPdXRwdXQsIElucHV0Pihhc3luYyAoeyBpbnB1dCwgc2VsZiB9KSA9PiB7XG4gKiAgIHNlbGY7XG4gKiAgIC8vIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICpcbiAqICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKFxuICogICAgIGBodHRwczovL2NhdGFhcy5jb20vY2F0L3NheXMvJHtpbnB1dC5tZXNzYWdlfWBcbiAqICAgKTtcbiAqICAgY29uc3QgdXJsID0gYXdhaXQgZGF0YS5qc29uKCk7XG4gKiAgIHJldHVybiB1cmw7XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7IGlucHV0OiB7IG1lc3NhZ2U6ICdoZWxsbyB3b3JsZCcgfSB9KTtcbiAqIC8vICAgIF4/IFByb21pc2VBY3RvclJlZjxPdXRwdXQsIElucHV0PlxuICogYGBgXG4gKlxuICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gKi9cblxuY29uc3QgY29udHJvbGxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQW4gYWN0b3IgbG9naWMgY3JlYXRvciB3aGljaCByZXR1cm5zIHByb21pc2UgbG9naWMgYXMgZGVmaW5lZCBieSBhbiBhc3luY1xuICogcHJvY2VzcyB0aGF0IHJlc29sdmVzIG9yIHJlamVjdHMgYWZ0ZXIgc29tZSB0aW1lLlxuICpcbiAqIEFjdG9ycyBjcmVhdGVkIGZyb20gcHJvbWlzZSBhY3RvciBsb2dpYyAo4oCccHJvbWlzZSBhY3RvcnPigJ0pIGNhbjpcbiAqXG4gKiAtIEVtaXQgdGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSBwcm9taXNlXG4gKiAtIE91dHB1dCB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgdGhlIHByb21pc2VcbiAqXG4gKiBTZW5kaW5nIGV2ZW50cyB0byBwcm9taXNlIGFjdG9ycyB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHByb21pc2VMb2dpYyA9IGZyb21Qcm9taXNlKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vZXhhbXBsZS5jb20vLi4uJykudGhlbigoZGF0YSkgPT5cbiAqICAgICBkYXRhLmpzb24oKVxuICogICApO1xuICpcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHByb21pc2VBY3RvciA9IGNyZWF0ZUFjdG9yKHByb21pc2VMb2dpYyk7XG4gKiBwcm9taXNlQWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqIHByb21pc2VBY3Rvci5zdGFydCgpO1xuICogLy8gPT4ge1xuICogLy8gICBvdXRwdXQ6IHVuZGVmaW5lZCxcbiAqIC8vICAgc3RhdHVzOiAnYWN0aXZlJ1xuICogLy8gICAuLi5cbiAqIC8vIH1cbiAqXG4gKiAvLyBBZnRlciBwcm9taXNlIHJlc29sdmVzXG4gKiAvLyA9PiB7XG4gKiAvLyAgIG91dHB1dDogeyAuLi4gfSxcbiAqIC8vICAgc3RhdHVzOiAnZG9uZScsXG4gKiAvLyAgIC4uLlxuICogLy8gfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHByb21pc2VDcmVhdG9yIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFByb21pc2UsIGFuZCBhY2NlcHRzIGFuXG4gKiAgIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gYGlucHV0YCAtIERhdGEgdGhhdCB3YXMgcHJvdmlkZWQgdG8gdGhlIHByb21pc2UgYWN0b3JcbiAqICAgLSBgc2VsZmAgLSBUaGUgcGFyZW50IGFjdG9yIG9mIHRoZSBwcm9taXNlIGFjdG9yXG4gKiAgIC0gYHN5c3RlbWAgLSBUaGUgYWN0b3Igc3lzdGVtIHRvIHdoaWNoIHRoZSBwcm9taXNlIGFjdG9yIGJlbG9uZ3NcbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9pbnB1dCB8IElucHV0IGRvY3N9IGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGhvdyBpbnB1dCBpcyBwYXNzZWRcbiAqL1xuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZUNyZWF0b3IpIHtcbiAgY29uc3QgbG9naWMgPSB7XG4gICAgY29uZmlnOiBwcm9taXNlQ3JlYXRvcixcbiAgICB0cmFuc2l0aW9uOiAoc3RhdGUsIGV2ZW50LCBzY29wZSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgWFNUQVRFX1BST01JU0VfUkVTT0xWRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdkb25lJyxcbiAgICAgICAgICAgICAgb3V0cHV0OiByZXNvbHZlZFZhbHVlLFxuICAgICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBYU1RBVEVfUFJPTUlTRV9SRUpFQ1Q6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICBpbnB1dDogdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBYU1RBVEVfU1RPUDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb250cm9sbGVyTWFwLmdldChzY29wZS5zZWxmKT8uYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdzdG9wcGVkJyxcbiAgICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnQ6IChzdGF0ZSwge1xuICAgICAgc2VsZixcbiAgICAgIHN5c3RlbSxcbiAgICAgIGVtaXRcbiAgICB9KSA9PiB7XG4gICAgICAvLyBUT0RPOiBkZXRlcm1pbmUgaG93IHRvIGFsbG93IGN1c3RvbWl6aW5nIHRoaXMgc28gdGhhdCBwcm9taXNlc1xuICAgICAgLy8gY2FuIGJlIHJlc3RhcnRlZCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICBjb250cm9sbGVyTWFwLnNldChzZWxmLCBjb250cm9sbGVyKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwcm9taXNlQ3JlYXRvcih7XG4gICAgICAgIGlucHV0OiBzdGF0ZS5pbnB1dCxcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBlbWl0XG4gICAgICB9KSk7XG4gICAgICByZXNvbHZlZFByb21pc2UudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyTWFwLmRlbGV0ZShzZWxmKTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgdHlwZTogWFNUQVRFX1BST01JU0VfUkVTT0xWRSxcbiAgICAgICAgICBkYXRhOiByZXNwb25zZVxuICAgICAgICB9KTtcbiAgICAgIH0sIGVycm9yRGF0YSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmdldFNuYXBzaG90KCkuc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyTWFwLmRlbGV0ZShzZWxmKTtcbiAgICAgICAgc3lzdGVtLl9yZWxheShzZWxmLCBzZWxmLCB7XG4gICAgICAgICAgdHlwZTogWFNUQVRFX1BST01JU0VfUkVKRUNULFxuICAgICAgICAgIGRhdGE6IGVycm9yRGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0SW5pdGlhbFNuYXBzaG90OiAoXywgaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIG91dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICBlcnJvcjogdW5kZWZpbmVkLFxuICAgICAgICBpbnB1dFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFBlcnNpc3RlZFNuYXBzaG90OiBzbmFwc2hvdCA9PiBzbmFwc2hvdCxcbiAgICByZXN0b3JlU25hcHNob3Q6IHNuYXBzaG90ID0+IHNuYXBzaG90XG4gIH07XG4gIHJldHVybiBsb2dpYztcbn1cblxuY29uc3QgZW1wdHlMb2dpYyA9IGZyb21UcmFuc2l0aW9uKF8gPT4gdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlBY3RvcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUFjdG9yKGVtcHR5TG9naWMpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbXB0eUFjdG9yLCBmcm9tQ2FsbGJhY2ssIGZyb21FdmVudE9ic2VydmFibGUsIGZyb21PYnNlcnZhYmxlLCBmcm9tUHJvbWlzZSwgZnJvbVRyYW5zaXRpb24gfTtcbiJdLCJuYW1lcyI6WyJYIiwiWFNUQVRFX1NUT1AiLCJBIiwiY3JlYXRlQWN0b3IiLCJmcm9tVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJpbml0aWFsQ29udGV4dCIsImNvbmZpZyIsInNuYXBzaG90IiwiZXZlbnQiLCJhY3RvclNjb3BlIiwiY29udGV4dCIsImdldEluaXRpYWxTbmFwc2hvdCIsIl8iLCJpbnB1dCIsInN0YXR1cyIsIm91dHB1dCIsInVuZGVmaW5lZCIsImVycm9yIiwiZ2V0UGVyc2lzdGVkU25hcHNob3QiLCJyZXN0b3JlU25hcHNob3QiLCJpbnN0YW5jZVN0YXRlcyIsIldlYWtNYXAiLCJmcm9tQ2FsbGJhY2siLCJjYWxsYmFjayIsImxvZ2ljIiwic3RhcnQiLCJzdGF0ZSIsInNlbGYiLCJzeXN0ZW0iLCJlbWl0IiwiY2FsbGJhY2tTdGF0ZSIsInJlY2VpdmVycyIsImRpc3Bvc2UiLCJzZXQiLCJzZW5kQmFjayIsImdldFNuYXBzaG90IiwiX3BhcmVudCIsIl9yZWxheSIsInJlY2VpdmUiLCJsaXN0ZW5lciIsIlNldCIsImFkZCIsImdldCIsInR5cGUiLCJmb3JFYWNoIiwicmVjZWl2ZXIiLCJYU1RBVEVfT0JTRVJWQUJMRV9ORVhUIiwiWFNUQVRFX09CU0VSVkFCTEVfRVJST1IiLCJYU1RBVEVfT0JTRVJWQUJMRV9DT01QTEVURSIsImZyb21PYnNlcnZhYmxlIiwib2JzZXJ2YWJsZUNyZWF0b3IiLCJuZXdTbmFwc2hvdCIsImRhdGEiLCJfc3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJuZXh0IiwidmFsdWUiLCJlcnIiLCJjb21wbGV0ZSIsImZyb21FdmVudE9ic2VydmFibGUiLCJsYXp5T2JzZXJ2YWJsZSIsIlhTVEFURV9QUk9NSVNFX1JFU09MVkUiLCJYU1RBVEVfUFJPTUlTRV9SRUpFQ1QiLCJjb250cm9sbGVyTWFwIiwiZnJvbVByb21pc2UiLCJwcm9taXNlQ3JlYXRvciIsInNjb3BlIiwicmVzb2x2ZWRWYWx1ZSIsImFib3J0IiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInJlc29sdmVkUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2lnbmFsIiwidGhlbiIsInJlc3BvbnNlIiwiZGVsZXRlIiwiZXJyb3JEYXRhIiwiZW1wdHlMb2dpYyIsImNyZWF0ZUVtcHR5QWN0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dev/dist/xstate-dev.development.esm.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devToolsAdapter: function() { return /* binding */ devToolsAdapter; },\n/* harmony export */   getGlobal: function() { return /* binding */ getGlobal; },\n/* harmony export */   registerService: function() { return /* binding */ registerService; }\n/* harmony export */ });\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nfunction getGlobal() {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (true) {\n        return window;\n    }\n    if (typeof __webpack_require__.g !== \"undefined\") {\n        return __webpack_require__.g;\n    }\n    {\n        console.warn(\"XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues\");\n    }\n}\nfunction getDevTools() {\n    const w = getGlobal();\n    if (w.__xstate__) {\n        return w.__xstate__;\n    }\n    return undefined;\n}\nfunction registerService(service) {\n    if (false) {}\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n}\nconst devToolsAdapter = (service)=>{\n    if (false) {}\n    const devTools = getDevTools();\n    if (devTools) {\n        devTools.register(service);\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsbUdBQW1HO0FBQ25HLFNBQVNBO0lBQ1AsSUFBSSxPQUFPQyxlQUFlLGFBQWE7UUFDckMsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0MsU0FBUyxhQUFhO1FBQy9CLE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLElBQWtCLEVBQWE7UUFDakMsT0FBT0M7SUFDVDtJQUNBLElBQUksT0FBT0MscUJBQU1BLEtBQUssYUFBYTtRQUNqQyxPQUFPQSxxQkFBTUE7SUFDZjtJQUNBO1FBQ0VDLFFBQVFDLElBQUksQ0FBQztJQUNmO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE1BQU1DLElBQUlSO0lBQ1YsSUFBSVEsRUFBRUMsVUFBVSxFQUFFO1FBQ2hCLE9BQU9ELEVBQUVDLFVBQVU7SUFDckI7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzlCLElBQUksS0FBa0IsRUFBYSxFQUVsQztJQUNELE1BQU1DLFdBQVdOO0lBQ2pCLElBQUlNLFVBQVU7UUFDWkEsU0FBU0MsUUFBUSxDQUFDRjtJQUNwQjtBQUNGO0FBQ0EsTUFBTUcsa0JBQWtCSCxDQUFBQTtJQUN0QixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDRCxNQUFNQyxXQUFXTjtJQUNqQixJQUFJTSxVQUFVO1FBQ1pBLFNBQVNDLFFBQVEsQ0FBQ0Y7SUFDcEI7QUFDRjtBQUV1RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rldi9kaXN0L3hzdGF0ZS1kZXYuZGV2ZWxvcG1lbnQuZXNtLmpzPzRmZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9nbG9iYWxUaGlzXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgfVxuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZ2xvYmFsO1xuICB9XG4gIHtcbiAgICBjb25zb2xlLndhcm4oJ1hTdGF0ZSBjb3VsZCBub3QgZmluZCBhIGdsb2JhbCBvYmplY3QgaW4gdGhpcyBlbnZpcm9ubWVudC4gUGxlYXNlIGxldCB0aGUgbWFpbnRhaW5lcnMga25vdyBhbmQgcmFpc2UgYW4gaXNzdWUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3N0YXRlbHlhaS94c3RhdGUvaXNzdWVzJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERldlRvb2xzKCkge1xuICBjb25zdCB3ID0gZ2V0R2xvYmFsKCk7XG4gIGlmICh3Ll9feHN0YXRlX18pIHtcbiAgICByZXR1cm4gdy5fX3hzdGF0ZV9fO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZWdpc3RlclNlcnZpY2Uoc2VydmljZSkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZGV2VG9vbHMgPSBnZXREZXZUb29scygpO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBkZXZUb29scy5yZWdpc3RlcihzZXJ2aWNlKTtcbiAgfVxufVxuY29uc3QgZGV2VG9vbHNBZGFwdGVyID0gc2VydmljZSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkZXZUb29scyA9IGdldERldlRvb2xzKCk7XG4gIGlmIChkZXZUb29scykge1xuICAgIGRldlRvb2xzLnJlZ2lzdGVyKHNlcnZpY2UpO1xuICB9XG59O1xuXG5leHBvcnQgeyBkZXZUb29sc0FkYXB0ZXIsIGdldEdsb2JhbCwgcmVnaXN0ZXJTZXJ2aWNlIH07XG4iXSwibmFtZXMiOlsiZ2V0R2xvYmFsIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJjb25zb2xlIiwid2FybiIsImdldERldlRvb2xzIiwidyIsIl9feHN0YXRlX18iLCJ1bmRlZmluZWQiLCJyZWdpc3RlclNlcnZpY2UiLCJzZXJ2aWNlIiwiZGV2VG9vbHMiLCJyZWdpc3RlciIsImRldlRvb2xzQWRhcHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dist/log-0acd9069.development.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/xstate/dist/log-0acd9069.development.esm.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: function() { return /* binding */ SpecialTargets; },\n/* harmony export */   a: function() { return /* binding */ assign; },\n/* harmony export */   b: function() { return /* binding */ enqueueActions; },\n/* harmony export */   c: function() { return /* binding */ sendTo; },\n/* harmony export */   e: function() { return /* binding */ emit; },\n/* harmony export */   f: function() { return /* binding */ forwardTo; },\n/* harmony export */   l: function() { return /* binding */ log; },\n/* harmony export */   s: function() { return /* binding */ sendParent; }\n/* harmony export */ });\n/* harmony import */ var _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raise-1db27a82.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n\nfunction createSpawner(actorScope, param, event, spawnedChildren) {\n    let { machine, context } = param;\n    const spawn = (src, options)=>{\n        if (typeof src === \"string\") {\n            const logic = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)(machine, src);\n            if (!logic) {\n                throw new Error(\"Actor logic '\".concat(src, \"' not implemented in machine '\").concat(machine.id, \"'\"));\n            }\n            const actorRef = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(logic, {\n                id: options === null || options === void 0 ? void 0 : options.id,\n                parent: actorScope.self,\n                syncSnapshot: options === null || options === void 0 ? void 0 : options.syncSnapshot,\n                input: typeof (options === null || options === void 0 ? void 0 : options.input) === \"function\" ? options.input({\n                    context,\n                    event,\n                    self: actorScope.self\n                }) : options === null || options === void 0 ? void 0 : options.input,\n                src,\n                systemId: options === null || options === void 0 ? void 0 : options.systemId\n            });\n            spawnedChildren[actorRef.id] = actorRef;\n            return actorRef;\n        } else {\n            const actorRef = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)(src, {\n                id: options === null || options === void 0 ? void 0 : options.id,\n                parent: actorScope.self,\n                syncSnapshot: options === null || options === void 0 ? void 0 : options.syncSnapshot,\n                input: options === null || options === void 0 ? void 0 : options.input,\n                src,\n                systemId: options === null || options === void 0 ? void 0 : options.systemId\n            });\n            return actorRef;\n        }\n    };\n    return (src, options)=>{\n        const actorRef = spawn(src, options); // TODO: fix types\n        spawnedChildren[actorRef.id] = actorRef;\n        actorScope.defer(()=>{\n            if (actorRef._processingStatus === _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.T.Stopped) {\n                return;\n            }\n            actorRef.start();\n        });\n        return actorRef;\n    };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, param) {\n    let { assignment } = param;\n    if (!snapshot.context) {\n        throw new Error(\"Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.\");\n    }\n    const spawnedChildren = {};\n    const assignArgs = {\n        context: snapshot.context,\n        event: actionArgs.event,\n        spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n        self: actorScope.self,\n        system: actorScope.system\n    };\n    let partialUpdate = {};\n    if (typeof assignment === \"function\") {\n        partialUpdate = assignment(assignArgs, actionParams);\n    } else {\n        for (const key of Object.keys(assignment)){\n            const propAssignment = assignment[key];\n            partialUpdate[key] = typeof propAssignment === \"function\" ? propAssignment(assignArgs, actionParams) : propAssignment;\n        }\n    }\n    const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n    return [\n        (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.U)(snapshot, {\n            context: updatedContext,\n            children: Object.keys(spawnedChildren).length ? {\n                ...snapshot.children,\n                ...spawnedChildren\n            } : snapshot.children\n        }),\n        undefined,\n        undefined\n    ];\n}\n/**\n * Updates the current context of the machine.\n *\n * @example\n *\n * ```ts\n * import { createMachine, assign } from 'xstate';\n *\n * const countMachine = createMachine({\n *   context: {\n *     count: 0,\n *     message: ''\n *   },\n *   on: {\n *     inc: {\n *       actions: assign({\n *         count: ({ context }) => context.count + 1\n *       })\n *     },\n *     updateMessage: {\n *       actions: assign(({ context, event }) => {\n *         return {\n *           message: event.message.trim()\n *         };\n *       })\n *     }\n *   }\n * });\n * ```\n *\n * @param assignment An object that represents the partial context to update, or\n *   a function that returns an object that represents the partial context to\n *   update.\n */ function assign(assignment) {\n    if (_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `assign()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function assign(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    assign.type = \"xstate.assign\";\n    assign.assignment = assignment;\n    assign.resolve = resolveAssign;\n    return assign;\n}\nfunction resolveEmit(_, snapshot, args, actionParams, param) {\n    let { event: eventOrExpr } = param;\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    return [\n        snapshot,\n        {\n            event: resolvedEvent\n        },\n        undefined\n    ];\n}\nfunction executeEmit(actorScope, param) {\n    let { event } = param;\n    actorScope.defer(()=>actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event,\n * handler)`.\n *\n * @example\n *\n * ```ts\n * import { emit } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     something: {\n *       actions: emit({\n *         type: 'emitted',\n *         some: 'data'\n *       })\n *     }\n *   }\n *   // ...\n * });\n *\n * const actor = createActor(machine).start();\n *\n * actor.on('emitted', (event) => {\n *   console.log(event);\n * });\n *\n * actor.send({ type: 'something' });\n * // logs:\n * // {\n * //   type: 'emitted',\n * //   some: 'data'\n * // }\n * ```\n */ function emit(/** The event to emit, or an expression that returns an event to emit. */ eventOrExpr) {\n    if (_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `emit()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function emit(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    emit.type = \"xstate.emit\";\n    emit.event = eventOrExpr;\n    emit.resolve = resolveEmit;\n    emit.execute = executeEmit;\n    return emit;\n}\n/**\n * @remarks\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes\n * to contextual typing. It especially is a problem when the union has a\n * function member, like here:\n *\n * ```ts\n * declare function test(\n *   cbOrVal: ((arg: number) => unknown) | unknown\n * ): void;\n * test((arg) => {}); // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same\n * value space as `unknown`.\n */ // https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n/** @deprecated Use the built-in `NoInfer` type instead */ /** The full definition of an event, with a string `type`. */ /**\n * The string or object representing the state value relative to the parent\n * state node.\n *\n * @remarks\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n * - For complex state nodes, this is an object, e.g., `{ success:\n *   \"someChildState\" }`.\n */ /** @deprecated Use `AnyMachineSnapshot` instead */ // TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/** @ignore */ let SpecialTargets = /*#__PURE__*/ function(SpecialTargets) {\n    SpecialTargets[\"Parent\"] = \"#_parent\";\n    SpecialTargets[\"Internal\"] = \"#_internal\";\n    return SpecialTargets;\n}({});\n/** @deprecated Use `AnyActor` instead. */ // Based on RxJS types\n// TODO: in v6, this should only accept AnyActorLogic, like ActorRefFromLogic\n/** @deprecated Use `Actor<T>` instead. */ /**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */ /** @deprecated */ // TODO: cover all that can be actually returned\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, param, extra) {\n    let { to, event: eventOrExpr, id, delay } = param;\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        'Only event objects may be used with sendTo; use sendTo({ type: \"'.concat(eventOrExpr, '\" }) instead'));\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    const resolvedTarget = typeof to === \"function\" ? to(args, actionParams) : to;\n    let targetActorRef;\n    if (typeof resolvedTarget === \"string\") {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n        if (resolvedTarget === SpecialTargets.Parent) {\n            targetActorRef = actorScope.self._parent;\n        } else if (resolvedTarget === SpecialTargets.Internal) {\n            targetActorRef = actorScope.self;\n        } else if (resolvedTarget.startsWith(\"#_\")) {\n            // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n            // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n            targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n        } else {\n            var _extra_deferredActorIds;\n            targetActorRef = ((_extra_deferredActorIds = extra.deferredActorIds) === null || _extra_deferredActorIds === void 0 ? void 0 : _extra_deferredActorIds.includes(resolvedTarget)) ? resolvedTarget : snapshot.children[resolvedTarget];\n        }\n        if (!targetActorRef) {\n            throw new Error(\"Unable to send event to actor '\".concat(resolvedTarget, \"' from machine '\").concat(snapshot.machine.id, \"'.\"));\n        }\n    } else {\n        targetActorRef = resolvedTarget || actorScope.self;\n    }\n    return [\n        snapshot,\n        {\n            to: targetActorRef,\n            targetId: typeof resolvedTarget === \"string\" ? resolvedTarget : undefined,\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n    if (typeof params.to === \"string\") {\n        params.to = snapshot.children[params.to];\n    }\n}\nfunction executeSendTo(actorScope, params) {\n    // this forms an outgoing events queue\n    // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n    actorScope.defer(()=>{\n        const { to, event, delay, id } = params;\n        if (typeof delay === \"number\") {\n            actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n            return;\n        }\n        actorScope.system._relay(actorScope.self, // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n        // if it initially started as a string\n        to, event.type === _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.W ? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.Y)(actorScope.self.id, event.data) : event);\n    });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event\n *   to send\n * @param options Send action options\n *\n *   - `id` - The unique send event identifier (used with `cancel()`).\n *   - `delay` - The number of milliseconds to delay the sending of the event.\n */ function sendTo(to, eventOrExpr, options) {\n    if (_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.V) {\n        console.warn(\"Custom actions should not call `sendTo()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function sendTo(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    sendTo.type = \"xstate.sendTo\";\n    sendTo.to = to;\n    sendTo.event = eventOrExpr;\n    sendTo.id = options === null || options === void 0 ? void 0 : options.id;\n    sendTo.delay = options === null || options === void 0 ? void 0 : options.delay;\n    sendTo.resolve = resolveSendTo;\n    sendTo.retryResolve = retryResolveSendTo;\n    sendTo.execute = executeSendTo;\n    return sendTo;\n}\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */ function sendParent(event, options) {\n    return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */ function forwardTo(target, options) {\n    if (!target || typeof target === \"function\") {\n        const originalTarget = target;\n        target = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const resolvedTarget = typeof originalTarget === \"function\" ? originalTarget(...args) : originalTarget;\n            if (!resolvedTarget) {\n                throw new Error(\"Attempted to forward event to undefined actor. This risks an infinite loop in the sender.\");\n            }\n            return resolvedTarget;\n        };\n    }\n    return sendTo(target, (param)=>{\n        let { event } = param;\n        return event;\n    }, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, param) {\n    let { collect } = param;\n    const actions = [];\n    const enqueue = function enqueue(action) {\n        actions.push(action);\n    };\n    enqueue.assign = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        actions.push(assign(...args));\n    };\n    enqueue.cancel = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.M)(...args));\n    };\n    enqueue.raise = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.O)(...args));\n    };\n    enqueue.sendTo = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n        // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n        actions.push(sendTo(...args));\n    };\n    enqueue.sendParent = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        actions.push(sendParent(...args));\n    };\n    enqueue.spawnChild = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.P)(...args));\n    };\n    enqueue.stopChild = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        actions.push((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.R)(...args));\n    };\n    enqueue.emit = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        actions.push(emit(...args));\n    };\n    collect({\n        context: args.context,\n        event: args.event,\n        enqueue,\n        check: (guard)=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(guard, snapshot.context, args.event, snapshot),\n        self: actorScope.self,\n        system: actorScope.system\n    }, actionParams);\n    return [\n        snapshot,\n        undefined,\n        actions\n    ];\n}\n/**\n * Creates an action object that will execute actions that are queued by the\n * `enqueue(action)` function.\n *\n * @example\n *\n * ```ts\n * import { createMachine, enqueueActions } from 'xstate';\n *\n * const machine = createMachine({\n *   entry: enqueueActions(({ enqueue, check }) => {\n *     enqueue.assign({ count: 0 });\n *\n *     if (check('someGuard')) {\n *       enqueue.assign({ count: 1 });\n *     }\n *\n *     enqueue('someAction');\n *   })\n * });\n * ```\n */ function enqueueActions(collect) {\n    function enqueueActions(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    enqueueActions.type = \"xstate.enqueueActions\";\n    enqueueActions.collect = collect;\n    enqueueActions.resolve = resolveEnqueueActions;\n    return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, param) {\n    let { value, label } = param;\n    return [\n        snapshot,\n        {\n            value: typeof value === \"function\" ? value(actionArgs, actionParams) : value,\n            label\n        },\n        undefined\n    ];\n}\nfunction executeLog(param, param1) {\n    let { logger } = param, { value, label } = param1;\n    if (label) {\n        logger(label, value);\n    } else {\n        logger(value);\n    }\n}\n/**\n * @param expr The expression function to evaluate which will be logged. Takes\n *   in 2 arguments:\n *\n *   - `ctx` - the current state context\n *   - `event` - the event that caused this action to be executed.\n *\n * @param label The label to give to the logged expression.\n */ function log() {\n    let value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (param)=>{\n        let { context, event } = param;\n        return {\n            context,\n            event\n        };\n    }, label = arguments.length > 1 ? arguments[1] : void 0;\n    function log(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    log.type = \"xstate.log\";\n    log.value = value;\n    log.label = label;\n    log.resolve = resolveLog;\n    log.execute = executeLog;\n    return log;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9sb2ctMGFjZDkwNjkuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErUztBQUUvUyxTQUFTd0IsY0FBY0MsVUFBVSxFQUFFLEtBR2xDLEVBQUVDLEtBQUssRUFBRUMsZUFBZTtRQUhVLEVBQ2pDQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUhrQztJQUlqQyxNQUFNQyxRQUFRLENBQUNDLEtBQUtDO1FBQ2xCLElBQUksT0FBT0QsUUFBUSxVQUFVO1lBQzNCLE1BQU1FLFFBQVE5QixxRUFBc0JBLENBQUN5QixTQUFTRztZQUM5QyxJQUFJLENBQUNFLE9BQU87Z0JBQ1YsTUFBTSxJQUFJQyxNQUFNLGdCQUFvRE4sT0FBcENHLEtBQUksa0NBQTJDLE9BQVhILFFBQVFPLEVBQUUsRUFBQztZQUNqRjtZQUNBLE1BQU1DLFdBQVcvQixxRUFBV0EsQ0FBQzRCLE9BQU87Z0JBQ2xDRSxFQUFFLEVBQUVILG9CQUFBQSw4QkFBQUEsUUFBU0csRUFBRTtnQkFDZkUsUUFBUVosV0FBV2EsSUFBSTtnQkFDdkJDLFlBQVksRUFBRVAsb0JBQUFBLDhCQUFBQSxRQUFTTyxZQUFZO2dCQUNuQ0MsT0FBTyxRQUFPUixvQkFBQUEsOEJBQUFBLFFBQVNRLEtBQUssTUFBSyxhQUFhUixRQUFRUSxLQUFLLENBQUM7b0JBQzFEWDtvQkFDQUg7b0JBQ0FZLE1BQU1iLFdBQVdhLElBQUk7Z0JBQ3ZCLEtBQUtOLG9CQUFBQSw4QkFBQUEsUUFBU1EsS0FBSztnQkFDbkJUO2dCQUNBVSxRQUFRLEVBQUVULG9CQUFBQSw4QkFBQUEsUUFBU1MsUUFBUTtZQUM3QjtZQUNBZCxlQUFlLENBQUNTLFNBQVNELEVBQUUsQ0FBQyxHQUFHQztZQUMvQixPQUFPQTtRQUNULE9BQU87WUFDTCxNQUFNQSxXQUFXL0IscUVBQVdBLENBQUMwQixLQUFLO2dCQUNoQ0ksRUFBRSxFQUFFSCxvQkFBQUEs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SUEsT0FBTztRQUNURSxPQUFPRixPQUFPRDtJQUNoQixPQUFPO1FBQ0xHLE9BQU9IO0lBQ1Q7QUFDRjtBQUNBOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0k7UUFBSUosUUFBQUEsaUVBQVE7WUFBQyxFQUNwQjNGLE9BQU8sRUFDUEgsS0FBSyxFQUNOO2VBQU07WUFDTEc7WUFDQUg7UUFDRjtPQUFJK0Y7SUFDRixTQUFTRyxJQUFJM0QsS0FBSyxFQUFFQyxPQUFPO1FBQ3pCO1lBQ0UsTUFBTSxJQUFJaEMsTUFBTztRQUNuQjtJQUNGO0lBQ0EwRixJQUFJekQsSUFBSSxHQUFHO0lBQ1h5RCxJQUFJSixLQUFLLEdBQUdBO0lBQ1pJLElBQUlILEtBQUssR0FBR0E7SUFDWkcsSUFBSXhELE9BQU8sR0FBR21EO0lBQ2RLLElBQUloRCxPQUFPLEdBQUc4QztJQUNkLE9BQU9FO0FBQ1Q7QUFFb0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3hzdGF0ZS9kaXN0L2xvZy0wYWNkOTA2OS5kZXZlbG9wbWVudC5lc20uanM/YWUxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUIGFzIFByb2Nlc3NpbmdTdGF0dXMsIHogYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgQSBhcyBjcmVhdGVBY3RvciwgVSBhcyBjbG9uZU1hY2hpbmVTbmFwc2hvdCwgViBhcyBleGVjdXRpbmdDdXN0b21BY3Rpb24sIFcgYXMgWFNUQVRFX0VSUk9SLCBZIGFzIGNyZWF0ZUVycm9yQWN0b3JFdmVudCwgZSBhcyBldmFsdWF0ZUd1YXJkLCBNIGFzIGNhbmNlbCwgTyBhcyByYWlzZSwgUCBhcyBzcGF3bkNoaWxkLCBSIGFzIHN0b3BDaGlsZCB9IGZyb20gJy4vcmFpc2UtMWRiMjdhODIuZGV2ZWxvcG1lbnQuZXNtLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlU3Bhd25lcihhY3RvclNjb3BlLCB7XG4gIG1hY2hpbmUsXG4gIGNvbnRleHRcbn0sIGV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pIHtcbiAgY29uc3Qgc3Bhd24gPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsb2dpYyA9IHJlc29sdmVSZWZlcmVuY2VkQWN0b3IobWFjaGluZSwgc3JjKTtcbiAgICAgIGlmICghbG9naWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY3RvciBsb2dpYyAnJHtzcmN9JyBub3QgaW1wbGVtZW50ZWQgaW4gbWFjaGluZSAnJHttYWNoaW5lLmlkfSdgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3IobG9naWMsIHtcbiAgICAgICAgaWQ6IG9wdGlvbnM/LmlkLFxuICAgICAgICBwYXJlbnQ6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgICAgc3luY1NuYXBzaG90OiBvcHRpb25zPy5zeW5jU25hcHNob3QsXG4gICAgICAgIGlucHV0OiB0eXBlb2Ygb3B0aW9ucz8uaW5wdXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmlucHV0KHtcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZlxuICAgICAgICB9KSA6IG9wdGlvbnM/LmlucHV0LFxuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkOiBvcHRpb25zPy5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgICByZXR1cm4gYWN0b3JSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjdG9yUmVmID0gY3JlYXRlQWN0b3Ioc3JjLCB7XG4gICAgICAgIGlkOiBvcHRpb25zPy5pZCxcbiAgICAgICAgcGFyZW50OiBhY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogb3B0aW9ucz8uc3luY1NuYXBzaG90LFxuICAgICAgICBpbnB1dDogb3B0aW9ucz8uaW5wdXQsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IG9wdGlvbnM/LnN5c3RlbUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY3RvclJlZjtcbiAgICB9XG4gIH07XG4gIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYWN0b3JSZWYgPSBzcGF3bihzcmMsIG9wdGlvbnMpOyAvLyBUT0RPOiBmaXggdHlwZXNcbiAgICBzcGF3bmVkQ2hpbGRyZW5bYWN0b3JSZWYuaWRdID0gYWN0b3JSZWY7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBpZiAoYWN0b3JSZWYuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhY3RvclJlZi5zdGFydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY3RvclJlZjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzc2lnbihhY3RvclNjb3BlLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFzc2lnbm1lbnRcbn0pIHtcbiAgaWYgKCFzbmFwc2hvdC5jb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYXNzaWduIHRvIHVuZGVmaW5lZCBgY29udGV4dGAuIEVuc3VyZSB0aGF0IGBjb250ZXh0YCBpcyBkZWZpbmVkIGluIHRoZSBtYWNoaW5lIGNvbmZpZy4nKTtcbiAgfVxuICBjb25zdCBzcGF3bmVkQ2hpbGRyZW4gPSB7fTtcbiAgY29uc3QgYXNzaWduQXJncyA9IHtcbiAgICBjb250ZXh0OiBzbmFwc2hvdC5jb250ZXh0LFxuICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgIHNwYXduOiBjcmVhdGVTcGF3bmVyKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLmV2ZW50LCBzcGF3bmVkQ2hpbGRyZW4pLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH07XG4gIGxldCBwYXJ0aWFsVXBkYXRlID0ge307XG4gIGlmICh0eXBlb2YgYXNzaWdubWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcnRpYWxVcGRhdGUgPSBhc3NpZ25tZW50KGFzc2lnbkFyZ3MsIGFjdGlvblBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXNzaWdubWVudCkpIHtcbiAgICAgIGNvbnN0IHByb3BBc3NpZ25tZW50ID0gYXNzaWdubWVudFtrZXldO1xuICAgICAgcGFydGlhbFVwZGF0ZVtrZXldID0gdHlwZW9mIHByb3BBc3NpZ25tZW50ID09PSAnZnVuY3Rpb24nID8gcHJvcEFzc2lnbm1lbnQoYXNzaWduQXJncywgYWN0aW9uUGFyYW1zKSA6IHByb3BBc3NpZ25tZW50O1xuICAgIH1cbiAgfVxuICBjb25zdCB1cGRhdGVkQ29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIHNuYXBzaG90LmNvbnRleHQsIHBhcnRpYWxVcGRhdGUpO1xuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY29udGV4dDogdXBkYXRlZENvbnRleHQsXG4gICAgY2hpbGRyZW46IE9iamVjdC5rZXlzKHNwYXduZWRDaGlsZHJlbikubGVuZ3RoID8ge1xuICAgICAgLi4uc25hcHNob3QuY2hpbGRyZW4sXG4gICAgICAuLi5zcGF3bmVkQ2hpbGRyZW5cbiAgICB9IDogc25hcHNob3QuY2hpbGRyZW5cbiAgfSksIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBtYWNoaW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGFzc2lnbiB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgY291bnRNYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGNvbnRleHQ6IHtcbiAqICAgICBjb3VudDogMCxcbiAqICAgICBtZXNzYWdlOiAnJ1xuICogICB9LFxuICogICBvbjoge1xuICogICAgIGluYzoge1xuICogICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAqICAgICAgICAgY291bnQ6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5jb3VudCArIDFcbiAqICAgICAgIH0pXG4gKiAgICAgfSxcbiAqICAgICB1cGRhdGVNZXNzYWdlOiB7XG4gKiAgICAgICBhY3Rpb25zOiBhc3NpZ24oKHsgY29udGV4dCwgZXZlbnQgfSkgPT4ge1xuICogICAgICAgICByZXR1cm4ge1xuICogICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UudHJpbSgpXG4gKiAgICAgICAgIH07XG4gKiAgICAgICB9KVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXNzaWdubWVudCBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG8gdXBkYXRlLCBvclxuICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXJ0aWFsIGNvbnRleHQgdG9cbiAqICAgdXBkYXRlLlxuICovXG5mdW5jdGlvbiBhc3NpZ24oYXNzaWdubWVudCkge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYGFzc2lnbigpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBhc3NpZ24oX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbi50eXBlID0gJ3hzdGF0ZS5hc3NpZ24nO1xuICBhc3NpZ24uYXNzaWdubWVudCA9IGFzc2lnbm1lbnQ7XG4gIGFzc2lnbi5yZXNvbHZlID0gcmVzb2x2ZUFzc2lnbjtcbiAgcmV0dXJuIGFzc2lnbjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVtaXQoXywgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBldmVudDogZXZlbnRPckV4cHJcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIGV2ZW50OiByZXNvbHZlZEV2ZW50XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlRW1pdChhY3RvclNjb3BlLCB7XG4gIGV2ZW50XG59KSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4gYWN0b3JTY29wZS5lbWl0KGV2ZW50KSk7XG59XG4vKipcbiAqIEVtaXRzIGFuIGV2ZW50IHRvIGV2ZW50IGhhbmRsZXJzIHJlZ2lzdGVyZWQgb24gdGhlIGFjdG9yIHZpYSBgYWN0b3Iub24oZXZlbnQsXG4gKiBoYW5kbGVyKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgZW1pdCB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICAvLyAuLi5cbiAqICAgb246IHtcbiAqICAgICBzb21ldGhpbmc6IHtcbiAqICAgICAgIGFjdGlvbnM6IGVtaXQoe1xuICogICAgICAgICB0eXBlOiAnZW1pdHRlZCcsXG4gKiAgICAgICAgIHNvbWU6ICdkYXRhJ1xuICogICAgICAgfSlcbiAqICAgICB9XG4gKiAgIH1cbiAqICAgLy8gLi4uXG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpLnN0YXJ0KCk7XG4gKlxuICogYWN0b3Iub24oJ2VtaXR0ZWQnLCAoZXZlbnQpID0+IHtcbiAqICAgY29uc29sZS5sb2coZXZlbnQpO1xuICogfSk7XG4gKlxuICogYWN0b3Iuc2VuZCh7IHR5cGU6ICdzb21ldGhpbmcnIH0pO1xuICogLy8gbG9nczpcbiAqIC8vIHtcbiAqIC8vICAgdHlwZTogJ2VtaXR0ZWQnLFxuICogLy8gICBzb21lOiAnZGF0YSdcbiAqIC8vIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBlbWl0KC8qKiBUaGUgZXZlbnQgdG8gZW1pdCwgb3IgYW4gZXhwcmVzc2lvbiB0aGF0IHJldHVybnMgYW4gZXZlbnQgdG8gZW1pdC4gKi9cbmV2ZW50T3JFeHByKSB7XG4gIGlmIChleGVjdXRpbmdDdXN0b21BY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ0N1c3RvbSBhY3Rpb25zIHNob3VsZCBub3QgY2FsbCBgZW1pdCgpYCBkaXJlY3RseSwgYXMgaXQgaXMgbm90IGltcGVyYXRpdmUuIFNlZSBodHRwczovL3N0YXRlbHkuYWkvZG9jcy9hY3Rpb25zI2J1aWx0LWluLWFjdGlvbnMgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgfVxuICBmdW5jdGlvbiBlbWl0KF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBlbWl0LnR5cGUgPSAneHN0YXRlLmVtaXQnO1xuICBlbWl0LmV2ZW50ID0gZXZlbnRPckV4cHI7XG4gIGVtaXQucmVzb2x2ZSA9IHJlc29sdmVFbWl0O1xuICBlbWl0LmV4ZWN1dGUgPSBleGVjdXRlRW1pdDtcbiAgcmV0dXJuIGVtaXQ7XG59XG5cbi8qKlxuICogQHJlbWFya3NcbiAqIGBUIHwgdW5rbm93bmAgcmVkdWNlcyB0byBgdW5rbm93bmAgYW5kIHRoYXQgY2FuIGJlIHByb2JsZW1hdGljIHdoZW4gaXQgY29tZXNcbiAqIHRvIGNvbnRleHR1YWwgdHlwaW5nLiBJdCBlc3BlY2lhbGx5IGlzIGEgcHJvYmxlbSB3aGVuIHRoZSB1bmlvbiBoYXMgYVxuICogZnVuY3Rpb24gbWVtYmVyLCBsaWtlIGhlcmU6XG4gKlxuICogYGBgdHNcbiAqIGRlY2xhcmUgZnVuY3Rpb24gdGVzdChcbiAqICAgY2JPclZhbDogKChhcmc6IG51bWJlcikgPT4gdW5rbm93bikgfCB1bmtub3duXG4gKiApOiB2b2lkO1xuICogdGVzdCgoYXJnKSA9PiB7fSk7IC8vIG9vcHMsIGltcGxpY2l0IGFueVxuICogYGBgXG4gKlxuICogVGhpcyB0eXBlIGNhbiBiZSB1c2VkIHRvIGF2b2lkIHRoaXMgcHJvYmxlbS4gVGhpcyB1bmlvbiByZXByZXNlbnRzIHRoZSBzYW1lXG4gKiB2YWx1ZSBzcGFjZSBhcyBgdW5rbm93bmAuXG4gKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yMzE4MiNpc3N1ZWNvbW1lbnQtMzc5MDkxODg3XG5cbi8vIEBUT0RPOiBSZXBsYWNlIHdpdGggbmF0aXZlIGBOb0luZmVyYCB3aGVuIFRTIGlzc3VlIGdldHMgZml4ZWQ6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvcHVsbC81NzY3M1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIHRoZSBidWlsdC1pbiBgTm9JbmZlcmAgdHlwZSBpbnN0ZWFkICovXG5cbi8qKiBUaGUgZnVsbCBkZWZpbml0aW9uIG9mIGFuIGV2ZW50LCB3aXRoIGEgc3RyaW5nIGB0eXBlYC4gKi9cblxuLyoqXG4gKiBUaGUgc3RyaW5nIG9yIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHN0YXRlIHZhbHVlIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAqIHN0YXRlIG5vZGUuXG4gKlxuICogQHJlbWFya3NcbiAqIC0gRm9yIGEgY2hpbGQgYXRvbWljIHN0YXRlIG5vZGUsIHRoaXMgaXMgYSBzdHJpbmcsIGUuZy4sIGBcInBlbmRpbmdcImAuXG4gKiAtIEZvciBjb21wbGV4IHN0YXRlIG5vZGVzLCB0aGlzIGlzIGFuIG9iamVjdCwgZS5nLiwgYHsgc3VjY2VzczpcbiAqICAgXCJzb21lQ2hpbGRTdGF0ZVwiIH1gLlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYEFueU1hY2hpbmVTbmFwc2hvdGAgaW5zdGVhZCAqL1xuXG4vLyBUT0RPOiBwb3NzaWJseSByZWZhY3RvciB0aGlzIHNvbWVob3csIHVzZSBldmVuIGEgc2ltcGxlciB0eXBlLCBhbmQgbWF5YmUgZXZlbiBtYWtlIGBtYWNoaW5lLm9wdGlvbnNgIHByaXZhdGUgb3Igc29tZXRoaW5nXG4vKiogQGlnbm9yZSAqL1xuXG5sZXQgU3BlY2lhbFRhcmdldHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFNwZWNpYWxUYXJnZXRzKSB7XG4gIFNwZWNpYWxUYXJnZXRzW1wiUGFyZW50XCJdID0gXCIjX3BhcmVudFwiO1xuICBTcGVjaWFsVGFyZ2V0c1tcIkludGVybmFsXCJdID0gXCIjX2ludGVybmFsXCI7XG4gIHJldHVybiBTcGVjaWFsVGFyZ2V0cztcbn0oe30pO1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBbnlBY3RvcmAgaW5zdGVhZC4gKi9cblxuLy8gQmFzZWQgb24gUnhKUyB0eXBlc1xuXG4vLyBUT0RPOiBpbiB2NiwgdGhpcyBzaG91bGQgb25seSBhY2NlcHQgQW55QWN0b3JMb2dpYywgbGlrZSBBY3RvclJlZkZyb21Mb2dpY1xuXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGBBY3RvcjxUPmAgaW5zdGVhZC4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGxvZ2ljIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIGFjdG9yLlxuICpcbiAqIEB0ZW1wbGF0ZSBUU25hcHNob3QgLSBUaGUgdHlwZSBvZiB0aGUgc25hcHNob3QuXG4gKiBAdGVtcGxhdGUgVEV2ZW50IC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IG9iamVjdC5cbiAqIEB0ZW1wbGF0ZSBUSW5wdXQgLSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBAdGVtcGxhdGUgVFN5c3RlbSAtIFRoZSB0eXBlIG9mIHRoZSBhY3RvciBzeXN0ZW0uXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkICovXG5cbi8vIFRPRE86IGNvdmVyIGFsbCB0aGF0IGNhbiBiZSBhY3R1YWxseSByZXR1cm5lZFxuXG5mdW5jdGlvbiByZXNvbHZlU2VuZFRvKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgdG8sXG4gIGV2ZW50OiBldmVudE9yRXhwcixcbiAgaWQsXG4gIGRlbGF5XG59LCBleHRyYSkge1xuICBjb25zdCBkZWxheXNNYXAgPSBzbmFwc2hvdC5tYWNoaW5lLmltcGxlbWVudGF0aW9ucy5kZWxheXM7XG4gIGlmICh0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICBgT25seSBldmVudCBvYmplY3RzIG1heSBiZSB1c2VkIHdpdGggc2VuZFRvOyB1c2Ugc2VuZFRvKHsgdHlwZTogXCIke2V2ZW50T3JFeHByfVwiIH0pIGluc3RlYWRgKTtcbiAgfVxuICBjb25zdCByZXNvbHZlZEV2ZW50ID0gdHlwZW9mIGV2ZW50T3JFeHByID09PSAnZnVuY3Rpb24nID8gZXZlbnRPckV4cHIoYXJncywgYWN0aW9uUGFyYW1zKSA6IGV2ZW50T3JFeHByO1xuICBsZXQgcmVzb2x2ZWREZWxheTtcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjb25maWdEZWxheSA9IGRlbGF5c01hcCAmJiBkZWxheXNNYXBbZGVsYXldO1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgY29uZmlnRGVsYXkgPT09ICdmdW5jdGlvbicgPyBjb25maWdEZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogY29uZmlnRGVsYXk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb2x2ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gJ2Z1bmN0aW9uJyA/IGRlbGF5KGFyZ3MsIGFjdGlvblBhcmFtcykgOiBkZWxheTtcbiAgfVxuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiB0byA9PT0gJ2Z1bmN0aW9uJyA/IHRvKGFyZ3MsIGFjdGlvblBhcmFtcykgOiB0bztcbiAgbGV0IHRhcmdldEFjdG9yUmVmO1xuICBpZiAodHlwZW9mIHJlc29sdmVkVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvblxuICAgIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuUGFyZW50KSB7XG4gICAgICB0YXJnZXRBY3RvclJlZiA9IGFjdG9yU2NvcGUuc2VsZi5fcGFyZW50O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb25cbiAgICBlbHNlIGlmIChyZXNvbHZlZFRhcmdldCA9PT0gU3BlY2lhbFRhcmdldHMuSW50ZXJuYWwpIHtcbiAgICAgIHRhcmdldEFjdG9yUmVmID0gYWN0b3JTY29wZS5zZWxmO1xuICAgIH0gZWxzZSBpZiAocmVzb2x2ZWRUYXJnZXQuc3RhcnRzV2l0aCgnI18nKSkge1xuICAgICAgLy8gU0NYTUwgY29tcGF0aWJpbGl0eTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNTQ1hNTEV2ZW50UHJvY2Vzc29yXG4gICAgICAvLyAjX2ludm9rZWlkLiBJZiB0aGUgdGFyZ2V0IGlzIHRoZSBzcGVjaWFsIHRlcm0gJyNfaW52b2tlaWQnLCB3aGVyZSBpbnZva2VpZCBpcyB0aGUgaW52b2tlaWQgb2YgYW4gU0NYTUwgc2Vzc2lvbiB0aGF0IHRoZSBzZW5kaW5nIHNlc3Npb24gaGFzIGNyZWF0ZWQgYnkgPGludm9rZT4sIHRoZSBQcm9jZXNzb3IgbXVzdCBhZGQgdGhlIGV2ZW50IHRvIHRoZSBleHRlcm5hbCBxdWV1ZSBvZiB0aGF0IHNlc3Npb24uXG4gICAgICB0YXJnZXRBY3RvclJlZiA9IHNuYXBzaG90LmNoaWxkcmVuW3Jlc29sdmVkVGFyZ2V0LnNsaWNlKDIpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0QWN0b3JSZWYgPSBleHRyYS5kZWZlcnJlZEFjdG9ySWRzPy5pbmNsdWRlcyhyZXNvbHZlZFRhcmdldCkgPyByZXNvbHZlZFRhcmdldCA6IHNuYXBzaG90LmNoaWxkcmVuW3Jlc29sdmVkVGFyZ2V0XTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXRBY3RvclJlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gc2VuZCBldmVudCB0byBhY3RvciAnJHtyZXNvbHZlZFRhcmdldH0nIGZyb20gbWFjaGluZSAnJHtzbmFwc2hvdC5tYWNoaW5lLmlkfScuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldEFjdG9yUmVmID0gcmVzb2x2ZWRUYXJnZXQgfHwgYWN0b3JTY29wZS5zZWxmO1xuICB9XG4gIHJldHVybiBbc25hcHNob3QsIHtcbiAgICB0bzogdGFyZ2V0QWN0b3JSZWYsXG4gICAgdGFyZ2V0SWQ6IHR5cGVvZiByZXNvbHZlZFRhcmdldCA9PT0gJ3N0cmluZycgPyByZXNvbHZlZFRhcmdldCA6IHVuZGVmaW5lZCxcbiAgICBldmVudDogcmVzb2x2ZWRFdmVudCxcbiAgICBpZCxcbiAgICBkZWxheTogcmVzb2x2ZWREZWxheVxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gcmV0cnlSZXNvbHZlU2VuZFRvKF8sIHNuYXBzaG90LCBwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zLnRvID0gc25hcHNob3QuY2hpbGRyZW5bcGFyYW1zLnRvXTtcbiAgfVxufVxuZnVuY3Rpb24gZXhlY3V0ZVNlbmRUbyhhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgLy8gdGhpcyBmb3JtcyBhbiBvdXRnb2luZyBldmVudHMgcXVldWVcbiAgLy8gdGhhbmtzIHRvIHRoYXQgdGhlIHJlY2lwaWVudCBhY3RvcnMgYXJlIGFibGUgdG8gcmVhZCB0aGUgKnVwZGF0ZWQqIHNuYXBzaG90IHZhbHVlIG9mIHRoZSBzZW5kZXJcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdG8sXG4gICAgICBldmVudCxcbiAgICAgIGRlbGF5LFxuICAgICAgaWRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBhY3RvclNjb3BlLnN5c3RlbS5zY2hlZHVsZXIuc2NoZWR1bGUoYWN0b3JTY29wZS5zZWxmLCB0bywgZXZlbnQsIGRlbGF5LCBpZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdG9yU2NvcGUuc3lzdGVtLl9yZWxheShhY3RvclNjb3BlLnNlbGYsXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgaW4gYSBkZWZlcnJlZCB0YXNrLCBpdCBzaG91bGQgYWxyZWFkeSBiZSBtdXRhdGVkIGJ5IHJldHJ5UmVzb2x2ZVNlbmRUb1xuICAgIC8vIGlmIGl0IGluaXRpYWxseSBzdGFydGVkIGFzIGEgc3RyaW5nXG4gICAgdG8sIGV2ZW50LnR5cGUgPT09IFhTVEFURV9FUlJPUiA/IGNyZWF0ZUVycm9yQWN0b3JFdmVudChhY3RvclNjb3BlLnNlbGYuaWQsIGV2ZW50LmRhdGEpIDogZXZlbnQpO1xuICB9KTtcbn1cbi8qKlxuICogU2VuZHMgYW4gZXZlbnQgdG8gYW4gYWN0b3IuXG4gKlxuICogQHBhcmFtIGFjdG9yIFRoZSBgQWN0b3JSZWZgIHRvIHNlbmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0byBzZW5kLCBvciBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBldmVudFxuICogICB0byBzZW5kXG4gKiBAcGFyYW0gb3B0aW9ucyBTZW5kIGFjdGlvbiBvcHRpb25zXG4gKlxuICogICAtIGBpZGAgLSBUaGUgdW5pcXVlIHNlbmQgZXZlbnQgaWRlbnRpZmllciAodXNlZCB3aXRoIGBjYW5jZWwoKWApLlxuICogICAtIGBkZWxheWAgLSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc2VuZGluZyBvZiB0aGUgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRUbyh0bywgZXZlbnRPckV4cHIsIG9wdGlvbnMpIHtcbiAgaWYgKGV4ZWN1dGluZ0N1c3RvbUFjdGlvbikge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIGFjdGlvbnMgc2hvdWxkIG5vdCBjYWxsIGBzZW5kVG8oKWAgZGlyZWN0bHksIGFzIGl0IGlzIG5vdCBpbXBlcmF0aXZlLiBTZWUgaHR0cHM6Ly9zdGF0ZWx5LmFpL2RvY3MvYWN0aW9ucyNidWlsdC1pbi1hY3Rpb25zIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gIH1cbiAgZnVuY3Rpb24gc2VuZFRvKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzZW5kVG8udHlwZSA9ICd4c3RhdGUuc2VuZFRvJztcbiAgc2VuZFRvLnRvID0gdG87XG4gIHNlbmRUby5ldmVudCA9IGV2ZW50T3JFeHByO1xuICBzZW5kVG8uaWQgPSBvcHRpb25zPy5pZDtcbiAgc2VuZFRvLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXk7XG4gIHNlbmRUby5yZXNvbHZlID0gcmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLnJldHJ5UmVzb2x2ZSA9IHJldHJ5UmVzb2x2ZVNlbmRUbztcbiAgc2VuZFRvLmV4ZWN1dGUgPSBleGVjdXRlU2VuZFRvO1xuICByZXR1cm4gc2VuZFRvO1xufVxuXG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHRvIHRoaXMgbWFjaGluZSdzIHBhcmVudC5cbiAqXG4gKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHNlbmQgdG8gdGhlIHBhcmVudCBtYWNoaW5lLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRQYXJlbnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlbmRUbyhTcGVjaWFsVGFyZ2V0cy5QYXJlbnQsIGV2ZW50LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRm9yd2FyZHMgKHNlbmRzKSBhbiBldmVudCB0byB0aGUgYHRhcmdldGAgYWN0b3IuXG4gKlxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IGFjdG9yIHRvIGZvcndhcmQgdGhlIGV2ZW50IHRvLlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBwYXNzIGludG8gdGhlIHNlbmQgYWN0aW9uIGNyZWF0b3IuXG4gKi9cbmZ1bmN0aW9uIGZvcndhcmRUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgaWYgKCghdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG4gICAgdGFyZ2V0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVGFyZ2V0ID0gdHlwZW9mIG9yaWdpbmFsVGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3JpZ2luYWxUYXJnZXQoLi4uYXJncykgOiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIGlmICghcmVzb2x2ZWRUYXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gZm9yd2FyZCBldmVudCB0byB1bmRlZmluZWQgYWN0b3IuIFRoaXMgcmlza3MgYW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgc2VuZGVyLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVkVGFyZ2V0O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNlbmRUbyh0YXJnZXQsICh7XG4gICAgZXZlbnRcbiAgfSkgPT4gZXZlbnQsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRW5xdWV1ZUFjdGlvbnMoYWN0b3JTY29wZSwgc25hcHNob3QsIGFyZ3MsIGFjdGlvblBhcmFtcywge1xuICBjb2xsZWN0XG59KSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBbXTtcbiAgY29uc3QgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoYWN0aW9uKSB7XG4gICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH07XG4gIGVucXVldWUuYXNzaWduID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goYXNzaWduKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5jYW5jZWwgPSAoLi4uYXJncykgPT4ge1xuICAgIGFjdGlvbnMucHVzaChjYW5jZWwoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnJhaXNlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAvLyBmb3Igc29tZSByZWFzb24gaXQgZmFpbHMgdG8gaW5mZXIgYFREZWxheWAgZnJvbSBgLi4uYXJnc2AgaGVyZSBhbmQgcGlja3MgaXRzIGRlZmF1bHQgKGBuZXZlcmApXG4gICAgLy8gdGhlbiBpdCBmYWlscyB0byB0eXBlY2hlY2sgdGhhdCBiZWNhdXNlIGAuLi5hcmdzYCB1c2UgYHN0cmluZ2AgaW4gcGxhY2Ugb2YgYFREZWxheWBcbiAgICBhY3Rpb25zLnB1c2gocmFpc2UoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnNlbmRUbyA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gZm9yIHNvbWUgcmVhc29uIGl0IGZhaWxzIHRvIGluZmVyIGBURGVsYXlgIGZyb20gYC4uLmFyZ3NgIGhlcmUgYW5kIHBpY2tzIGl0cyBkZWZhdWx0IChgbmV2ZXJgKVxuICAgIC8vIHRoZW4gaXQgZmFpbHMgdG8gdHlwZWNoZWNrIHRoYXQgYmVjYXVzZSBgLi4uYXJnc2AgdXNlIGBzdHJpbmdgIGluIHBsYWNlIG9mIGBURGVsYXlcbiAgICBhY3Rpb25zLnB1c2goc2VuZFRvKC4uLmFyZ3MpKTtcbiAgfTtcbiAgZW5xdWV1ZS5zZW5kUGFyZW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBhY3Rpb25zLnB1c2goc2VuZFBhcmVudCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuc3Bhd25DaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHNwYXduQ2hpbGQoLi4uYXJncykpO1xuICB9O1xuICBlbnF1ZXVlLnN0b3BDaGlsZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKHN0b3BDaGlsZCguLi5hcmdzKSk7XG4gIH07XG4gIGVucXVldWUuZW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgYWN0aW9ucy5wdXNoKGVtaXQoLi4uYXJncykpO1xuICB9O1xuICBjb2xsZWN0KHtcbiAgICBjb250ZXh0OiBhcmdzLmNvbnRleHQsXG4gICAgZXZlbnQ6IGFyZ3MuZXZlbnQsXG4gICAgZW5xdWV1ZSxcbiAgICBjaGVjazogZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgc25hcHNob3QuY29udGV4dCwgYXJncy5ldmVudCwgc25hcHNob3QpLFxuICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICBzeXN0ZW06IGFjdG9yU2NvcGUuc3lzdGVtXG4gIH0sIGFjdGlvblBhcmFtcyk7XG4gIHJldHVybiBbc25hcHNob3QsIHVuZGVmaW5lZCwgYWN0aW9uc107XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYWN0aW9uIG9iamVjdCB0aGF0IHdpbGwgZXhlY3V0ZSBhY3Rpb25zIHRoYXQgYXJlIHF1ZXVlZCBieSB0aGVcbiAqIGBlbnF1ZXVlKGFjdGlvbilgIGZ1bmN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIGVucXVldWVBY3Rpb25zIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIGVudHJ5OiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlLCBjaGVjayB9KSA9PiB7XG4gKiAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMCB9KTtcbiAqXG4gKiAgICAgaWYgKGNoZWNrKCdzb21lR3VhcmQnKSkge1xuICogICAgICAgZW5xdWV1ZS5hc3NpZ24oeyBjb3VudDogMSB9KTtcbiAqICAgICB9XG4gKlxuICogICAgIGVucXVldWUoJ3NvbWVBY3Rpb24nKTtcbiAqICAgfSlcbiAqIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVBY3Rpb25zKGNvbGxlY3QpIHtcbiAgZnVuY3Rpb24gZW5xdWV1ZUFjdGlvbnMoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGVucXVldWVBY3Rpb25zLnR5cGUgPSAneHN0YXRlLmVucXVldWVBY3Rpb25zJztcbiAgZW5xdWV1ZUFjdGlvbnMuY29sbGVjdCA9IGNvbGxlY3Q7XG4gIGVucXVldWVBY3Rpb25zLnJlc29sdmUgPSByZXNvbHZlRW5xdWV1ZUFjdGlvbnM7XG4gIHJldHVybiBlbnF1ZXVlQWN0aW9ucztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxvZyhfLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHZhbHVlLFxuICBsYWJlbFxufSkge1xuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgdmFsdWU6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcykgOiB2YWx1ZSxcbiAgICBsYWJlbFxuICB9LCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gZXhlY3V0ZUxvZyh7XG4gIGxvZ2dlclxufSwge1xuICB2YWx1ZSxcbiAgbGFiZWxcbn0pIHtcbiAgaWYgKGxhYmVsKSB7XG4gICAgbG9nZ2VyKGxhYmVsLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbG9nZ2VyKHZhbHVlKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gZXhwciBUaGUgZXhwcmVzc2lvbiBmdW5jdGlvbiB0byBldmFsdWF0ZSB3aGljaCB3aWxsIGJlIGxvZ2dlZC4gVGFrZXNcbiAqICAgaW4gMiBhcmd1bWVudHM6XG4gKlxuICogICAtIGBjdHhgIC0gdGhlIGN1cnJlbnQgc3RhdGUgY29udGV4dFxuICogICAtIGBldmVudGAgLSB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG4gKlxuICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB0byBnaXZlIHRvIHRoZSBsb2dnZWQgZXhwcmVzc2lvbi5cbiAqL1xuZnVuY3Rpb24gbG9nKHZhbHVlID0gKHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0pID0+ICh7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59KSwgbGFiZWwpIHtcbiAgZnVuY3Rpb24gbG9nKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBsb2cudHlwZSA9ICd4c3RhdGUubG9nJztcbiAgbG9nLnZhbHVlID0gdmFsdWU7XG4gIGxvZy5sYWJlbCA9IGxhYmVsO1xuICBsb2cucmVzb2x2ZSA9IHJlc29sdmVMb2c7XG4gIGxvZy5leGVjdXRlID0gZXhlY3V0ZUxvZztcbiAgcmV0dXJuIGxvZztcbn1cblxuZXhwb3J0IHsgU3BlY2lhbFRhcmdldHMgYXMgUywgYXNzaWduIGFzIGEsIGVucXVldWVBY3Rpb25zIGFzIGIsIHNlbmRUbyBhcyBjLCBlbWl0IGFzIGUsIGZvcndhcmRUbyBhcyBmLCBsb2cgYXMgbCwgc2VuZFBhcmVudCBhcyBzIH07XG4iXSwibmFtZXMiOlsiVCIsIlByb2Nlc3NpbmdTdGF0dXMiLCJ6IiwicmVzb2x2ZVJlZmVyZW5jZWRBY3RvciIsIkEiLCJjcmVhdGVBY3RvciIsIlUiLCJjbG9uZU1hY2hpbmVTbmFwc2hvdCIsIlYiLCJleGVjdXRpbmdDdXN0b21BY3Rpb24iLCJXIiwiWFNUQVRFX0VSUk9SIiwiWSIsImNyZWF0ZUVycm9yQWN0b3JFdmVudCIsImUiLCJldmFsdWF0ZUd1YXJkIiwiTSIsImNhbmNlbCIsIk8iLCJyYWlzZSIsIlAiLCJzcGF3bkNoaWxkIiwiUiIsInN0b3BDaGlsZCIsImNyZWF0ZVNwYXduZXIiLCJhY3RvclNjb3BlIiwiZXZlbnQiLCJzcGF3bmVkQ2hpbGRyZW4iLCJtYWNoaW5lIiwiY29udGV4dCIsInNwYXduIiwic3JjIiwib3B0aW9ucyIsImxvZ2ljIiwiRXJyb3IiLCJpZCIsImFjdG9yUmVmIiwicGFyZW50Iiwic2VsZiIsInN5bmNTbmFwc2hvdCIsImlucHV0Iiwic3lzdGVtSWQiLCJkZWZlciIsIl9wcm9jZXNzaW5nU3RhdHVzIiwiU3RvcHBlZCIsInN0YXJ0IiwicmVzb2x2ZUFzc2lnbiIsInNuYXBzaG90IiwiYWN0aW9uQXJncyIsImFjdGlvblBhcmFtcyIsImFzc2lnbm1lbnQiLCJhc3NpZ25BcmdzIiwic3lzdGVtIiwicGFydGlhbFVwZGF0ZSIsImtleSIsIk9iamVjdCIsImtleXMiLCJwcm9wQXNzaWdubWVudCIsInVwZGF0ZWRDb250ZXh0IiwiYXNzaWduIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsIl9hcmdzIiwiX3BhcmFtcyIsInR5cGUiLCJyZXNvbHZlIiwicmVzb2x2ZUVtaXQiLCJfIiwiYXJncyIsImV2ZW50T3JFeHByIiwicmVzb2x2ZWRFdmVudCIsImV4ZWN1dGVFbWl0IiwiZW1pdCIsImV4ZWN1dGUiLCJTcGVjaWFsVGFyZ2V0cyIsInJlc29sdmVTZW5kVG8iLCJleHRyYSIsInRvIiwiZGVsYXkiLCJkZWxheXNNYXAiLCJpbXBsZW1lbnRhdGlvbnMiLCJkZWxheXMiLCJyZXNvbHZlZERlbGF5IiwiY29uZmlnRGVsYXkiLCJyZXNvbHZlZFRhcmdldCIsInRhcmdldEFjdG9yUmVmIiwiUGFyZW50IiwiX3BhcmVudCIsIkludGVybmFsIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiZGVmZXJyZWRBY3RvcklkcyIsImluY2x1ZGVzIiwidGFyZ2V0SWQiLCJyZXRyeVJlc29sdmVTZW5kVG8iLCJwYXJhbXMiLCJleGVjdXRlU2VuZFRvIiwic2NoZWR1bGVyIiwic2NoZWR1bGUiLCJfcmVsYXkiLCJkYXRhIiwic2VuZFRvIiwicmV0cnlSZXNvbHZlIiwic2VuZFBhcmVudCIsImZvcndhcmRUbyIsInRhcmdldCIsIm9yaWdpbmFsVGFyZ2V0IiwicmVzb2x2ZUVucXVldWVBY3Rpb25zIiwiY29sbGVjdCIsImFjdGlvbnMiLCJlbnF1ZXVlIiwiYWN0aW9uIiwicHVzaCIsImNoZWNrIiwiZ3VhcmQiLCJlbnF1ZXVlQWN0aW9ucyIsInJlc29sdmVMb2ciLCJ2YWx1ZSIsImxhYmVsIiwiZXhlY3V0ZUxvZyIsImxvZ2dlciIsImxvZyIsIlMiLCJhIiwiYiIsImMiLCJmIiwibCIsInMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/xstate/dist/raise-1db27a82.development.esm.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ $$ACTOR_TYPE; },\n/* harmony export */   A: function() { return /* binding */ createActor; },\n/* harmony export */   B: function() { return /* binding */ Actor; },\n/* harmony export */   C: function() { return /* binding */ interpret; },\n/* harmony export */   D: function() { return /* binding */ and; },\n/* harmony export */   E: function() { return /* binding */ not; },\n/* harmony export */   F: function() { return /* binding */ or; },\n/* harmony export */   G: function() { return /* binding */ stateIn; },\n/* harmony export */   H: function() { return /* binding */ isMachineSnapshot; },\n/* harmony export */   I: function() { return /* binding */ getAllOwnEventDescriptors; },\n/* harmony export */   J: function() { return /* binding */ matchesState; },\n/* harmony export */   K: function() { return /* binding */ pathToStateValue; },\n/* harmony export */   L: function() { return /* binding */ toObserver; },\n/* harmony export */   M: function() { return /* binding */ cancel; },\n/* harmony export */   N: function() { return /* binding */ NULL_EVENT; },\n/* harmony export */   O: function() { return /* binding */ raise; },\n/* harmony export */   P: function() { return /* binding */ spawnChild; },\n/* harmony export */   Q: function() { return /* binding */ stop; },\n/* harmony export */   R: function() { return /* binding */ stopChild; },\n/* harmony export */   S: function() { return /* binding */ STATE_DELIMITER; },\n/* harmony export */   T: function() { return /* binding */ ProcessingStatus; },\n/* harmony export */   U: function() { return /* binding */ cloneMachineSnapshot; },\n/* harmony export */   V: function() { return /* binding */ executingCustomAction; },\n/* harmony export */   W: function() { return /* binding */ XSTATE_ERROR; },\n/* harmony export */   X: function() { return /* binding */ XSTATE_STOP; },\n/* harmony export */   Y: function() { return /* binding */ createErrorActorEvent; },\n/* harmony export */   a: function() { return /* binding */ toTransitionConfigArray; },\n/* harmony export */   b: function() { return /* binding */ formatTransition; },\n/* harmony export */   c: function() { return /* binding */ createInvokeId; },\n/* harmony export */   d: function() { return /* binding */ formatInitialTransition; },\n/* harmony export */   e: function() { return /* binding */ evaluateGuard; },\n/* harmony export */   f: function() { return /* binding */ formatTransitions; },\n/* harmony export */   g: function() { return /* binding */ getDelayedTransitions; },\n/* harmony export */   h: function() { return /* binding */ getCandidates; },\n/* harmony export */   i: function() { return /* binding */ getAllStateNodes; },\n/* harmony export */   j: function() { return /* binding */ getStateNodes; },\n/* harmony export */   k: function() { return /* binding */ createMachineSnapshot; },\n/* harmony export */   l: function() { return /* binding */ isInFinalState; },\n/* harmony export */   m: function() { return /* binding */ mapValues; },\n/* harmony export */   n: function() { return /* binding */ macrostep; },\n/* harmony export */   o: function() { return /* binding */ transitionNode; },\n/* harmony export */   p: function() { return /* binding */ resolveActionsAndContext; },\n/* harmony export */   q: function() { return /* binding */ createInitEvent; },\n/* harmony export */   r: function() { return /* binding */ resolveStateValue; },\n/* harmony export */   s: function() { return /* binding */ microstep; },\n/* harmony export */   t: function() { return /* binding */ toArray; },\n/* harmony export */   u: function() { return /* binding */ getInitialStateNodes; },\n/* harmony export */   v: function() { return /* binding */ toStatePath; },\n/* harmony export */   w: function() { return /* binding */ isStateId; },\n/* harmony export */   x: function() { return /* binding */ getStateNodeByPath; },\n/* harmony export */   y: function() { return /* binding */ getPersistedSnapshot; },\n/* harmony export */   z: function() { return /* binding */ resolveReferencedActor; }\n/* harmony export */ });\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\nclass Mailbox {\n    start() {\n        this._active = true;\n        this.flush();\n    }\n    clear() {\n        // we can't set _current to null because we might be currently processing\n        // and enqueue following clear shouldnt start processing the enqueued item immediately\n        if (this._current) {\n            this._current.next = null;\n            this._last = this._current;\n        }\n    }\n    enqueue(event) {\n        const enqueued = {\n            value: event,\n            next: null\n        };\n        if (this._current) {\n            this._last.next = enqueued;\n            this._last = enqueued;\n            return;\n        }\n        this._current = enqueued;\n        this._last = enqueued;\n        if (this._active) {\n            this.flush();\n        }\n    }\n    flush() {\n        while(this._current){\n            // atm the given _process is responsible for implementing proper try/catch handling\n            // we assume here that this won't throw in a way that can affect this mailbox\n            const consumed = this._current;\n            this._process(consumed.value);\n            this._current = consumed.next;\n        }\n        this._last = null;\n    }\n    constructor(_process){\n        this._process = _process;\n        this._active = false;\n        this._current = null;\n        this._last = null;\n    }\n}\nconst STATE_DELIMITER = \".\";\nconst TARGETLESS_KEY = \"\";\nconst NULL_EVENT = \"\";\nconst STATE_IDENTIFIER = \"#\";\nconst WILDCARD = \"*\";\nconst XSTATE_INIT = \"xstate.init\";\nconst XSTATE_ERROR = \"xstate.error\";\nconst XSTATE_STOP = \"xstate.stop\";\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */ function createAfterEvent(delayRef, id) {\n    return {\n        type: \"xstate.after.\".concat(delayRef, \".\").concat(id)\n    };\n}\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */ function createDoneStateEvent(id, output) {\n    return {\n        type: \"xstate.done.state.\".concat(id),\n        output\n    };\n}\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */ function createDoneActorEvent(invokeId, output) {\n    return {\n        type: \"xstate.done.actor.\".concat(invokeId),\n        output,\n        actorId: invokeId\n    };\n}\nfunction createErrorActorEvent(id, error) {\n    return {\n        type: \"xstate.error.actor.\".concat(id),\n        error,\n        actorId: id\n    };\n}\nfunction createInitEvent(input) {\n    return {\n        type: XSTATE_INIT,\n        input\n    };\n}\n/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */ function reportUnhandledError(err) {\n    setTimeout(()=>{\n        throw err;\n    });\n}\nconst symbolObservable = (()=>typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\nfunction matchesState(parentStateId, childStateId) {\n    const parentStateValue = toStateValue(parentStateId);\n    const childStateValue = toStateValue(childStateId);\n    if (typeof childStateValue === \"string\") {\n        if (typeof parentStateValue === \"string\") {\n            return childStateValue === parentStateValue;\n        }\n        // Parent more specific than child\n        return false;\n    }\n    if (typeof parentStateValue === \"string\") {\n        return parentStateValue in childStateValue;\n    }\n    return Object.keys(parentStateValue).every((key)=>{\n        if (!(key in childStateValue)) {\n            return false;\n        }\n        return matchesState(parentStateValue[key], childStateValue[key]);\n    });\n}\nfunction toStatePath(stateId) {\n    if (isArray(stateId)) {\n        return stateId;\n    }\n    const result = [];\n    let segment = \"\";\n    for(let i = 0; i < stateId.length; i++){\n        const char = stateId.charCodeAt(i);\n        switch(char){\n            // \\\n            case 92:\n                // consume the next character\n                segment += stateId[i + 1];\n                // and skip over it\n                i++;\n                continue;\n            // .\n            case 46:\n                result.push(segment);\n                segment = \"\";\n                continue;\n        }\n        segment += stateId[i];\n    }\n    result.push(segment);\n    return result;\n}\nfunction toStateValue(stateValue) {\n    if (isMachineSnapshot(stateValue)) {\n        return stateValue.value;\n    }\n    if (typeof stateValue !== \"string\") {\n        return stateValue;\n    }\n    const statePath = toStatePath(stateValue);\n    return pathToStateValue(statePath);\n}\nfunction pathToStateValue(statePath) {\n    if (statePath.length === 1) {\n        return statePath[0];\n    }\n    const value = {};\n    let marker = value;\n    for(let i = 0; i < statePath.length - 1; i++){\n        if (i === statePath.length - 2) {\n            marker[statePath[i]] = statePath[i + 1];\n        } else {\n            const previous = marker;\n            marker = {};\n            previous[statePath[i]] = marker;\n        }\n    }\n    return value;\n}\nfunction mapValues(collection, iteratee) {\n    const result = {};\n    const collectionKeys = Object.keys(collection);\n    for(let i = 0; i < collectionKeys.length; i++){\n        const key = collectionKeys[i];\n        result[key] = iteratee(collection[key], key, collection, i);\n    }\n    return result;\n}\nfunction toArrayStrict(value) {\n    if (isArray(value)) {\n        return value;\n    }\n    return [\n        value\n    ];\n}\nfunction toArray(value) {\n    if (value === undefined) {\n        return [];\n    }\n    return toArrayStrict(value);\n}\nfunction resolveOutput(mapper, context, event, self) {\n    if (typeof mapper === \"function\") {\n        return mapper({\n            context,\n            event,\n            self\n        });\n    }\n    if (!!mapper && typeof mapper === \"object\" && Object.values(mapper).some((val)=>typeof val === \"function\")) {\n        console.warn(\"Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: \".concat(Object.entries(mapper).filter((param)=>{\n            let [, value] = param;\n            return typeof value === \"function\";\n        }).map((param)=>{\n            let [key, value] = param;\n            return \"\\n - \".concat(key, \": \").concat(value.toString().replace(/\\n\\s*/g, \"\"));\n        }).join(\"\")));\n    }\n    return mapper;\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\nfunction isErrorActorEvent(event) {\n    return event.type.startsWith(\"xstate.error.actor\");\n}\nfunction toTransitionConfigArray(configLike) {\n    return toArrayStrict(configLike).map((transitionLike)=>{\n        if (typeof transitionLike === \"undefined\" || typeof transitionLike === \"string\") {\n            return {\n                target: transitionLike\n            };\n        }\n        return transitionLike;\n    });\n}\nfunction normalizeTarget(target) {\n    if (target === undefined || target === TARGETLESS_KEY) {\n        return undefined;\n    }\n    return toArray(target);\n}\nfunction toObserver(nextHandler, errorHandler, completionHandler) {\n    var _this, _this1, _this2;\n    const isObserver = typeof nextHandler === \"object\";\n    const self = isObserver ? nextHandler : undefined;\n    return {\n        next: (_this = isObserver ? nextHandler.next : nextHandler) === null || _this === void 0 ? void 0 : _this.bind(self),\n        error: (_this1 = isObserver ? nextHandler.error : errorHandler) === null || _this1 === void 0 ? void 0 : _this1.bind(self),\n        complete: (_this2 = isObserver ? nextHandler.complete : completionHandler) === null || _this2 === void 0 ? void 0 : _this2.bind(self)\n    };\n}\nfunction createInvokeId(stateNodeId, index) {\n    return \"\".concat(index, \".\").concat(stateNodeId);\n}\nfunction resolveReferencedActor(machine, src) {\n    const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/);\n    if (!match) {\n        return machine.implementations.actors[src];\n    }\n    const [, indexStr, nodeId] = match;\n    const node = machine.getStateNodeById(nodeId);\n    const invokeConfig = node.config.invoke;\n    return (Array.isArray(invokeConfig) ? invokeConfig[indexStr] : invokeConfig).src;\n}\nfunction getAllOwnEventDescriptors(snapshot) {\n    return [\n        ...new Set([\n            ...snapshot._nodes.flatMap((sn)=>sn.ownEvents)\n        ])\n    ];\n}\nfunction createScheduledEventId(actorRef, id) {\n    return \"\".concat(actorRef.sessionId, \".\").concat(id);\n}\nlet idCounter = 0;\nfunction createSystem(rootActor, options) {\n    const children = new Map();\n    const keyedActors = new Map();\n    const reverseKeyedActors = new WeakMap();\n    const inspectionObservers = new Set();\n    const timerMap = {};\n    const { clock, logger } = options;\n    const scheduler = {\n        schedule: function(source, target, event, delay) {\n            let id = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Math.random().toString(36).slice(2);\n            const scheduledEvent = {\n                source,\n                target,\n                event,\n                delay,\n                id,\n                startedAt: Date.now()\n            };\n            const scheduledEventId = createScheduledEventId(source, id);\n            system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n            const timeout = clock.setTimeout(()=>{\n                delete timerMap[scheduledEventId];\n                delete system._snapshot._scheduledEvents[scheduledEventId];\n                system._relay(source, target, event);\n            }, delay);\n            timerMap[scheduledEventId] = timeout;\n        },\n        cancel: (source, id)=>{\n            const scheduledEventId = createScheduledEventId(source, id);\n            const timeout = timerMap[scheduledEventId];\n            delete timerMap[scheduledEventId];\n            delete system._snapshot._scheduledEvents[scheduledEventId];\n            if (timeout !== undefined) {\n                clock.clearTimeout(timeout);\n            }\n        },\n        cancelAll: (actorRef)=>{\n            for(const scheduledEventId in system._snapshot._scheduledEvents){\n                const scheduledEvent = system._snapshot._scheduledEvents[scheduledEventId];\n                if (scheduledEvent.source === actorRef) {\n                    scheduler.cancel(actorRef, scheduledEvent.id);\n                }\n            }\n        }\n    };\n    const sendInspectionEvent = (event)=>{\n        if (!inspectionObservers.size) {\n            return;\n        }\n        const resolvedInspectionEvent = {\n            ...event,\n            rootId: rootActor.sessionId\n        };\n        inspectionObservers.forEach((observer)=>{\n            var _observer_next;\n            return (_observer_next = observer.next) === null || _observer_next === void 0 ? void 0 : _observer_next.call(observer, resolvedInspectionEvent);\n        });\n    };\n    var _ref;\n    const system = {\n        _snapshot: {\n            _scheduledEvents: (_ref = (options === null || options === void 0 ? void 0 : options.snapshot) && options.snapshot.scheduler) !== null && _ref !== void 0 ? _ref : {}\n        },\n        _bookId: ()=>\"x:\".concat(idCounter++),\n        _register: (sessionId, actorRef)=>{\n            children.set(sessionId, actorRef);\n            return sessionId;\n        },\n        _unregister: (actorRef)=>{\n            children.delete(actorRef.sessionId);\n            const systemId = reverseKeyedActors.get(actorRef);\n            if (systemId !== undefined) {\n                keyedActors.delete(systemId);\n                reverseKeyedActors.delete(actorRef);\n            }\n        },\n        get: (systemId)=>{\n            return keyedActors.get(systemId);\n        },\n        _set: (systemId, actorRef)=>{\n            const existing = keyedActors.get(systemId);\n            if (existing && existing !== actorRef) {\n                throw new Error(\"Actor with system ID '\".concat(systemId, \"' already exists.\"));\n            }\n            keyedActors.set(systemId, actorRef);\n            reverseKeyedActors.set(actorRef, systemId);\n        },\n        inspect: (observerOrFn)=>{\n            const observer = toObserver(observerOrFn);\n            inspectionObservers.add(observer);\n            return {\n                unsubscribe () {\n                    inspectionObservers.delete(observer);\n                }\n            };\n        },\n        _sendInspectionEvent: sendInspectionEvent,\n        _relay: (source, target, event)=>{\n            system._sendInspectionEvent({\n                type: \"@xstate.event\",\n                sourceRef: source,\n                actorRef: target,\n                event\n            });\n            target._send(event);\n        },\n        scheduler,\n        getSnapshot: ()=>{\n            return {\n                _scheduledEvents: {\n                    ...system._snapshot._scheduledEvents\n                }\n            };\n        },\n        start: ()=>{\n            const scheduledEvents = system._snapshot._scheduledEvents;\n            system._snapshot._scheduledEvents = {};\n            for(const scheduledId in scheduledEvents){\n                const { source, target, event, delay, id } = scheduledEvents[scheduledId];\n                scheduler.schedule(source, target, event, delay, id);\n            }\n        },\n        _clock: clock,\n        _logger: logger\n    };\n    return system;\n}\nlet executingCustomAction = false;\nconst $$ACTOR_TYPE = 1;\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nlet ProcessingStatus = /*#__PURE__*/ function(ProcessingStatus) {\n    ProcessingStatus[ProcessingStatus[\"NotStarted\"] = 0] = \"NotStarted\";\n    ProcessingStatus[ProcessingStatus[\"Running\"] = 1] = \"Running\";\n    ProcessingStatus[ProcessingStatus[\"Stopped\"] = 2] = \"Stopped\";\n    return ProcessingStatus;\n}({});\nconst defaultOptions = {\n    clock: {\n        setTimeout: (fn, ms)=>{\n            return setTimeout(fn, ms);\n        },\n        clearTimeout: (id)=>{\n            return clearTimeout(id);\n        }\n    },\n    logger: console.log.bind(console),\n    devTools: false\n};\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */ class Actor {\n    _initState(persistedState) {\n        try {\n            var _this_options;\n            this._snapshot = persistedState ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(persistedState, this._actorScope) : persistedState : this.logic.getInitialSnapshot(this._actorScope, (_this_options = this.options) === null || _this_options === void 0 ? void 0 : _this_options.input);\n        } catch (err) {\n            // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n            // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n            // so right now this is a lie of sorts\n            this._snapshot = {\n                status: \"error\",\n                output: undefined,\n                error: err\n            };\n        }\n    }\n    update(snapshot, event) {\n        // Update state\n        this._snapshot = snapshot;\n        // Execute deferred effects\n        let deferredFn;\n        while(deferredFn = this._deferred.shift()){\n            try {\n                deferredFn();\n            } catch (err) {\n                // this error can only be caught when executing *initial* actions\n                // it's the only time when we call actions provided by the user through those deferreds\n                // when the actor is already running we always execute them synchronously while transitioning\n                // no \"builtin deferred\" should actually throw an error since they are either safe\n                // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n                this._deferred.length = 0;\n                this._snapshot = {\n                    ...snapshot,\n                    status: \"error\",\n                    error: err\n                };\n            }\n        }\n        switch(this._snapshot.status){\n            case \"active\":\n                for (const observer of this.observers){\n                    try {\n                        var _observer_next;\n                        (_observer_next = observer.next) === null || _observer_next === void 0 ? void 0 : _observer_next.call(observer, snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                break;\n            case \"done\":\n                // next observers are meant to be notified about done snapshots\n                // this can be seen as something that is different from how observable work\n                // but with observables `complete` callback is called without any arguments\n                // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n                // and the completion event as something that is separate,\n                // something that merely follows emitting that done snapshot\n                for (const observer of this.observers){\n                    try {\n                        var _observer_next1;\n                        (_observer_next1 = observer.next) === null || _observer_next1 === void 0 ? void 0 : _observer_next1.call(observer, snapshot);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                }\n                this._stopProcedure();\n                this._complete();\n                this._doneEvent = createDoneActorEvent(this.id, this._snapshot.output);\n                if (this._parent) {\n                    this.system._relay(this, this._parent, this._doneEvent);\n                }\n                break;\n            case \"error\":\n                this._error(this._snapshot.error);\n                break;\n        }\n        this.system._sendInspectionEvent({\n            type: \"@xstate.snapshot\",\n            actorRef: this,\n            event,\n            snapshot\n        });\n    }\n    /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */ subscribe(nextListenerOrObserver, errorListener, completeListener) {\n        const observer = toObserver(nextListenerOrObserver, errorListener, completeListener);\n        if (this._processingStatus !== ProcessingStatus.Stopped) {\n            this.observers.add(observer);\n        } else {\n            switch(this._snapshot.status){\n                case \"done\":\n                    try {\n                        var _observer_complete;\n                        (_observer_complete = observer.complete) === null || _observer_complete === void 0 ? void 0 : _observer_complete.call(observer);\n                    } catch (err) {\n                        reportUnhandledError(err);\n                    }\n                    break;\n                case \"error\":\n                    {\n                        const err = this._snapshot.error;\n                        if (!observer.error) {\n                            reportUnhandledError(err);\n                        } else {\n                            try {\n                                observer.error(err);\n                            } catch (err) {\n                                reportUnhandledError(err);\n                            }\n                        }\n                        break;\n                    }\n            }\n        }\n        return {\n            unsubscribe: ()=>{\n                this.observers.delete(observer);\n            }\n        };\n    }\n    on(type, handler) {\n        let listeners = this.eventListeners.get(type);\n        if (!listeners) {\n            listeners = new Set();\n            this.eventListeners.set(type, listeners);\n        }\n        const wrappedHandler = handler.bind(undefined);\n        listeners.add(wrappedHandler);\n        return {\n            unsubscribe: ()=>{\n                listeners.delete(wrappedHandler);\n            }\n        };\n    }\n    /** Starts the Actor from the initial state */ start() {\n        if (this._processingStatus === ProcessingStatus.Running) {\n            // Do not restart the service if it is already started\n            return this;\n        }\n        if (this._syncSnapshot) {\n            this.subscribe({\n                next: (snapshot)=>{\n                    if (snapshot.status === \"active\") {\n                        this.system._relay(this, this._parent, {\n                            type: \"xstate.snapshot.\".concat(this.id),\n                            snapshot\n                        });\n                    }\n                },\n                error: ()=>{}\n            });\n        }\n        this.system._register(this.sessionId, this);\n        if (this._systemId) {\n            this.system._set(this._systemId, this);\n        }\n        this._processingStatus = ProcessingStatus.Running;\n        // TODO: this isn't correct when rehydrating\n        const initEvent = createInitEvent(this.options.input);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.event\",\n            sourceRef: this._parent,\n            actorRef: this,\n            event: initEvent\n        });\n        const status = this._snapshot.status;\n        switch(status){\n            case \"done\":\n                // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n                // we still need to complete observers, flush deferreds etc\n                this.update(this._snapshot, initEvent);\n                // TODO: rethink cleanup of observers, mailbox, etc\n                return this;\n            case \"error\":\n                this._error(this._snapshot.error);\n                return this;\n        }\n        if (!this._parent) {\n            this.system.start();\n        }\n        if (this.logic.start) {\n            try {\n                this.logic.start(this._snapshot, this._actorScope);\n            } catch (err) {\n                this._snapshot = {\n                    ...this._snapshot,\n                    status: \"error\",\n                    error: err\n                };\n                this._error(err);\n                return this;\n            }\n        }\n        // TODO: this notifies all subscribers but usually this is redundant\n        // there is no real change happening here\n        // we need to rethink if this needs to be refactored\n        this.update(this._snapshot, initEvent);\n        if (this.options.devTools) {\n            this.attachDevTools();\n        }\n        this.mailbox.start();\n        return this;\n    }\n    _process(event) {\n        let nextState;\n        let caughtError;\n        try {\n            nextState = this.logic.transition(this._snapshot, event, this._actorScope);\n        } catch (err) {\n            // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n            caughtError = {\n                err\n            };\n        }\n        if (caughtError) {\n            const { err } = caughtError;\n            this._snapshot = {\n                ...this._snapshot,\n                status: \"error\",\n                error: err\n            };\n            this._error(err);\n            return;\n        }\n        this.update(nextState, event);\n        if (event.type === XSTATE_STOP) {\n            this._stopProcedure();\n            this._complete();\n        }\n    }\n    _stop() {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            return this;\n        }\n        this.mailbox.clear();\n        if (this._processingStatus === ProcessingStatus.NotStarted) {\n            this._processingStatus = ProcessingStatus.Stopped;\n            return this;\n        }\n        this.mailbox.enqueue({\n            type: XSTATE_STOP\n        });\n        return this;\n    }\n    /** Stops the Actor and unsubscribe all listeners. */ stop() {\n        if (this._parent) {\n            throw new Error(\"A non-root actor cannot be stopped directly.\");\n        }\n        return this._stop();\n    }\n    _complete() {\n        for (const observer of this.observers){\n            try {\n                var _observer_complete;\n                (_observer_complete = observer.complete) === null || _observer_complete === void 0 ? void 0 : _observer_complete.call(observer);\n            } catch (err) {\n                reportUnhandledError(err);\n            }\n        }\n        this.observers.clear();\n    }\n    _reportError(err) {\n        if (!this.observers.size) {\n            if (!this._parent) {\n                reportUnhandledError(err);\n            }\n            return;\n        }\n        let reportError = false;\n        for (const observer of this.observers){\n            const errorListener = observer.error;\n            reportError || (reportError = !errorListener);\n            try {\n                errorListener === null || errorListener === void 0 ? void 0 : errorListener(err);\n            } catch (err2) {\n                reportUnhandledError(err2);\n            }\n        }\n        this.observers.clear();\n        if (reportError) {\n            reportUnhandledError(err);\n        }\n    }\n    _error(err) {\n        this._stopProcedure();\n        this._reportError(err);\n        if (this._parent) {\n            this.system._relay(this, this._parent, createErrorActorEvent(this.id, err));\n        }\n    }\n    // TODO: atm children don't belong entirely to the actor so\n    // in a way - it's not even super aware of them\n    // so we can't stop them from here but we really should!\n    // right now, they are being stopped within the machine's transition\n    // but that could throw and leave us with \"orphaned\" active actors\n    _stopProcedure() {\n        if (this._processingStatus !== ProcessingStatus.Running) {\n            // Actor already stopped; do nothing\n            return this;\n        }\n        // Cancel all delayed events\n        this.system.scheduler.cancelAll(this);\n        // TODO: mailbox.reset\n        this.mailbox.clear();\n        // TODO: after `stop` we must prepare ourselves for receiving events again\n        // events sent *after* stop signal must be queued\n        // it seems like this should be the common behavior for all of our consumers\n        // so perhaps this should be unified somehow for all of them\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this._processingStatus = ProcessingStatus.Stopped;\n        this.system._unregister(this);\n        return this;\n    }\n    /** @internal */ _send(event) {\n        if (this._processingStatus === ProcessingStatus.Stopped) {\n            // do nothing\n            {\n                const eventString = JSON.stringify(event);\n                console.warn('Event \"'.concat(event.type, '\" was sent to stopped actor \"').concat(this.id, \" (\").concat(this.sessionId, ')\". This actor has already reached its final state, and will not transition.\\nEvent: ').concat(eventString));\n            }\n            return;\n        }\n        this.mailbox.enqueue(event);\n    }\n    /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */ send(event) {\n        if (typeof event === \"string\") {\n            throw new Error('Only event objects may be sent to actors; use .send({ type: \"'.concat(event, '\" }) instead'));\n        }\n        this.system._relay(undefined, this, event);\n    }\n    attachDevTools() {\n        const { devTools } = this.options;\n        if (devTools) {\n            const resolvedDevToolsAdapter = typeof devTools === \"function\" ? devTools : _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.devToolsAdapter;\n            resolvedDevToolsAdapter(this);\n        }\n    }\n    toJSON() {\n        return {\n            xstate$$type: $$ACTOR_TYPE,\n            id: this.id\n        };\n    }\n    /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */ getPersistedSnapshot(options) {\n        return this.logic.getPersistedSnapshot(this._snapshot, options);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n    /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */ getSnapshot() {\n        if (!this._snapshot) {\n            throw new Error(\"Snapshot can't be read while the actor initializes itself\");\n        }\n        return this._snapshot;\n    }\n    /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */ constructor(logic, options){\n        this.logic = logic;\n        /** The current internal state of the actor. */ this._snapshot = void 0;\n        /**\n     * The clock that is responsible for setting and clearing timeouts, such as\n     * delayed events and transitions.\n     */ this.clock = void 0;\n        this.options = void 0;\n        /** The unique identifier for this actor relative to its parent. */ this.id = void 0;\n        this.mailbox = new Mailbox(this._process.bind(this));\n        this.observers = new Set();\n        this.eventListeners = new Map();\n        this.logger = void 0;\n        /** @internal */ this._processingStatus = ProcessingStatus.NotStarted;\n        // Actor Ref\n        this._parent = void 0;\n        /** @internal */ this._syncSnapshot = void 0;\n        this.ref = void 0;\n        // TODO: add typings for system\n        this._actorScope = void 0;\n        this._systemId = void 0;\n        /** The globally unique process ID for this invocation. */ this.sessionId = void 0;\n        /** The system to which this actor belongs. */ this.system = void 0;\n        this._doneEvent = void 0;\n        this.src = void 0;\n        // array of functions to defer\n        this._deferred = [];\n        const resolvedOptions = {\n            ...defaultOptions,\n            ...options\n        };\n        const { clock, logger, parent, syncSnapshot, id, systemId, inspect } = resolvedOptions;\n        this.system = parent ? parent.system : createSystem(this, {\n            clock,\n            logger\n        });\n        if (inspect && !parent) {\n            // Always inspect at the system-level\n            this.system.inspect(toObserver(inspect));\n        }\n        this.sessionId = this.system._bookId();\n        this.id = id !== null && id !== void 0 ? id : this.sessionId;\n        var _options_logger;\n        this.logger = (_options_logger = options === null || options === void 0 ? void 0 : options.logger) !== null && _options_logger !== void 0 ? _options_logger : this.system._logger;\n        var _options_clock;\n        this.clock = (_options_clock = options === null || options === void 0 ? void 0 : options.clock) !== null && _options_clock !== void 0 ? _options_clock : this.system._clock;\n        this._parent = parent;\n        this._syncSnapshot = syncSnapshot;\n        this.options = resolvedOptions;\n        var _resolvedOptions_src;\n        this.src = (_resolvedOptions_src = resolvedOptions.src) !== null && _resolvedOptions_src !== void 0 ? _resolvedOptions_src : logic;\n        this.ref = this;\n        this._actorScope = {\n            self: this,\n            id: this.id,\n            sessionId: this.sessionId,\n            logger: this.logger,\n            defer: (fn)=>{\n                this._deferred.push(fn);\n            },\n            system: this.system,\n            stopChild: (child)=>{\n                if (child._parent !== this) {\n                    throw new Error(\"Cannot stop child actor \".concat(child.id, \" of \").concat(this.id, \" because it is not a child\"));\n                }\n                child._stop();\n            },\n            emit: (emittedEvent)=>{\n                const listeners = this.eventListeners.get(emittedEvent.type);\n                const wildcardListener = this.eventListeners.get(\"*\");\n                if (!listeners && !wildcardListener) {\n                    return;\n                }\n                const allListeners = [\n                    ...listeners ? listeners.values() : [],\n                    ...wildcardListener ? wildcardListener.values() : []\n                ];\n                for (const handler of allListeners){\n                    handler(emittedEvent);\n                }\n            },\n            actionExecutor: (action)=>{\n                const exec = ()=>{\n                    this._actorScope.system._sendInspectionEvent({\n                        type: \"@xstate.action\",\n                        actorRef: this,\n                        action: {\n                            type: action.type,\n                            params: action.params\n                        }\n                    });\n                    if (!action.exec) {\n                        return;\n                    }\n                    const saveExecutingCustomAction = executingCustomAction;\n                    try {\n                        executingCustomAction = true;\n                        action.exec(action.info, action.params);\n                    } finally{\n                        executingCustomAction = saveExecutingCustomAction;\n                    }\n                };\n                if (this._processingStatus === ProcessingStatus.Running) {\n                    exec();\n                } else {\n                    this._deferred.push(exec);\n                }\n            }\n        };\n        // Ensure that the send method is bound to this Actor instance\n        // if destructured\n        this.send = this.send.bind(this);\n        this.system._sendInspectionEvent({\n            type: \"@xstate.actor\",\n            actorRef: this\n        });\n        if (systemId) {\n            this._systemId = systemId;\n            this.system._set(systemId, this);\n        }\n        var _options_snapshot;\n        this._initState((_options_snapshot = options === null || options === void 0 ? void 0 : options.snapshot) !== null && _options_snapshot !== void 0 ? _options_snapshot : options === null || options === void 0 ? void 0 : options.state);\n        if (systemId && this._snapshot.status !== \"active\") {\n            this.system._unregister(this);\n        }\n    }\n}\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */ function createActor(logic) {\n    for(var _len = arguments.length, _tmp = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        _tmp[_key - 1] = arguments[_key];\n    }\n    let [options] = _tmp;\n    return new Actor(logic, options);\n}\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */ const interpret = createActor;\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */ function resolveCancel(_, snapshot, actionArgs, actionParams, param) {\n    let { sendId } = param;\n    const resolvedSendId = typeof sendId === \"function\" ? sendId(actionArgs, actionParams) : sendId;\n    return [\n        snapshot,\n        {\n            sendId: resolvedSendId\n        },\n        undefined\n    ];\n}\nfunction executeCancel(actorScope, params) {\n    actorScope.defer(()=>{\n        actorScope.system.scheduler.cancel(actorScope.self, params.sendId);\n    });\n}\n/**\n * Cancels a delayed `sendTo(...)` action that is waiting to be executed. The\n * canceled `sendTo(...)` action will not send its event or execute, unless the\n * `delay` has already elapsed before `cancel(...)` is called.\n *\n * @example\n *\n * ```ts\n * import { createMachine, sendTo, cancel } from 'xstate';\n *\n * const machine = createMachine({\n *   // ...\n *   on: {\n *     sendEvent: {\n *       actions: sendTo(\n *         'some-actor',\n *         { type: 'someEvent' },\n *         {\n *           id: 'some-id',\n *           delay: 1000\n *         }\n *       )\n *     },\n *     cancelEvent: {\n *       actions: cancel('some-id')\n *     }\n *   }\n * });\n * ```\n *\n * @param sendId The `id` of the `sendTo(...)` action to cancel.\n */ function cancel(sendId) {\n    function cancel(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    cancel.type = \"xstate.cancel\";\n    cancel.sendId = sendId;\n    cancel.resolve = resolveCancel;\n    cancel.execute = executeCancel;\n    return cancel;\n}\nfunction resolveSpawn(actorScope, snapshot, actionArgs, _actionParams, param) {\n    let { id, systemId, src, input, syncSnapshot } = param;\n    const logic = typeof src === \"string\" ? resolveReferencedActor(snapshot.machine, src) : src;\n    const resolvedId = typeof id === \"function\" ? id(actionArgs) : id;\n    let actorRef;\n    let resolvedInput = undefined;\n    if (logic) {\n        resolvedInput = typeof input === \"function\" ? input({\n            context: snapshot.context,\n            event: actionArgs.event,\n            self: actorScope.self\n        }) : input;\n        actorRef = createActor(logic, {\n            id: resolvedId,\n            src,\n            parent: actorScope.self,\n            syncSnapshot,\n            systemId,\n            input: resolvedInput\n        });\n    }\n    if (!actorRef) {\n        console.warn(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-base-to-string\n        \"Actor type '\".concat(src, \"' not found in machine '\").concat(actorScope.id, \"'.\"));\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children: {\n                ...snapshot.children,\n                [resolvedId]: actorRef\n            }\n        }),\n        {\n            id,\n            systemId,\n            actorRef,\n            src,\n            input: resolvedInput\n        },\n        undefined\n    ];\n}\nfunction executeSpawn(actorScope, param) {\n    let { actorRef } = param;\n    if (!actorRef) {\n        return;\n    }\n    actorScope.defer(()=>{\n        if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n            return;\n        }\n        actorRef.start();\n    });\n}\nfunction spawnChild() {\n    for(var _len = arguments.length, _tmp = new Array(_len), _key = 0; _key < _len; _key++){\n        _tmp[_key] = arguments[_key];\n    }\n    let [src, { id, systemId, input, syncSnapshot = false } = {}] = _tmp;\n    function spawnChild(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    spawnChild.type = \"xstate.spawnChild\";\n    spawnChild.id = id;\n    spawnChild.systemId = systemId;\n    spawnChild.src = src;\n    spawnChild.input = input;\n    spawnChild.syncSnapshot = syncSnapshot;\n    spawnChild.resolve = resolveSpawn;\n    spawnChild.execute = executeSpawn;\n    return spawnChild;\n}\nfunction resolveStop(_, snapshot, args, actionParams, param) {\n    let { actorRef } = param;\n    const actorRefOrString = typeof actorRef === \"function\" ? actorRef(args, actionParams) : actorRef;\n    const resolvedActorRef = typeof actorRefOrString === \"string\" ? snapshot.children[actorRefOrString] : actorRefOrString;\n    let children = snapshot.children;\n    if (resolvedActorRef) {\n        children = {\n            ...children\n        };\n        delete children[resolvedActorRef.id];\n    }\n    return [\n        cloneMachineSnapshot(snapshot, {\n            children\n        }),\n        resolvedActorRef,\n        undefined\n    ];\n}\nfunction executeStop(actorScope, actorRef) {\n    if (!actorRef) {\n        return;\n    }\n    // we need to eagerly unregister it here so a new actor with the same systemId can be registered immediately\n    // since we defer actual stopping of the actor but we don't defer actor creations (and we can't do that)\n    // this could throw on `systemId` collision, for example, when dealing with reentering transitions\n    actorScope.system._unregister(actorRef);\n    // this allows us to prevent an actor from being started if it gets stopped within the same macrostep\n    // this can happen, for example, when the invoking state is being exited immediately by an always transition\n    if (actorRef._processingStatus !== ProcessingStatus.Running) {\n        actorScope.stopChild(actorRef);\n        return;\n    }\n    // stopping a child enqueues a stop event in the child actor's mailbox\n    // we need for all of the already enqueued events to be processed before we stop the child\n    // the parent itself might want to send some events to a child (for example from exit actions on the invoking state)\n    // and we don't want to ignore those events\n    actorScope.defer(()=>{\n        actorScope.stopChild(actorRef);\n    });\n}\n/**\n * Stops a child actor.\n *\n * @param actorRef The actor to stop.\n */ function stopChild(actorRef) {\n    function stop(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    stop.type = \"xstate.stopChild\";\n    stop.actorRef = actorRef;\n    stop.resolve = resolveStop;\n    stop.execute = executeStop;\n    return stop;\n}\n/**\n * Stops a child actor.\n *\n * @deprecated Use `stopChild(...)` instead\n * @alias\n */ const stop = stopChild;\nfunction checkStateIn(snapshot, _, param) {\n    let { stateValue } = param;\n    if (typeof stateValue === \"string\" && isStateId(stateValue)) {\n        const target = snapshot.machine.getStateNodeById(stateValue);\n        return snapshot._nodes.some((sn)=>sn === target);\n    }\n    return snapshot.matches(stateValue);\n}\nfunction stateIn(stateValue) {\n    function stateIn() {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    stateIn.check = checkStateIn;\n    stateIn.stateValue = stateValue;\n    return stateIn;\n}\nfunction checkNot(snapshot, param, param1) {\n    let { context, event } = param, { guards } = param1;\n    return !evaluateGuard(guards[0], context, event, snapshot);\n}\n/**\n * Higher-order guard that evaluates to `true` if the `guard` passed to it\n * evaluates to `false`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, not } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => false\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: not('someNamedGuard'),\n *       actions: () => {\n *         // will be executed if guard in `not(...)`\n *         // evaluates to `false`\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard\n */ function not(guard) {\n    function not(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    not.check = checkNot;\n    not.guards = [\n        guard\n    ];\n    return not;\n}\nfunction checkAnd(snapshot, param, param1) {\n    let { context, event } = param, { guards } = param1;\n    return guards.every((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if all `guards` passed to it\n * evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, and } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: and([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if all guards in `and(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function and(guards) {\n    function and(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    and.check = checkAnd;\n    and.guards = guards;\n    return and;\n}\nfunction checkOr(snapshot, param, param1) {\n    let { context, event } = param, { guards } = param1;\n    return guards.some((guard)=>evaluateGuard(guard, context, event, snapshot));\n}\n/**\n * Higher-order guard that evaluates to `true` if any of the `guards` passed to\n * it evaluate to `true`.\n *\n * @category Guards\n * @example\n *\n * ```ts\n * import { setup, or } from 'xstate';\n *\n * const machine = setup({\n *   guards: {\n *     someNamedGuard: () => true\n *   }\n * }).createMachine({\n *   on: {\n *     someEvent: {\n *       guard: or([({ context }) => context.value > 0, 'someNamedGuard']),\n *       actions: () => {\n *         // will be executed if any of the guards in `or(...)`\n *         // evaluate to true\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @returns A guard action object\n */ function or(guards) {\n    function or(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    or.check = checkOr;\n    or.guards = guards;\n    return or;\n}\n// TODO: throw on cycles (depth check should be enough)\nfunction evaluateGuard(guard, context, event, snapshot) {\n    const { machine } = snapshot;\n    const isInline = typeof guard === \"function\";\n    const resolved = isInline ? guard : machine.implementations.guards[typeof guard === \"string\" ? guard : guard.type];\n    if (!isInline && !resolved) {\n        throw new Error(\"Guard '\".concat(typeof guard === \"string\" ? guard : guard.type, \"' is not implemented.'.\"));\n    }\n    if (typeof resolved !== \"function\") {\n        return evaluateGuard(resolved, context, event, snapshot);\n    }\n    const guardArgs = {\n        context,\n        event\n    };\n    const guardParams = isInline || typeof guard === \"string\" ? undefined : \"params\" in guard ? typeof guard.params === \"function\" ? guard.params({\n        context,\n        event\n    }) : guard.params : undefined;\n    if (!(\"check\" in resolved)) {\n        // the existing type of `.guards` assumes non-nullable `TExpressionGuard`\n        // inline guards expect `TExpressionGuard` to be set to `undefined`\n        // it's fine to cast this here, our logic makes sure that we call those 2 \"variants\" correctly\n        return resolved(guardArgs, guardParams);\n    }\n    const builtinGuard = resolved;\n    return builtinGuard.check(snapshot, guardArgs, resolved // this holds all params\n    );\n}\nconst isAtomicStateNode = (stateNode)=>stateNode.type === \"atomic\" || stateNode.type === \"final\";\nfunction getChildren(stateNode) {\n    return Object.values(stateNode.states).filter((sn)=>sn.type !== \"history\");\n}\nfunction getProperAncestors(stateNode, toStateNode) {\n    const ancestors = [];\n    if (toStateNode === stateNode) {\n        return ancestors;\n    }\n    // add all ancestors\n    let m = stateNode.parent;\n    while(m && m !== toStateNode){\n        ancestors.push(m);\n        m = m.parent;\n    }\n    return ancestors;\n}\nfunction getAllStateNodes(stateNodes) {\n    const nodeSet = new Set(stateNodes);\n    const adjList = getAdjList(nodeSet);\n    // add descendants\n    for (const s of nodeSet){\n        // if previously active, add existing child nodes\n        if (s.type === \"compound\" && (!adjList.get(s) || !adjList.get(s).length)) {\n            getInitialStateNodesWithTheirAncestors(s).forEach((sn)=>nodeSet.add(sn));\n        } else {\n            if (s.type === \"parallel\") {\n                for (const child of getChildren(s)){\n                    if (child.type === \"history\") {\n                        continue;\n                    }\n                    if (!nodeSet.has(child)) {\n                        const initialStates = getInitialStateNodesWithTheirAncestors(child);\n                        for (const initialStateNode of initialStates){\n                            nodeSet.add(initialStateNode);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // add all ancestors\n    for (const s of nodeSet){\n        let m = s.parent;\n        while(m){\n            nodeSet.add(m);\n            m = m.parent;\n        }\n    }\n    return nodeSet;\n}\nfunction getValueFromAdj(baseNode, adjList) {\n    const childStateNodes = adjList.get(baseNode);\n    if (!childStateNodes) {\n        return {}; // todo: fix?\n    }\n    if (baseNode.type === \"compound\") {\n        const childStateNode = childStateNodes[0];\n        if (childStateNode) {\n            if (isAtomicStateNode(childStateNode)) {\n                return childStateNode.key;\n            }\n        } else {\n            return {};\n        }\n    }\n    const stateValue = {};\n    for (const childStateNode of childStateNodes){\n        stateValue[childStateNode.key] = getValueFromAdj(childStateNode, adjList);\n    }\n    return stateValue;\n}\nfunction getAdjList(stateNodes) {\n    const adjList = new Map();\n    for (const s of stateNodes){\n        if (!adjList.has(s)) {\n            adjList.set(s, []);\n        }\n        if (s.parent) {\n            if (!adjList.has(s.parent)) {\n                adjList.set(s.parent, []);\n            }\n            adjList.get(s.parent).push(s);\n        }\n    }\n    return adjList;\n}\nfunction getStateValue(rootNode, stateNodes) {\n    const config = getAllStateNodes(stateNodes);\n    return getValueFromAdj(rootNode, getAdjList(config));\n}\nfunction isInFinalState(stateNodeSet, stateNode) {\n    if (stateNode.type === \"compound\") {\n        return getChildren(stateNode).some((s)=>s.type === \"final\" && stateNodeSet.has(s));\n    }\n    if (stateNode.type === \"parallel\") {\n        return getChildren(stateNode).every((sn)=>isInFinalState(stateNodeSet, sn));\n    }\n    return stateNode.type === \"final\";\n}\nconst isStateId = (str)=>str[0] === STATE_IDENTIFIER;\nfunction getCandidates(stateNode, receivedEventType) {\n    const candidates = stateNode.transitions.get(receivedEventType) || [\n        ...stateNode.transitions.keys()\n    ].filter((eventDescriptor)=>{\n        // check if transition is a wildcard transition,\n        // which matches any non-transient events\n        if (eventDescriptor === WILDCARD) {\n            return true;\n        }\n        if (!eventDescriptor.endsWith(\".*\")) {\n            return false;\n        }\n        if (/.*\\*.+/.test(eventDescriptor)) {\n            console.warn('Wildcards can only be the last token of an event descriptor (e.g., \"event.*\") or the entire event descriptor (\"*\"). Check the \"'.concat(eventDescriptor, '\" event.'));\n        }\n        const partialEventTokens = eventDescriptor.split(\".\");\n        const eventTokens = receivedEventType.split(\".\");\n        for(let tokenIndex = 0; tokenIndex < partialEventTokens.length; tokenIndex++){\n            const partialEventToken = partialEventTokens[tokenIndex];\n            const eventToken = eventTokens[tokenIndex];\n            if (partialEventToken === \"*\") {\n                const isLastToken = tokenIndex === partialEventTokens.length - 1;\n                if (!isLastToken) {\n                    console.warn('Infix wildcards in transition events are not allowed. Check the \"'.concat(eventDescriptor, '\" transition.'));\n                }\n                return isLastToken;\n            }\n            if (partialEventToken !== eventToken) {\n                return false;\n            }\n        }\n        return true;\n    }).sort((a, b)=>b.length - a.length).flatMap((key)=>stateNode.transitions.get(key));\n    return candidates;\n}\n/** All delayed transitions from the config. */ function getDelayedTransitions(stateNode) {\n    const afterConfig = stateNode.config.after;\n    if (!afterConfig) {\n        return [];\n    }\n    const mutateEntryExit = (delay)=>{\n        const afterEvent = createAfterEvent(delay, stateNode.id);\n        const eventType = afterEvent.type;\n        stateNode.entry.push(raise(afterEvent, {\n            id: eventType,\n            delay\n        }));\n        stateNode.exit.push(cancel(eventType));\n        return eventType;\n    };\n    const delayedTransitions = Object.keys(afterConfig).flatMap((delay)=>{\n        const configTransition = afterConfig[delay];\n        const resolvedTransition = typeof configTransition === \"string\" ? {\n            target: configTransition\n        } : configTransition;\n        const resolvedDelay = Number.isNaN(+delay) ? delay : +delay;\n        const eventType = mutateEntryExit(resolvedDelay);\n        return toArray(resolvedTransition).map((transition)=>({\n                ...transition,\n                event: eventType,\n                delay: resolvedDelay\n            }));\n    });\n    return delayedTransitions.map((delayedTransition)=>{\n        const { delay } = delayedTransition;\n        return {\n            ...formatTransition(stateNode, delayedTransition.event, delayedTransition),\n            delay\n        };\n    });\n}\nfunction formatTransition(stateNode, descriptor, transitionConfig) {\n    const normalizedTarget = normalizeTarget(transitionConfig.target);\n    var _transitionConfig_reenter;\n    const reenter = (_transitionConfig_reenter = transitionConfig.reenter) !== null && _transitionConfig_reenter !== void 0 ? _transitionConfig_reenter : false;\n    const target = resolveTarget(stateNode, normalizedTarget);\n    // TODO: should this be part of a lint rule instead?\n    if (transitionConfig.cond) {\n        throw new Error('State \"'.concat(stateNode.id, '\" has declared `cond` for one of its transitions. This property has been renamed to `guard`. Please update your code.'));\n    }\n    const transition = {\n        ...transitionConfig,\n        actions: toArray(transitionConfig.actions),\n        guard: transitionConfig.guard,\n        target,\n        source: stateNode,\n        reenter,\n        eventType: descriptor,\n        toJSON: ()=>({\n                ...transition,\n                source: \"#\".concat(stateNode.id),\n                target: target ? target.map((t)=>\"#\".concat(t.id)) : undefined\n            })\n    };\n    return transition;\n}\nfunction formatTransitions(stateNode) {\n    const transitions = new Map();\n    if (stateNode.config.on) {\n        for (const descriptor of Object.keys(stateNode.config.on)){\n            if (descriptor === NULL_EVENT) {\n                throw new Error('Null events (\"\") cannot be specified as a transition key. Use `always: { ... }` instead.');\n            }\n            const transitionsConfig = stateNode.config.on[descriptor];\n            transitions.set(descriptor, toTransitionConfigArray(transitionsConfig).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    if (stateNode.config.onDone) {\n        const descriptor = \"xstate.done.state.\".concat(stateNode.id);\n        transitions.set(descriptor, toTransitionConfigArray(stateNode.config.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n    }\n    for (const invokeDef of stateNode.invoke){\n        if (invokeDef.onDone) {\n            const descriptor = \"xstate.done.actor.\".concat(invokeDef.id);\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onDone).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onError) {\n            const descriptor = \"xstate.error.actor.\".concat(invokeDef.id);\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onError).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n        if (invokeDef.onSnapshot) {\n            const descriptor = \"xstate.snapshot.\".concat(invokeDef.id);\n            transitions.set(descriptor, toTransitionConfigArray(invokeDef.onSnapshot).map((t)=>formatTransition(stateNode, descriptor, t)));\n        }\n    }\n    for (const delayedTransition of stateNode.after){\n        let existing = transitions.get(delayedTransition.eventType);\n        if (!existing) {\n            existing = [];\n            transitions.set(delayedTransition.eventType, existing);\n        }\n        existing.push(delayedTransition);\n    }\n    return transitions;\n}\nfunction formatInitialTransition(stateNode, _target) {\n    const resolvedTarget = typeof _target === \"string\" ? stateNode.states[_target] : _target ? stateNode.states[_target.target] : undefined;\n    if (!resolvedTarget && _target) {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string\n        'Initial state node \"'.concat(_target, '\" not found on parent state node #').concat(stateNode.id));\n    }\n    const transition = {\n        source: stateNode,\n        actions: !_target || typeof _target === \"string\" ? [] : toArray(_target.actions),\n        eventType: null,\n        reenter: false,\n        target: resolvedTarget ? [\n            resolvedTarget\n        ] : [],\n        toJSON: ()=>({\n                ...transition,\n                source: \"#\".concat(stateNode.id),\n                target: resolvedTarget ? [\n                    \"#\".concat(resolvedTarget.id)\n                ] : []\n            })\n    };\n    return transition;\n}\nfunction resolveTarget(stateNode, targets) {\n    if (targets === undefined) {\n        // an undefined target signals that the state node should not transition from that state when receiving that event\n        return undefined;\n    }\n    return targets.map((target)=>{\n        if (typeof target !== \"string\") {\n            return target;\n        }\n        if (isStateId(target)) {\n            return stateNode.machine.getStateNodeById(target);\n        }\n        const isInternalTarget = target[0] === STATE_DELIMITER;\n        // If internal target is defined on machine,\n        // do not include machine key on target\n        if (isInternalTarget && !stateNode.parent) {\n            return getStateNodeByPath(stateNode, target.slice(1));\n        }\n        const resolvedTarget = isInternalTarget ? stateNode.key + target : target;\n        if (stateNode.parent) {\n            try {\n                const targetStateNode = getStateNodeByPath(stateNode.parent, resolvedTarget);\n                return targetStateNode;\n            } catch (err) {\n                throw new Error(\"Invalid transition definition for state node '\".concat(stateNode.id, \"':\\n\").concat(err.message));\n            }\n        } else {\n            throw new Error('Invalid target: \"'.concat(target, '\" is not a valid target from the root node. Did you mean \".').concat(target, '\"?'));\n        }\n    });\n}\nfunction resolveHistoryDefaultTransition(stateNode) {\n    const normalizedTarget = normalizeTarget(stateNode.config.target);\n    if (!normalizedTarget) {\n        return stateNode.parent.initial;\n    }\n    return {\n        target: normalizedTarget.map((t)=>typeof t === \"string\" ? getStateNodeByPath(stateNode.parent, t) : t)\n    };\n}\nfunction isHistoryNode(stateNode) {\n    return stateNode.type === \"history\";\n}\nfunction getInitialStateNodesWithTheirAncestors(stateNode) {\n    const states = getInitialStateNodes(stateNode);\n    for (const initialState of states){\n        for (const ancestor of getProperAncestors(initialState, stateNode)){\n            states.add(ancestor);\n        }\n    }\n    return states;\n}\nfunction getInitialStateNodes(stateNode) {\n    const set = new Set();\n    function iter(descStateNode) {\n        if (set.has(descStateNode)) {\n            return;\n        }\n        set.add(descStateNode);\n        if (descStateNode.type === \"compound\") {\n            iter(descStateNode.initial.target[0]);\n        } else if (descStateNode.type === \"parallel\") {\n            for (const child of getChildren(descStateNode)){\n                iter(child);\n            }\n        }\n    }\n    iter(stateNode);\n    return set;\n}\n/** Returns the child state node from its relative `stateKey`, or throws. */ function getStateNode(stateNode, stateKey) {\n    if (isStateId(stateKey)) {\n        return stateNode.machine.getStateNodeById(stateKey);\n    }\n    if (!stateNode.states) {\n        throw new Error(\"Unable to retrieve child state '\".concat(stateKey, \"' from '\").concat(stateNode.id, \"'; no child states exist.\"));\n    }\n    const result = stateNode.states[stateKey];\n    if (!result) {\n        throw new Error(\"Child state '\".concat(stateKey, \"' does not exist on '\").concat(stateNode.id, \"'\"));\n    }\n    return result;\n}\n/**\n * Returns the relative state node from the given `statePath`, or throws.\n *\n * @param statePath The string or string array relative path to the state node.\n */ function getStateNodeByPath(stateNode, statePath) {\n    if (typeof statePath === \"string\" && isStateId(statePath)) {\n        try {\n            return stateNode.machine.getStateNodeById(statePath);\n        } catch (e) {\n        // try individual paths\n        // throw e;\n        }\n    }\n    const arrayStatePath = toStatePath(statePath).slice();\n    let currentStateNode = stateNode;\n    while(arrayStatePath.length){\n        const key = arrayStatePath.shift();\n        if (!key.length) {\n            break;\n        }\n        currentStateNode = getStateNode(currentStateNode, key);\n    }\n    return currentStateNode;\n}\n/**\n * Returns the state nodes represented by the current state value.\n *\n * @param stateValue The state value or State instance\n */ function getStateNodes(stateNode, stateValue) {\n    if (typeof stateValue === \"string\") {\n        const childStateNode = stateNode.states[stateValue];\n        if (!childStateNode) {\n            throw new Error(\"State '\".concat(stateValue, \"' does not exist on '\").concat(stateNode.id, \"'\"));\n        }\n        return [\n            stateNode,\n            childStateNode\n        ];\n    }\n    const childStateKeys = Object.keys(stateValue);\n    const childStateNodes = childStateKeys.map((subStateKey)=>getStateNode(stateNode, subStateKey)).filter(Boolean);\n    return [\n        stateNode.machine.root,\n        stateNode\n    ].concat(childStateNodes, childStateKeys.reduce((allSubStateNodes, subStateKey)=>{\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        if (!subStateNode) {\n            return allSubStateNodes;\n        }\n        const subStateNodes = getStateNodes(subStateNode, stateValue[subStateKey]);\n        return allSubStateNodes.concat(subStateNodes);\n    }, []));\n}\nfunction transitionAtomicNode(stateNode, stateValue, snapshot, event) {\n    const childStateNode = getStateNode(stateNode, stateValue);\n    const next = childStateNode.next(snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionCompoundNode(stateNode, stateValue, snapshot, event) {\n    const subStateKeys = Object.keys(stateValue);\n    const childStateNode = getStateNode(stateNode, subStateKeys[0]);\n    const next = transitionNode(childStateNode, stateValue[subStateKeys[0]], snapshot, event);\n    if (!next || !next.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return next;\n}\nfunction transitionParallelNode(stateNode, stateValue, snapshot, event) {\n    const allInnerTransitions = [];\n    for (const subStateKey of Object.keys(stateValue)){\n        const subStateValue = stateValue[subStateKey];\n        if (!subStateValue) {\n            continue;\n        }\n        const subStateNode = getStateNode(stateNode, subStateKey);\n        const innerTransitions = transitionNode(subStateNode, subStateValue, snapshot, event);\n        if (innerTransitions) {\n            allInnerTransitions.push(...innerTransitions);\n        }\n    }\n    if (!allInnerTransitions.length) {\n        return stateNode.next(snapshot, event);\n    }\n    return allInnerTransitions;\n}\nfunction transitionNode(stateNode, stateValue, snapshot, event) {\n    // leaf node\n    if (typeof stateValue === \"string\") {\n        return transitionAtomicNode(stateNode, stateValue, snapshot, event);\n    }\n    // compound node\n    if (Object.keys(stateValue).length === 1) {\n        return transitionCompoundNode(stateNode, stateValue, snapshot, event);\n    }\n    // parallel node\n    return transitionParallelNode(stateNode, stateValue, snapshot, event);\n}\nfunction getHistoryNodes(stateNode) {\n    return Object.keys(stateNode.states).map((key)=>stateNode.states[key]).filter((sn)=>sn.type === \"history\");\n}\nfunction isDescendant(childStateNode, parentStateNode) {\n    let marker = childStateNode;\n    while(marker.parent && marker.parent !== parentStateNode){\n        marker = marker.parent;\n    }\n    return marker.parent === parentStateNode;\n}\nfunction hasIntersection(s1, s2) {\n    const set1 = new Set(s1);\n    const set2 = new Set(s2);\n    for (const item of set1){\n        if (set2.has(item)) {\n            return true;\n        }\n    }\n    for (const item of set2){\n        if (set1.has(item)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction removeConflictingTransitions(enabledTransitions, stateNodeSet, historyValue) {\n    const filteredTransitions = new Set();\n    for (const t1 of enabledTransitions){\n        let t1Preempted = false;\n        const transitionsToRemove = new Set();\n        for (const t2 of filteredTransitions){\n            if (hasIntersection(computeExitSet([\n                t1\n            ], stateNodeSet, historyValue), computeExitSet([\n                t2\n            ], stateNodeSet, historyValue))) {\n                if (isDescendant(t1.source, t2.source)) {\n                    transitionsToRemove.add(t2);\n                } else {\n                    t1Preempted = true;\n                    break;\n                }\n            }\n        }\n        if (!t1Preempted) {\n            for (const t3 of transitionsToRemove){\n                filteredTransitions.delete(t3);\n            }\n            filteredTransitions.add(t1);\n        }\n    }\n    return Array.from(filteredTransitions);\n}\nfunction findLeastCommonAncestor(stateNodes) {\n    const [head, ...tail] = stateNodes;\n    for (const ancestor of getProperAncestors(head, undefined)){\n        if (tail.every((sn)=>isDescendant(sn, ancestor))) {\n            return ancestor;\n        }\n    }\n}\nfunction getEffectiveTargetStates(transition, historyValue) {\n    if (!transition.target) {\n        return [];\n    }\n    const targets = new Set();\n    for (const targetNode of transition.target){\n        if (isHistoryNode(targetNode)) {\n            if (historyValue[targetNode.id]) {\n                for (const node of historyValue[targetNode.id]){\n                    targets.add(node);\n                }\n            } else {\n                for (const node of getEffectiveTargetStates(resolveHistoryDefaultTransition(targetNode), historyValue)){\n                    targets.add(node);\n                }\n            }\n        } else {\n            targets.add(targetNode);\n        }\n    }\n    return [\n        ...targets\n    ];\n}\nfunction getTransitionDomain(transition, historyValue) {\n    const targetStates = getEffectiveTargetStates(transition, historyValue);\n    if (!targetStates) {\n        return;\n    }\n    if (!transition.reenter && targetStates.every((target)=>target === transition.source || isDescendant(target, transition.source))) {\n        return transition.source;\n    }\n    const lca = findLeastCommonAncestor(targetStates.concat(transition.source));\n    if (lca) {\n        return lca;\n    }\n    // at this point we know that it's a root transition since LCA couldn't be found\n    if (transition.reenter) {\n        return;\n    }\n    return transition.source.machine.root;\n}\nfunction computeExitSet(transitions, stateNodeSet, historyValue) {\n    const statesToExit = new Set();\n    for (const t of transitions){\n        var _t_target;\n        if ((_t_target = t.target) === null || _t_target === void 0 ? void 0 : _t_target.length) {\n            const domain = getTransitionDomain(t, historyValue);\n            if (t.reenter && t.source === domain) {\n                statesToExit.add(domain);\n            }\n            for (const stateNode of stateNodeSet){\n                if (isDescendant(stateNode, domain)) {\n                    statesToExit.add(stateNode);\n                }\n            }\n        }\n    }\n    return [\n        ...statesToExit\n    ];\n}\nfunction areStateNodeCollectionsEqual(prevStateNodes, nextStateNodeSet) {\n    if (prevStateNodes.length !== nextStateNodeSet.size) {\n        return false;\n    }\n    for (const node of prevStateNodes){\n        if (!nextStateNodeSet.has(node)) {\n            return false;\n        }\n    }\n    return true;\n}\n/** https://www.w3.org/TR/scxml/#microstepProcedure */ function microstep(transitions, currentSnapshot, actorScope, event, isInitial, internalQueue) {\n    if (!transitions.length) {\n        return currentSnapshot;\n    }\n    const mutStateNodeSet = new Set(currentSnapshot._nodes);\n    let historyValue = currentSnapshot.historyValue;\n    const filteredTransitions = removeConflictingTransitions(transitions, mutStateNodeSet, historyValue);\n    let nextState = currentSnapshot;\n    // Exit states\n    if (!isInitial) {\n        [nextState, historyValue] = exitStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, historyValue, internalQueue, actorScope.actionExecutor);\n    }\n    // Execute transition content\n    nextState = resolveActionsAndContext(nextState, event, actorScope, filteredTransitions.flatMap((t)=>t.actions), internalQueue, undefined);\n    // Enter states\n    nextState = enterStates(nextState, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial);\n    const nextStateNodes = [\n        ...mutStateNodeSet\n    ];\n    if (nextState.status === \"done\") {\n        nextState = resolveActionsAndContext(nextState, event, actorScope, nextStateNodes.sort((a, b)=>b.order - a.order).flatMap((state)=>state.exit), internalQueue, undefined);\n    }\n    // eslint-disable-next-line no-useless-catch\n    try {\n        if (historyValue === currentSnapshot.historyValue && areStateNodeCollectionsEqual(currentSnapshot._nodes, mutStateNodeSet)) {\n            return nextState;\n        }\n        return cloneMachineSnapshot(nextState, {\n            _nodes: nextStateNodes,\n            historyValue\n        });\n    } catch (e) {\n        // TODO: Refactor this once proper error handling is implemented.\n        // See https://github.com/statelyai/rfcs/pull/4\n        throw e;\n    }\n}\nfunction getMachineOutput(snapshot, event, actorScope, rootNode, rootCompletionNode) {\n    if (rootNode.output === undefined) {\n        return;\n    }\n    const doneStateEvent = createDoneStateEvent(rootCompletionNode.id, rootCompletionNode.output !== undefined && rootCompletionNode.parent ? resolveOutput(rootCompletionNode.output, snapshot.context, event, actorScope.self) : undefined);\n    return resolveOutput(rootNode.output, snapshot.context, doneStateEvent, actorScope.self);\n}\nfunction enterStates(currentSnapshot, event, actorScope, filteredTransitions, mutStateNodeSet, internalQueue, historyValue, isInitial) {\n    let nextSnapshot = currentSnapshot;\n    const statesToEnter = new Set();\n    // those are states that were directly targeted or indirectly targeted by the explicit target\n    // in other words, those are states for which initial actions should be executed\n    // when we target `#deep_child` initial actions of its ancestors shouldn't be executed\n    const statesForDefaultEntry = new Set();\n    computeEntrySet(filteredTransitions, historyValue, statesForDefaultEntry, statesToEnter);\n    // In the initial state, the root state node is \"entered\".\n    if (isInitial) {\n        statesForDefaultEntry.add(currentSnapshot.machine.root);\n    }\n    const completedNodes = new Set();\n    for (const stateNodeToEnter of [\n        ...statesToEnter\n    ].sort((a, b)=>a.order - b.order)){\n        mutStateNodeSet.add(stateNodeToEnter);\n        const actions = [];\n        // Add entry actions\n        actions.push(...stateNodeToEnter.entry);\n        for (const invokeDef of stateNodeToEnter.invoke){\n            actions.push(spawnChild(invokeDef.src, {\n                ...invokeDef,\n                syncSnapshot: !!invokeDef.onSnapshot\n            }));\n        }\n        if (statesForDefaultEntry.has(stateNodeToEnter)) {\n            const initialActions = stateNodeToEnter.initial.actions;\n            actions.push(...initialActions);\n        }\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, actions, internalQueue, stateNodeToEnter.invoke.map((invokeDef)=>invokeDef.id));\n        if (stateNodeToEnter.type === \"final\") {\n            const parent = stateNodeToEnter.parent;\n            let ancestorMarker = (parent === null || parent === void 0 ? void 0 : parent.type) === \"parallel\" ? parent : parent === null || parent === void 0 ? void 0 : parent.parent;\n            let rootCompletionNode = ancestorMarker || stateNodeToEnter;\n            if ((parent === null || parent === void 0 ? void 0 : parent.type) === \"compound\") {\n                internalQueue.push(createDoneStateEvent(parent.id, stateNodeToEnter.output !== undefined ? resolveOutput(stateNodeToEnter.output, nextSnapshot.context, event, actorScope.self) : undefined));\n            }\n            while((ancestorMarker === null || ancestorMarker === void 0 ? void 0 : ancestorMarker.type) === \"parallel\" && !completedNodes.has(ancestorMarker) && isInFinalState(mutStateNodeSet, ancestorMarker)){\n                completedNodes.add(ancestorMarker);\n                internalQueue.push(createDoneStateEvent(ancestorMarker.id));\n                rootCompletionNode = ancestorMarker;\n                ancestorMarker = ancestorMarker.parent;\n            }\n            if (ancestorMarker) {\n                continue;\n            }\n            nextSnapshot = cloneMachineSnapshot(nextSnapshot, {\n                status: \"done\",\n                output: getMachineOutput(nextSnapshot, event, actorScope, nextSnapshot.machine.root, rootCompletionNode)\n            });\n        }\n    }\n    return nextSnapshot;\n}\nfunction computeEntrySet(transitions, historyValue, statesForDefaultEntry, statesToEnter) {\n    for (const t of transitions){\n        const domain = getTransitionDomain(t, historyValue);\n        for (const s of t.target || []){\n            if (!isHistoryNode(s) && // if the target is different than the source then it will *definitely* be entered\n            (t.source !== s || // we know that the domain can't lie within the source\n            // if it's different than the source then it's outside of it and it means that the target has to be entered as well\n            t.source !== domain || // reentering transitions always enter the target, even if it's the source itself\n            t.reenter)) {\n                statesToEnter.add(s);\n                statesForDefaultEntry.add(s);\n            }\n            addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n        }\n        const targetStates = getEffectiveTargetStates(t, historyValue);\n        for (const s of targetStates){\n            const ancestors = getProperAncestors(s, domain);\n            if ((domain === null || domain === void 0 ? void 0 : domain.type) === \"parallel\") {\n                ancestors.push(domain);\n            }\n            addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, !t.source.parent && t.reenter ? undefined : domain);\n        }\n    }\n}\nfunction addDescendantStatesToEnter(stateNode, historyValue, statesForDefaultEntry, statesToEnter) {\n    if (isHistoryNode(stateNode)) {\n        if (historyValue[stateNode.id]) {\n            const historyStateNodes = historyValue[stateNode.id];\n            for (const s of historyStateNodes){\n                statesToEnter.add(s);\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyStateNodes){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        } else {\n            const historyDefaultTransition = resolveHistoryDefaultTransition(stateNode);\n            for (const s of historyDefaultTransition.target){\n                var _stateNode_parent;\n                statesToEnter.add(s);\n                if (historyDefaultTransition === ((_stateNode_parent = stateNode.parent) === null || _stateNode_parent === void 0 ? void 0 : _stateNode_parent.initial)) {\n                    statesForDefaultEntry.add(stateNode.parent);\n                }\n                addDescendantStatesToEnter(s, historyValue, statesForDefaultEntry, statesToEnter);\n            }\n            for (const s of historyDefaultTransition.target){\n                addProperAncestorStatesToEnter(s, stateNode.parent, statesToEnter, historyValue, statesForDefaultEntry);\n            }\n        }\n    } else {\n        if (stateNode.type === \"compound\") {\n            const [initialState] = stateNode.initial.target;\n            if (!isHistoryNode(initialState)) {\n                statesToEnter.add(initialState);\n                statesForDefaultEntry.add(initialState);\n            }\n            addDescendantStatesToEnter(initialState, historyValue, statesForDefaultEntry, statesToEnter);\n            addProperAncestorStatesToEnter(initialState, stateNode, statesToEnter, historyValue, statesForDefaultEntry);\n        } else {\n            if (stateNode.type === \"parallel\") {\n                for (const child of getChildren(stateNode).filter((sn)=>!isHistoryNode(sn))){\n                    if (![\n                        ...statesToEnter\n                    ].some((s)=>isDescendant(s, child))) {\n                        if (!isHistoryNode(child)) {\n                            statesToEnter.add(child);\n                            statesForDefaultEntry.add(child);\n                        }\n                        addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                    }\n                }\n            }\n        }\n    }\n}\nfunction addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, ancestors, reentrancyDomain) {\n    for (const anc of ancestors){\n        if (!reentrancyDomain || isDescendant(anc, reentrancyDomain)) {\n            statesToEnter.add(anc);\n        }\n        if (anc.type === \"parallel\") {\n            for (const child of getChildren(anc).filter((sn)=>!isHistoryNode(sn))){\n                if (![\n                    ...statesToEnter\n                ].some((s)=>isDescendant(s, child))) {\n                    statesToEnter.add(child);\n                    addDescendantStatesToEnter(child, historyValue, statesForDefaultEntry, statesToEnter);\n                }\n            }\n        }\n    }\n}\nfunction addProperAncestorStatesToEnter(stateNode, toStateNode, statesToEnter, historyValue, statesForDefaultEntry) {\n    addAncestorStatesToEnter(statesToEnter, historyValue, statesForDefaultEntry, getProperAncestors(stateNode, toStateNode));\n}\nfunction exitStates(currentSnapshot, event, actorScope, transitions, mutStateNodeSet, historyValue, internalQueue, _actionExecutor) {\n    let nextSnapshot = currentSnapshot;\n    const statesToExit = computeExitSet(transitions, mutStateNodeSet, historyValue);\n    statesToExit.sort((a, b)=>b.order - a.order);\n    let changedHistory;\n    // From SCXML algorithm: https://www.w3.org/TR/scxml/#exitStates\n    for (const exitStateNode of statesToExit){\n        for (const historyNode of getHistoryNodes(exitStateNode)){\n            let predicate;\n            if (historyNode.history === \"deep\") {\n                predicate = (sn)=>isAtomicStateNode(sn) && isDescendant(sn, exitStateNode);\n            } else {\n                predicate = (sn)=>{\n                    return sn.parent === exitStateNode;\n                };\n            }\n            changedHistory !== null && changedHistory !== void 0 ? changedHistory : changedHistory = {\n                ...historyValue\n            };\n            changedHistory[historyNode.id] = Array.from(mutStateNodeSet).filter(predicate);\n        }\n    }\n    for (const s of statesToExit){\n        nextSnapshot = resolveActionsAndContext(nextSnapshot, event, actorScope, [\n            ...s.exit,\n            ...s.invoke.map((def)=>stopChild(def.id))\n        ], internalQueue, undefined);\n        mutStateNodeSet.delete(s);\n    }\n    return [\n        nextSnapshot,\n        changedHistory || historyValue\n    ];\n}\nfunction getAction(machine, actionType) {\n    return machine.implementations.actions[actionType];\n}\nfunction resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, extra, retries) {\n    const { machine } = currentSnapshot;\n    let intermediateSnapshot = currentSnapshot;\n    for (const action of actions){\n        const isInline = typeof action === \"function\";\n        const resolvedAction = isInline ? action : // the existing type of `.actions` assumes non-nullable `TExpressionAction`\n        // it's fine to cast this here to get a common type and lack of errors in the rest of the code\n        // our logic below makes sure that we call those 2 \"variants\" correctly\n        getAction(machine, typeof action === \"string\" ? action : action.type);\n        const actionArgs = {\n            context: intermediateSnapshot.context,\n            event,\n            self: actorScope.self,\n            system: actorScope.system\n        };\n        const actionParams = isInline || typeof action === \"string\" ? undefined : \"params\" in action ? typeof action.params === \"function\" ? action.params({\n            context: intermediateSnapshot.context,\n            event\n        }) : action.params : undefined;\n        if (!resolvedAction || !(\"resolve\" in resolvedAction)) {\n            actorScope.actionExecutor({\n                type: typeof action === \"string\" ? action : typeof action === \"object\" ? action.type : action.name || \"(anonymous)\",\n                info: actionArgs,\n                params: actionParams,\n                exec: resolvedAction\n            });\n            continue;\n        }\n        const builtinAction = resolvedAction;\n        const [nextState, params, actions] = builtinAction.resolve(actorScope, intermediateSnapshot, actionArgs, actionParams, resolvedAction, // this holds all params\n        extra);\n        intermediateSnapshot = nextState;\n        if (\"retryResolve\" in builtinAction) {\n            retries === null || retries === void 0 ? void 0 : retries.push([\n                builtinAction,\n                params\n            ]);\n        }\n        if (\"execute\" in builtinAction) {\n            actorScope.actionExecutor({\n                type: builtinAction.type,\n                info: actionArgs,\n                params,\n                exec: builtinAction.execute.bind(null, actorScope, params)\n            });\n        }\n        if (actions) {\n            intermediateSnapshot = resolveAndExecuteActionsWithContext(intermediateSnapshot, event, actorScope, actions, extra, retries);\n        }\n    }\n    return intermediateSnapshot;\n}\nfunction resolveActionsAndContext(currentSnapshot, event, actorScope, actions, internalQueue, deferredActorIds) {\n    const retries = deferredActorIds ? [] : undefined;\n    const nextState = resolveAndExecuteActionsWithContext(currentSnapshot, event, actorScope, actions, {\n        internalQueue,\n        deferredActorIds\n    }, retries);\n    retries === null || retries === void 0 ? void 0 : retries.forEach((param)=>{\n        let [builtinAction, params] = param;\n        builtinAction.retryResolve(actorScope, nextState, params);\n    });\n    return nextState;\n}\nfunction macrostep(snapshot, event, actorScope, internalQueue) {\n    if (event.type === WILDCARD) {\n        throw new Error(\"An event cannot have the wildcard type ('\".concat(WILDCARD, \"')\"));\n    }\n    let nextSnapshot = snapshot;\n    const microstates = [];\n    function addMicrostate(microstate, event, transitions) {\n        actorScope.system._sendInspectionEvent({\n            type: \"@xstate.microstep\",\n            actorRef: actorScope.self,\n            event,\n            snapshot: microstate,\n            _transitions: transitions\n        });\n        microstates.push(microstate);\n    }\n    // Handle stop event\n    if (event.type === XSTATE_STOP) {\n        nextSnapshot = cloneMachineSnapshot(stopChildren(nextSnapshot, event, actorScope), {\n            status: \"stopped\"\n        });\n        addMicrostate(nextSnapshot, event, []);\n        return {\n            snapshot: nextSnapshot,\n            microstates\n        };\n    }\n    let nextEvent = event;\n    // Assume the state is at rest (no raised events)\n    // Determine the next state based on the next microstep\n    if (nextEvent.type !== XSTATE_INIT) {\n        const currentEvent = nextEvent;\n        const isErr = isErrorActorEvent(currentEvent);\n        const transitions = selectTransitions(currentEvent, nextSnapshot);\n        if (isErr && !transitions.length) {\n            // TODO: we should likely only allow transitions selected by very explicit descriptors\n            // `*` shouldn't be matched, likely `xstate.error.*` shouldnt be either\n            // similarly `xstate.error.actor.*` and `xstate.error.actor.todo.*` have to be considered too\n            nextSnapshot = cloneMachineSnapshot(snapshot, {\n                status: \"error\",\n                error: currentEvent.error\n            });\n            addMicrostate(nextSnapshot, currentEvent, []);\n            return {\n                snapshot: nextSnapshot,\n                microstates\n            };\n        }\n        nextSnapshot = microstep(transitions, snapshot, actorScope, nextEvent, false, // isInitial\n        internalQueue);\n        addMicrostate(nextSnapshot, currentEvent, transitions);\n    }\n    let shouldSelectEventlessTransitions = true;\n    while(nextSnapshot.status === \"active\"){\n        let enabledTransitions = shouldSelectEventlessTransitions ? selectEventlessTransitions(nextSnapshot, nextEvent) : [];\n        // eventless transitions should always be selected after selecting *regular* transitions\n        // by assigning `undefined` to `previousState` we ensure that `shouldSelectEventlessTransitions` gets always computed to true in such a case\n        const previousState = enabledTransitions.length ? nextSnapshot : undefined;\n        if (!enabledTransitions.length) {\n            if (!internalQueue.length) {\n                break;\n            }\n            nextEvent = internalQueue.shift();\n            enabledTransitions = selectTransitions(nextEvent, nextSnapshot);\n        }\n        nextSnapshot = microstep(enabledTransitions, nextSnapshot, actorScope, nextEvent, false, internalQueue);\n        shouldSelectEventlessTransitions = nextSnapshot !== previousState;\n        addMicrostate(nextSnapshot, nextEvent, enabledTransitions);\n    }\n    if (nextSnapshot.status !== \"active\") {\n        stopChildren(nextSnapshot, nextEvent, actorScope);\n    }\n    return {\n        snapshot: nextSnapshot,\n        microstates\n    };\n}\nfunction stopChildren(nextState, event, actorScope) {\n    return resolveActionsAndContext(nextState, event, actorScope, Object.values(nextState.children).map((child)=>stopChild(child)), [], undefined);\n}\nfunction selectTransitions(event, nextState) {\n    return nextState.machine.getTransitionData(nextState, event);\n}\nfunction selectEventlessTransitions(nextState, event) {\n    const enabledTransitionSet = new Set();\n    const atomicStates = nextState._nodes.filter(isAtomicStateNode);\n    for (const stateNode of atomicStates){\n        loop: for (const s of [\n            stateNode\n        ].concat(getProperAncestors(stateNode, undefined))){\n            if (!s.always) {\n                continue;\n            }\n            for (const transition of s.always){\n                if (transition.guard === undefined || evaluateGuard(transition.guard, nextState.context, event, nextState)) {\n                    enabledTransitionSet.add(transition);\n                    break loop;\n                }\n            }\n        }\n    }\n    return removeConflictingTransitions(Array.from(enabledTransitionSet), new Set(nextState._nodes), nextState.historyValue);\n}\n/**\n * Resolves a partial state value with its full representation in the state\n * node's machine.\n *\n * @param stateValue The partial state value to resolve.\n */ function resolveStateValue(rootNode, stateValue) {\n    const allStateNodes = getAllStateNodes(getStateNodes(rootNode, stateValue));\n    return getStateValue(rootNode, [\n        ...allStateNodes\n    ]);\n}\nfunction isMachineSnapshot(value) {\n    return !!value && typeof value === \"object\" && \"machine\" in value && \"value\" in value;\n}\nconst machineSnapshotMatches = function matches(testValue) {\n    return matchesState(testValue, this.value);\n};\nconst machineSnapshotHasTag = function hasTag(tag) {\n    return this.tags.has(tag);\n};\nconst machineSnapshotCan = function can(event) {\n    if (!this.machine) {\n        console.warn(\"state.can(...) used outside of a machine-created State object; this will always return false.\");\n    }\n    const transitionData = this.machine.getTransitionData(this, event);\n    return !!(transitionData === null || transitionData === void 0 ? void 0 : transitionData.length) && // Check that at least one transition is not forbidden\n    transitionData.some((t)=>t.target !== undefined || t.actions.length);\n};\nconst machineSnapshotToJSON = function toJSON() {\n    const { _nodes: nodes, tags, machine, getMeta, toJSON, can, hasTag, matches, ...jsonValues } = this;\n    return {\n        ...jsonValues,\n        tags: Array.from(tags)\n    };\n};\nconst machineSnapshotGetMeta = function getMeta() {\n    return this._nodes.reduce((acc, stateNode)=>{\n        if (stateNode.meta !== undefined) {\n            acc[stateNode.id] = stateNode.meta;\n        }\n        return acc;\n    }, {});\n};\nfunction createMachineSnapshot(config, machine) {\n    return {\n        status: config.status,\n        output: config.output,\n        error: config.error,\n        machine,\n        context: config.context,\n        _nodes: config._nodes,\n        value: getStateValue(machine.root, config._nodes),\n        tags: new Set(config._nodes.flatMap((sn)=>sn.tags)),\n        children: config.children,\n        historyValue: config.historyValue || {},\n        matches: machineSnapshotMatches,\n        hasTag: machineSnapshotHasTag,\n        can: machineSnapshotCan,\n        getMeta: machineSnapshotGetMeta,\n        toJSON: machineSnapshotToJSON\n    };\n}\nfunction cloneMachineSnapshot(snapshot) {\n    let config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return createMachineSnapshot({\n        ...snapshot,\n        ...config\n    }, snapshot.machine);\n}\nfunction getPersistedSnapshot(snapshot, options) {\n    const { _nodes: nodes, tags, machine, children, context, can, hasTag, matches, getMeta, toJSON, ...jsonValues } = snapshot;\n    const childrenJson = {};\n    for(const id in children){\n        const child = children[id];\n        if (typeof child.src !== \"string\" && (!options || !(\"__unsafeAllowInlineActors\" in options))) {\n            throw new Error(\"An inline child actor cannot be persisted.\");\n        }\n        childrenJson[id] = {\n            snapshot: child.getPersistedSnapshot(options),\n            src: child.src,\n            systemId: child._systemId,\n            syncSnapshot: child._syncSnapshot\n        };\n    }\n    const persisted = {\n        ...jsonValues,\n        context: persistContext(context),\n        children: childrenJson\n    };\n    return persisted;\n}\nfunction persistContext(contextPart) {\n    let copy;\n    for(const key in contextPart){\n        const value = contextPart[key];\n        if (value && typeof value === \"object\") {\n            if (\"sessionId\" in value && \"send\" in value && \"ref\" in value) {\n                copy !== null && copy !== void 0 ? copy : copy = Array.isArray(contextPart) ? contextPart.slice() : {\n                    ...contextPart\n                };\n                copy[key] = {\n                    xstate$$type: $$ACTOR_TYPE,\n                    id: value.id\n                };\n            } else {\n                const result = persistContext(value);\n                if (result !== value) {\n                    copy !== null && copy !== void 0 ? copy : copy = Array.isArray(contextPart) ? contextPart.slice() : {\n                        ...contextPart\n                    };\n                    copy[key] = result;\n                }\n            }\n        }\n    }\n    return copy !== null && copy !== void 0 ? copy : contextPart;\n}\nfunction resolveRaise(_, snapshot, args, actionParams, param, param1) {\n    let { event: eventOrExpr, id, delay } = param, { internalQueue } = param1;\n    const delaysMap = snapshot.machine.implementations.delays;\n    if (typeof eventOrExpr === \"string\") {\n        throw new Error(// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        'Only event objects may be used with raise; use raise({ type: \"'.concat(eventOrExpr, '\" }) instead'));\n    }\n    const resolvedEvent = typeof eventOrExpr === \"function\" ? eventOrExpr(args, actionParams) : eventOrExpr;\n    let resolvedDelay;\n    if (typeof delay === \"string\") {\n        const configDelay = delaysMap && delaysMap[delay];\n        resolvedDelay = typeof configDelay === \"function\" ? configDelay(args, actionParams) : configDelay;\n    } else {\n        resolvedDelay = typeof delay === \"function\" ? delay(args, actionParams) : delay;\n    }\n    if (typeof resolvedDelay !== \"number\") {\n        internalQueue.push(resolvedEvent);\n    }\n    return [\n        snapshot,\n        {\n            event: resolvedEvent,\n            id,\n            delay: resolvedDelay\n        },\n        undefined\n    ];\n}\nfunction executeRaise(actorScope, params) {\n    const { event, delay, id } = params;\n    if (typeof delay === \"number\") {\n        actorScope.defer(()=>{\n            const self = actorScope.self;\n            actorScope.system.scheduler.schedule(self, self, event, delay, id);\n        });\n        return;\n    }\n}\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */ function raise(eventOrExpr, options) {\n    if (executingCustomAction) {\n        console.warn(\"Custom actions should not call `raise()` directly, as it is not imperative. See https://stately.ai/docs/actions#built-in-actions for more details.\");\n    }\n    function raise(_args, _params) {\n        {\n            throw new Error(\"This isn't supposed to be called\");\n        }\n    }\n    raise.type = \"xstate.raise\";\n    raise.event = eventOrExpr;\n    raise.id = options === null || options === void 0 ? void 0 : options.id;\n    raise.delay = options === null || options === void 0 ? void 0 : options.delay;\n    raise.resolve = resolveRaise;\n    raise.execute = executeRaise;\n    return raise;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC9yYWlzZS0xZGIyN2E4Mi5kZXZlbG9wbWVudC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEU7QUFFNUUsTUFBTUM7SUFPSkMsUUFBUTtRQUNOLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxLQUFLO0lBQ1o7SUFDQUMsUUFBUTtRQUNOLHlFQUF5RTtRQUN6RSxzRkFBc0Y7UUFDdEYsSUFBSSxJQUFJLENBQUNDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUNBLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHO1lBQ3JCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksQ0FBQ0YsUUFBUTtRQUM1QjtJQUNGO0lBQ0FHLFFBQVFDLEtBQUssRUFBRTtRQUNiLE1BQU1DLFdBQVc7WUFDZkMsT0FBT0Y7WUFDUEgsTUFBTTtRQUNSO1FBQ0EsSUFBSSxJQUFJLENBQUNELFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUNFLEtBQUssQ0FBQ0QsSUFBSSxHQUFHSTtZQUNsQixJQUFJLENBQUNILEtBQUssR0FBR0c7WUFDYjtRQUNGO1FBQ0EsSUFBSSxDQUFDTCxRQUFRLEdBQUdLO1FBQ2hCLElBQUksQ0FBQ0gsS0FBSyxHQUFHRztRQUNiLElBQUksSUFBSSxDQUFDUixPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDQyxLQUFLO1FBQ1o7SUFDRjtJQUNBQSxRQUFRO1FBQ04sTUFBTyxJQUFJLENBQUNFLFFBQVEsQ0FBRTtZQUNwQixtRkFBbUY7WUFDbkYsNkVBQTZFO1lBQzdFLE1BQU1PLFdBQVcsSUFBSSxDQUFDUCxRQUFRO1lBQzlCLElBQUksQ0FBQ1EsUUFBUSxDQUFDRCxTQUFTRCxLQUFLO1lBQzVCLElBQUksQ0FBQ04sUUFBUSxHQUFHTyxTQUFTTixJQUFJO1FBQy9CO1FBQ0EsSUFBSSxD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Q0wxSCxFQUFFLEVBQ0gsR0FBR2lQO0lBQ0osSUFBSSxPQUFPdkgsVUFBVSxVQUFVO1FBQzdCb0ksV0FBV3ZCLEtBQUssQ0FBQztZQUNmLE1BQU1sTCxPQUFPeU0sV0FBV3pNLElBQUk7WUFDNUJ5TSxXQUFXM0gsTUFBTSxDQUFDWixTQUFTLENBQUNDLFFBQVEsQ0FBQ25FLE1BQU1BLE1BQU1yRSxPQUFPMEksT0FBTzFIO1FBQ2pFO1FBQ0E7SUFDRjtBQUNGO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTcVYsTUFBTXlMLFdBQVcsRUFBRWphLE9BQU87SUFDakMsSUFBSTBELHVCQUF1QjtRQUN6QjlHLFFBQVFDLElBQUksQ0FBQztJQUNmO0lBQ0EsU0FBUzJSLE1BQU10RixLQUFLLEVBQUVDLE9BQU87UUFDM0I7WUFDRSxNQUFNLElBQUl0RyxNQUFPO1FBQ25CO0lBQ0Y7SUFDQTJMLE1BQU1wVixJQUFJLEdBQUc7SUFDYm9WLE1BQU1yVyxLQUFLLEdBQUc4aEI7SUFDZHpMLE1BQU1yVixFQUFFLEdBQUc2RyxvQkFBQUEsOEJBQUFBLFFBQVM3RyxFQUFFO0lBQ3RCcVYsTUFBTTNOLEtBQUssR0FBR2Isb0JBQUFBLDhCQUFBQSxRQUFTYSxLQUFLO0lBQzVCMk4sTUFBTXBGLE9BQU8sR0FBRzRRO0lBQ2hCeEwsTUFBTW5GLE9BQU8sR0FBR2lSO0lBQ2hCLE9BQU85TDtBQUNUO0FBRWtqQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QvcmFpc2UtMWRiMjdhODIuZGV2ZWxvcG1lbnQuZXNtLmpzP2U1ZTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV2VG9vbHNBZGFwdGVyIH0gZnJvbSAnLi4vZGV2L2Rpc3QveHN0YXRlLWRldi5kZXZlbG9wbWVudC5lc20uanMnO1xuXG5jbGFzcyBNYWlsYm94IHtcbiAgY29uc3RydWN0b3IoX3Byb2Nlc3MpIHtcbiAgICB0aGlzLl9wcm9jZXNzID0gX3Byb2Nlc3M7XG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgLy8gd2UgY2FuJ3Qgc2V0IF9jdXJyZW50IHRvIG51bGwgYmVjYXVzZSB3ZSBtaWdodCBiZSBjdXJyZW50bHkgcHJvY2Vzc2luZ1xuICAgIC8vIGFuZCBlbnF1ZXVlIGZvbGxvd2luZyBjbGVhciBzaG91bGRudCBzdGFydCBwcm9jZXNzaW5nIHRoZSBlbnF1ZXVlZCBpdGVtIGltbWVkaWF0ZWx5XG4gICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQubmV4dCA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0ID0gdGhpcy5fY3VycmVudDtcbiAgICB9XG4gIH1cbiAgZW5xdWV1ZShldmVudCkge1xuICAgIGNvbnN0IGVucXVldWVkID0ge1xuICAgICAgdmFsdWU6IGV2ZW50LFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2xhc3QubmV4dCA9IGVucXVldWVkO1xuICAgICAgdGhpcy5fbGFzdCA9IGVucXVldWVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50ID0gZW5xdWV1ZWQ7XG4gICAgdGhpcy5fbGFzdCA9IGVucXVldWVkO1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgd2hpbGUgKHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIC8vIGF0bSB0aGUgZ2l2ZW4gX3Byb2Nlc3MgaXMgcmVzcG9uc2libGUgZm9yIGltcGxlbWVudGluZyBwcm9wZXIgdHJ5L2NhdGNoIGhhbmRsaW5nXG4gICAgICAvLyB3ZSBhc3N1bWUgaGVyZSB0aGF0IHRoaXMgd29uJ3QgdGhyb3cgaW4gYSB3YXkgdGhhdCBjYW4gYWZmZWN0IHRoaXMgbWFpbGJveFxuICAgICAgY29uc3QgY29uc3VtZWQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgdGhpcy5fcHJvY2Vzcyhjb25zdW1lZC52YWx1ZSk7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gY29uc3VtZWQubmV4dDtcbiAgICB9XG4gICAgdGhpcy5fbGFzdCA9IG51bGw7XG4gIH1cbn1cblxuY29uc3QgU1RBVEVfREVMSU1JVEVSID0gJy4nO1xuY29uc3QgVEFSR0VUTEVTU19LRVkgPSAnJztcbmNvbnN0IE5VTExfRVZFTlQgPSAnJztcbmNvbnN0IFNUQVRFX0lERU5USUZJRVIgPSAnIyc7XG5jb25zdCBXSUxEQ0FSRCA9ICcqJztcbmNvbnN0IFhTVEFURV9JTklUID0gJ3hzdGF0ZS5pbml0JztcbmNvbnN0IFhTVEFURV9FUlJPUiA9ICd4c3RhdGUuZXJyb3InO1xuY29uc3QgWFNUQVRFX1NUT1AgPSAneHN0YXRlLnN0b3AnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIGFuIGltcGxpY2l0IGV2ZW50IHRoYXQgaXMgc2VudCBhZnRlciB0aGVcbiAqIHNwZWNpZmllZCBgZGVsYXlgLlxuICpcbiAqIEBwYXJhbSBkZWxheVJlZiBUaGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcGFyYW0gaWQgVGhlIHN0YXRlIG5vZGUgSUQgd2hlcmUgdGhpcyBldmVudCBpcyBoYW5kbGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFmdGVyRXZlbnQoZGVsYXlSZWYsIGlkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYHhzdGF0ZS5hZnRlci4ke2RlbGF5UmVmfS4ke2lkfWBcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGV2ZW50IHRoYXQgcmVwcmVzZW50cyB0aGF0IGEgZmluYWwgc3RhdGUgbm9kZSBoYXMgYmVlbiByZWFjaGVkIGluXG4gKiB0aGUgcGFyZW50IHN0YXRlIG5vZGUuXG4gKlxuICogQHBhcmFtIGlkIFRoZSBmaW5hbCBzdGF0ZSBub2RlJ3MgcGFyZW50IHN0YXRlIG5vZGUgYGlkYFxuICogQHBhcmFtIG91dHB1dCBUaGUgZGF0YSB0byBwYXNzIGludG8gdGhlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbmVTdGF0ZUV2ZW50KGlkLCBvdXRwdXQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmRvbmUuc3RhdGUuJHtpZH1gLFxuICAgIG91dHB1dFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoYXQgYW4gaW52b2tlZCBzZXJ2aWNlIGhhcyB0ZXJtaW5hdGVkLlxuICpcbiAqIEFuIGludm9rZWQgc2VydmljZSBpcyB0ZXJtaW5hdGVkIHdoZW4gaXQgaGFzIHJlYWNoZWQgYSB0b3AtbGV2ZWwgZmluYWwgc3RhdGVcbiAqIG5vZGUsIGJ1dCBub3Qgd2hlbiBpdCBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0gaW52b2tlSWQgVGhlIGludm9rZWQgc2VydmljZSBJRFxuICogQHBhcmFtIG91dHB1dCBUaGUgZGF0YSB0byBwYXNzIGludG8gdGhlIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbmVBY3RvckV2ZW50KGludm9rZUlkLCBvdXRwdXQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBgeHN0YXRlLmRvbmUuYWN0b3IuJHtpbnZva2VJZH1gLFxuICAgIG91dHB1dCxcbiAgICBhY3RvcklkOiBpbnZva2VJZFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRXJyb3JBY3RvckV2ZW50KGlkLCBlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGB4c3RhdGUuZXJyb3IuYWN0b3IuJHtpZH1gLFxuICAgIGVycm9yLFxuICAgIGFjdG9ySWQ6IGlkXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0RXZlbnQoaW5wdXQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBYU1RBVEVfSU5JVCxcbiAgICBpbnB1dFxuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbiBhIHNlcGFyYXRlXG4gKiBtYWNyb3Rhc2suIEl0IGFsbG93cyB0aG9zZSBlcnJvcnMgdG8gYmUgZGV0ZWN0ZWQgYnkgZ2xvYmFsIGVycm9yIGhhbmRsZXJzIGFuZFxuICogcmVwb3J0ZWQgdG8gYnVnIHRyYWNraW5nIHNlcnZpY2VzIHdpdGhvdXQgaW50ZXJydXB0aW5nIG91ciBvd24gc3RhY2sgb2ZcbiAqIGV4ZWN1dGlvbi5cbiAqXG4gKiBAcGFyYW0gZXJyIEVycm9yIHRvIGJlIHRocm93blxuICovXG5mdW5jdGlvbiByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn1cblxuY29uc3Qgc3ltYm9sT2JzZXJ2YWJsZSA9ICgoKSA9PiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5vYnNlcnZhYmxlIHx8ICdAQG9ic2VydmFibGUnKSgpO1xuXG5mdW5jdGlvbiBtYXRjaGVzU3RhdGUocGFyZW50U3RhdGVJZCwgY2hpbGRTdGF0ZUlkKSB7XG4gIGNvbnN0IHBhcmVudFN0YXRlVmFsdWUgPSB0b1N0YXRlVmFsdWUocGFyZW50U3RhdGVJZCk7XG4gIGNvbnN0IGNoaWxkU3RhdGVWYWx1ZSA9IHRvU3RhdGVWYWx1ZShjaGlsZFN0YXRlSWQpO1xuICBpZiAodHlwZW9mIGNoaWxkU3RhdGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHBhcmVudFN0YXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY2hpbGRTdGF0ZVZhbHVlID09PSBwYXJlbnRTdGF0ZVZhbHVlO1xuICAgIH1cblxuICAgIC8vIFBhcmVudCBtb3JlIHNwZWNpZmljIHRoYW4gY2hpbGRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXJlbnRTdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJlbnRTdGF0ZVZhbHVlIGluIGNoaWxkU3RhdGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMocGFyZW50U3RhdGVWYWx1ZSkuZXZlcnkoa2V5ID0+IHtcbiAgICBpZiAoIShrZXkgaW4gY2hpbGRTdGF0ZVZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlc1N0YXRlKHBhcmVudFN0YXRlVmFsdWVba2V5XSwgY2hpbGRTdGF0ZVZhbHVlW2tleV0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRvU3RhdGVQYXRoKHN0YXRlSWQpIHtcbiAgaWYgKGlzQXJyYXkoc3RhdGVJZCkpIHtcbiAgICByZXR1cm4gc3RhdGVJZDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHNlZ21lbnQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZUlkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHN0YXRlSWQuY2hhckNvZGVBdChpKTtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIC8vIFxcXG4gICAgICBjYXNlIDkyOlxuICAgICAgICAvLyBjb25zdW1lIHRoZSBuZXh0IGNoYXJhY3RlclxuICAgICAgICBzZWdtZW50ICs9IHN0YXRlSWRbaSArIDFdO1xuICAgICAgICAvLyBhbmQgc2tpcCBvdmVyIGl0XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICAvLyAuXG4gICAgICBjYXNlIDQ2OlxuICAgICAgICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgICAgICAgc2VnbWVudCA9ICcnO1xuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc2VnbWVudCArPSBzdGF0ZUlkW2ldO1xuICB9XG4gIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9TdGF0ZVZhbHVlKHN0YXRlVmFsdWUpIHtcbiAgaWYgKGlzTWFjaGluZVNuYXBzaG90KHN0YXRlVmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0YXRlVmFsdWUudmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdGF0ZVZhbHVlO1xuICB9XG4gIGNvbnN0IHN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlVmFsdWUpO1xuICByZXR1cm4gcGF0aFRvU3RhdGVWYWx1ZShzdGF0ZVBhdGgpO1xufVxuZnVuY3Rpb24gcGF0aFRvU3RhdGVWYWx1ZShzdGF0ZVBhdGgpIHtcbiAgaWYgKHN0YXRlUGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc3RhdGVQYXRoWzBdO1xuICB9XG4gIGNvbnN0IHZhbHVlID0ge307XG4gIGxldCBtYXJrZXIgPSB2YWx1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZVBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKGkgPT09IHN0YXRlUGF0aC5sZW5ndGggLSAyKSB7XG4gICAgICBtYXJrZXJbc3RhdGVQYXRoW2ldXSA9IHN0YXRlUGF0aFtpICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gbWFya2VyO1xuICAgICAgbWFya2VyID0ge307XG4gICAgICBwcmV2aW91c1tzdGF0ZVBhdGhbaV1dID0gbWFya2VyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBtYXBWYWx1ZXMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGNvbGxlY3Rpb25LZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sbGVjdGlvbktleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBjb2xsZWN0aW9uS2V5c1tpXTtcbiAgICByZXN1bHRba2V5XSA9IGl0ZXJhdGVlKGNvbGxlY3Rpb25ba2V5XSwga2V5LCBjb2xsZWN0aW9uLCBpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9BcnJheVN0cmljdCh2YWx1ZSkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFt2YWx1ZV07XG59XG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB0b0FycmF5U3RyaWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVPdXRwdXQobWFwcGVyLCBjb250ZXh0LCBldmVudCwgc2VsZikge1xuICBpZiAodHlwZW9mIG1hcHBlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXBwZXIoe1xuICAgICAgY29udGV4dCxcbiAgICAgIGV2ZW50LFxuICAgICAgc2VsZlxuICAgIH0pO1xuICB9XG4gIGlmICghIW1hcHBlciAmJiB0eXBlb2YgbWFwcGVyID09PSAnb2JqZWN0JyAmJiBPYmplY3QudmFsdWVzKG1hcHBlcikuc29tZSh2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjb25zb2xlLndhcm4oYER5bmFtaWNhbGx5IG1hcHBpbmcgdmFsdWVzIHRvIGluZGl2aWR1YWwgcHJvcGVydGllcyBpcyBkZXByZWNhdGVkLiBVc2UgYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtYXBwZWQgb2JqZWN0IGluc3RlYWQuXFxuRm91bmQgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB3aG9zZSB2YWx1ZXMgYXJlIHBvc3NpYmx5IG1hcHBpbmcgZnVuY3Rpb25zOiAke09iamVjdC5lbnRyaWVzKG1hcHBlcikuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykubWFwKChba2V5LCB2YWx1ZV0pID0+IGBcXG4gLSAke2tleX06ICR7dmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC9cXG5cXHMqL2csICcnKX1gKS5qb2luKCcnKX1gKTtcbiAgfVxuICByZXR1cm4gbWFwcGVyO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0Vycm9yQWN0b3JFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKCd4c3RhdGUuZXJyb3IuYWN0b3InKTtcbn1cbmZ1bmN0aW9uIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGNvbmZpZ0xpa2UpIHtcbiAgcmV0dXJuIHRvQXJyYXlTdHJpY3QoY29uZmlnTGlrZSkubWFwKHRyYW5zaXRpb25MaWtlID0+IHtcbiAgICBpZiAodHlwZW9mIHRyYW5zaXRpb25MaWtlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdHJhbnNpdGlvbkxpa2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YXJnZXQ6IHRyYW5zaXRpb25MaWtlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNpdGlvbkxpa2U7XG4gIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVGFyZ2V0KHRhcmdldCkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBUQVJHRVRMRVNTX0tFWSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHRvQXJyYXkodGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIHRvT2JzZXJ2ZXIobmV4dEhhbmRsZXIsIGVycm9ySGFuZGxlciwgY29tcGxldGlvbkhhbmRsZXIpIHtcbiAgY29uc3QgaXNPYnNlcnZlciA9IHR5cGVvZiBuZXh0SGFuZGxlciA9PT0gJ29iamVjdCc7XG4gIGNvbnN0IHNlbGYgPSBpc09ic2VydmVyID8gbmV4dEhhbmRsZXIgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgbmV4dDogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5uZXh0IDogbmV4dEhhbmRsZXIpPy5iaW5kKHNlbGYpLFxuICAgIGVycm9yOiAoaXNPYnNlcnZlciA/IG5leHRIYW5kbGVyLmVycm9yIDogZXJyb3JIYW5kbGVyKT8uYmluZChzZWxmKSxcbiAgICBjb21wbGV0ZTogKGlzT2JzZXJ2ZXIgPyBuZXh0SGFuZGxlci5jb21wbGV0ZSA6IGNvbXBsZXRpb25IYW5kbGVyKT8uYmluZChzZWxmKVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW52b2tlSWQoc3RhdGVOb2RlSWQsIGluZGV4KSB7XG4gIHJldHVybiBgJHtpbmRleH0uJHtzdGF0ZU5vZGVJZH1gO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZWRBY3RvcihtYWNoaW5lLCBzcmMpIHtcbiAgY29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL154c3RhdGVcXC5pbnZva2VcXC4oXFxkKylcXC4oLiopLyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuYWN0b3JzW3NyY107XG4gIH1cbiAgY29uc3QgWywgaW5kZXhTdHIsIG5vZGVJZF0gPSBtYXRjaDtcbiAgY29uc3Qgbm9kZSA9IG1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChub2RlSWQpO1xuICBjb25zdCBpbnZva2VDb25maWcgPSBub2RlLmNvbmZpZy5pbnZva2U7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShpbnZva2VDb25maWcpID8gaW52b2tlQ29uZmlnW2luZGV4U3RyXSA6IGludm9rZUNvbmZpZykuc3JjO1xufVxuZnVuY3Rpb24gZ2V0QWxsT3duRXZlbnREZXNjcmlwdG9ycyhzbmFwc2hvdCkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoWy4uLnNuYXBzaG90Ll9ub2Rlcy5mbGF0TWFwKHNuID0+IHNuLm93bkV2ZW50cyldKV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNjaGVkdWxlZEV2ZW50SWQoYWN0b3JSZWYsIGlkKSB7XG4gIHJldHVybiBgJHthY3RvclJlZi5zZXNzaW9uSWR9LiR7aWR9YDtcbn1cbmxldCBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gY3JlYXRlU3lzdGVtKHJvb3RBY3Rvciwgb3B0aW9ucykge1xuICBjb25zdCBjaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgY29uc3Qga2V5ZWRBY3RvcnMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHJldmVyc2VLZXllZEFjdG9ycyA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IGluc3BlY3Rpb25PYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHRpbWVyTWFwID0ge307XG4gIGNvbnN0IHtcbiAgICBjbG9jayxcbiAgICBsb2dnZXJcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHNjaGVkdWxlciA9IHtcbiAgICBzY2hlZHVsZTogKHNvdXJjZSwgdGFyZ2V0LCBldmVudCwgZGVsYXksIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMikpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIGRlbGF5LFxuICAgICAgICBpZCxcbiAgICAgICAgc3RhcnRlZEF0OiBEYXRlLm5vdygpXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnRJZCA9IGNyZWF0ZVNjaGVkdWxlZEV2ZW50SWQoc291cmNlLCBpZCk7XG4gICAgICBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF0gPSBzY2hlZHVsZWRFdmVudDtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBjbG9jay5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGVsZXRlIHRpbWVyTWFwW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgICBkZWxldGUgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZEV2ZW50SWRdO1xuICAgICAgICBzeXN0ZW0uX3JlbGF5KHNvdXJjZSwgdGFyZ2V0LCBldmVudCk7XG4gICAgICB9LCBkZWxheSk7XG4gICAgICB0aW1lck1hcFtzY2hlZHVsZWRFdmVudElkXSA9IHRpbWVvdXQ7XG4gICAgfSxcbiAgICBjYW5jZWw6IChzb3VyY2UsIGlkKSA9PiB7XG4gICAgICBjb25zdCBzY2hlZHVsZWRFdmVudElkID0gY3JlYXRlU2NoZWR1bGVkRXZlbnRJZChzb3VyY2UsIGlkKTtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aW1lck1hcFtzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgIGRlbGV0ZSB0aW1lck1hcFtzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgIGRlbGV0ZSBzeXN0ZW0uX3NuYXBzaG90Ll9zY2hlZHVsZWRFdmVudHNbc2NoZWR1bGVkRXZlbnRJZF07XG4gICAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsb2NrLmNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbEFsbDogYWN0b3JSZWYgPT4ge1xuICAgICAgZm9yIChjb25zdCBzY2hlZHVsZWRFdmVudElkIGluIHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50cykge1xuICAgICAgICBjb25zdCBzY2hlZHVsZWRFdmVudCA9IHN5c3RlbS5fc25hcHNob3QuX3NjaGVkdWxlZEV2ZW50c1tzY2hlZHVsZWRFdmVudElkXTtcbiAgICAgICAgaWYgKHNjaGVkdWxlZEV2ZW50LnNvdXJjZSA9PT0gYWN0b3JSZWYpIHtcbiAgICAgICAgICBzY2hlZHVsZXIuY2FuY2VsKGFjdG9yUmVmLCBzY2hlZHVsZWRFdmVudC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHNlbmRJbnNwZWN0aW9uRXZlbnQgPSBldmVudCA9PiB7XG4gICAgaWYgKCFpbnNwZWN0aW9uT2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRJbnNwZWN0aW9uRXZlbnQgPSB7XG4gICAgICAuLi5ldmVudCxcbiAgICAgIHJvb3RJZDogcm9vdEFjdG9yLnNlc3Npb25JZFxuICAgIH07XG4gICAgaW5zcGVjdGlvbk9ic2VydmVycy5mb3JFYWNoKG9ic2VydmVyID0+IG9ic2VydmVyLm5leHQ/LihyZXNvbHZlZEluc3BlY3Rpb25FdmVudCkpO1xuICB9O1xuICBjb25zdCBzeXN0ZW0gPSB7XG4gICAgX3NuYXBzaG90OiB7XG4gICAgICBfc2NoZWR1bGVkRXZlbnRzOiAob3B0aW9ucz8uc25hcHNob3QgJiYgb3B0aW9ucy5zbmFwc2hvdC5zY2hlZHVsZXIpID8/IHt9XG4gICAgfSxcbiAgICBfYm9va0lkOiAoKSA9PiBgeDoke2lkQ291bnRlcisrfWAsXG4gICAgX3JlZ2lzdGVyOiAoc2Vzc2lvbklkLCBhY3RvclJlZikgPT4ge1xuICAgICAgY2hpbGRyZW4uc2V0KHNlc3Npb25JZCwgYWN0b3JSZWYpO1xuICAgICAgcmV0dXJuIHNlc3Npb25JZDtcbiAgICB9LFxuICAgIF91bnJlZ2lzdGVyOiBhY3RvclJlZiA9PiB7XG4gICAgICBjaGlsZHJlbi5kZWxldGUoYWN0b3JSZWYuc2Vzc2lvbklkKTtcbiAgICAgIGNvbnN0IHN5c3RlbUlkID0gcmV2ZXJzZUtleWVkQWN0b3JzLmdldChhY3RvclJlZik7XG4gICAgICBpZiAoc3lzdGVtSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXllZEFjdG9ycy5kZWxldGUoc3lzdGVtSWQpO1xuICAgICAgICByZXZlcnNlS2V5ZWRBY3RvcnMuZGVsZXRlKGFjdG9yUmVmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogc3lzdGVtSWQgPT4ge1xuICAgICAgcmV0dXJuIGtleWVkQWN0b3JzLmdldChzeXN0ZW1JZCk7XG4gICAgfSxcbiAgICBfc2V0OiAoc3lzdGVtSWQsIGFjdG9yUmVmKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IGtleWVkQWN0b3JzLmdldChzeXN0ZW1JZCk7XG4gICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcgIT09IGFjdG9yUmVmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWN0b3Igd2l0aCBzeXN0ZW0gSUQgJyR7c3lzdGVtSWR9JyBhbHJlYWR5IGV4aXN0cy5gKTtcbiAgICAgIH1cbiAgICAgIGtleWVkQWN0b3JzLnNldChzeXN0ZW1JZCwgYWN0b3JSZWYpO1xuICAgICAgcmV2ZXJzZUtleWVkQWN0b3JzLnNldChhY3RvclJlZiwgc3lzdGVtSWQpO1xuICAgIH0sXG4gICAgaW5zcGVjdDogb2JzZXJ2ZXJPckZuID0+IHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gdG9PYnNlcnZlcihvYnNlcnZlck9yRm4pO1xuICAgICAgaW5zcGVjdGlvbk9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgaW5zcGVjdGlvbk9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgX3NlbmRJbnNwZWN0aW9uRXZlbnQ6IHNlbmRJbnNwZWN0aW9uRXZlbnQsXG4gICAgX3JlbGF5OiAoc291cmNlLCB0YXJnZXQsIGV2ZW50KSA9PiB7XG4gICAgICBzeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgICB0eXBlOiAnQHhzdGF0ZS5ldmVudCcsXG4gICAgICAgIHNvdXJjZVJlZjogc291cmNlLFxuICAgICAgICBhY3RvclJlZjogdGFyZ2V0LFxuICAgICAgICBldmVudFxuICAgICAgfSk7XG4gICAgICB0YXJnZXQuX3NlbmQoZXZlbnQpO1xuICAgIH0sXG4gICAgc2NoZWR1bGVyLFxuICAgIGdldFNuYXBzaG90OiAoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfc2NoZWR1bGVkRXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBzdGFydDogKCkgPT4ge1xuICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnRzID0gc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzO1xuICAgICAgc3lzdGVtLl9zbmFwc2hvdC5fc2NoZWR1bGVkRXZlbnRzID0ge307XG4gICAgICBmb3IgKGNvbnN0IHNjaGVkdWxlZElkIGluIHNjaGVkdWxlZEV2ZW50cykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBkZWxheSxcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gc2NoZWR1bGVkRXZlbnRzW3NjaGVkdWxlZElkXTtcbiAgICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlKHNvdXJjZSwgdGFyZ2V0LCBldmVudCwgZGVsYXksIGlkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jbG9jazogY2xvY2ssXG4gICAgX2xvZ2dlcjogbG9nZ2VyXG4gIH07XG4gIHJldHVybiBzeXN0ZW07XG59XG5cbmxldCBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBmYWxzZTtcbmNvbnN0ICQkQUNUT1JfVFlQRSA9IDE7XG5cbi8vIHRob3NlIHZhbHVlcyBhcmUgY3VycmVudGx5IHVzZWQgYnkgQHhzdGF0ZS9yZWFjdCBkaXJlY3RseSBzbyBpdCdzIGltcG9ydGFudCB0byBrZWVwIHRoZSBhc3NpZ25lZCB2YWx1ZXMgaW4gc3luY1xubGV0IFByb2Nlc3NpbmdTdGF0dXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKFByb2Nlc3NpbmdTdGF0dXMpIHtcbiAgUHJvY2Vzc2luZ1N0YXR1c1tQcm9jZXNzaW5nU3RhdHVzW1wiTm90U3RhcnRlZFwiXSA9IDBdID0gXCJOb3RTdGFydGVkXCI7XG4gIFByb2Nlc3NpbmdTdGF0dXNbUHJvY2Vzc2luZ1N0YXR1c1tcIlJ1bm5pbmdcIl0gPSAxXSA9IFwiUnVubmluZ1wiO1xuICBQcm9jZXNzaW5nU3RhdHVzW1Byb2Nlc3NpbmdTdGF0dXNbXCJTdG9wcGVkXCJdID0gMl0gPSBcIlN0b3BwZWRcIjtcbiAgcmV0dXJuIFByb2Nlc3NpbmdTdGF0dXM7XG59KHt9KTtcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBjbG9jazoge1xuICAgIHNldFRpbWVvdXQ6IChmbiwgbXMpID0+IHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gICAgfSxcbiAgICBjbGVhclRpbWVvdXQ6IGlkID0+IHtcbiAgICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cbiAgfSxcbiAgbG9nZ2VyOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxuICBkZXZUb29sczogZmFsc2Vcbn07XG5cbi8qKlxuICogQW4gQWN0b3IgaXMgYSBydW5uaW5nIHByb2Nlc3MgdGhhdCBjYW4gcmVjZWl2ZSBldmVudHMsIHNlbmQgZXZlbnRzIGFuZCBjaGFuZ2VcbiAqIGl0cyBiZWhhdmlvciBiYXNlZCBvbiB0aGUgZXZlbnRzIGl0IHJlY2VpdmVzLCB3aGljaCBjYW4gY2F1c2UgZWZmZWN0cyBvdXRzaWRlXG4gKiBvZiB0aGUgYWN0b3IuIFdoZW4geW91IHJ1biBhIHN0YXRlIG1hY2hpbmUsIGl0IGJlY29tZXMgYW4gYWN0b3IuXG4gKi9cbmNsYXNzIEFjdG9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYWN0b3IgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBsb2dpYyB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLFxuICAgKiBpZiBhbnkuXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpYyBUaGUgbG9naWMgdG8gY3JlYXRlIGFuIGFjdG9yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgQWN0b3Igb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IobG9naWMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmxvZ2ljID0gbG9naWM7XG4gICAgLyoqIFRoZSBjdXJyZW50IGludGVybmFsIHN0YXRlIG9mIHRoZSBhY3Rvci4gKi9cbiAgICB0aGlzLl9zbmFwc2hvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xvY2sgdGhhdCBpcyByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbmQgY2xlYXJpbmcgdGltZW91dHMsIHN1Y2ggYXNcbiAgICAgKiBkZWxheWVkIGV2ZW50cyBhbmQgdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3RvciByZWxhdGl2ZSB0byBpdHMgcGFyZW50LiAqL1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5tYWlsYm94ID0gbmV3IE1haWxib3godGhpcy5fcHJvY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID0gUHJvY2Vzc2luZ1N0YXR1cy5Ob3RTdGFydGVkO1xuICAgIC8vIEFjdG9yIFJlZlxuICAgIHRoaXMuX3BhcmVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3luY1NuYXBzaG90ID0gdm9pZCAwO1xuICAgIHRoaXMucmVmID0gdm9pZCAwO1xuICAgIC8vIFRPRE86IGFkZCB0eXBpbmdzIGZvciBzeXN0ZW1cbiAgICB0aGlzLl9hY3RvclNjb3BlID0gdm9pZCAwO1xuICAgIHRoaXMuX3N5c3RlbUlkID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZ2xvYmFsbHkgdW5pcXVlIHByb2Nlc3MgSUQgZm9yIHRoaXMgaW52b2NhdGlvbi4gKi9cbiAgICB0aGlzLnNlc3Npb25JZCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHN5c3RlbSB0byB3aGljaCB0aGlzIGFjdG9yIGJlbG9uZ3MuICovXG4gICAgdGhpcy5zeXN0ZW0gPSB2b2lkIDA7XG4gICAgdGhpcy5fZG9uZUV2ZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuc3JjID0gdm9pZCAwO1xuICAgIC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBkZWZlclxuICAgIHRoaXMuX2RlZmVycmVkID0gW107XG4gICAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBjbG9jayxcbiAgICAgIGxvZ2dlcixcbiAgICAgIHBhcmVudCxcbiAgICAgIHN5bmNTbmFwc2hvdCxcbiAgICAgIGlkLFxuICAgICAgc3lzdGVtSWQsXG4gICAgICBpbnNwZWN0XG4gICAgfSA9IHJlc29sdmVkT3B0aW9ucztcbiAgICB0aGlzLnN5c3RlbSA9IHBhcmVudCA/IHBhcmVudC5zeXN0ZW0gOiBjcmVhdGVTeXN0ZW0odGhpcywge1xuICAgICAgY2xvY2ssXG4gICAgICBsb2dnZXJcbiAgICB9KTtcbiAgICBpZiAoaW5zcGVjdCAmJiAhcGFyZW50KSB7XG4gICAgICAvLyBBbHdheXMgaW5zcGVjdCBhdCB0aGUgc3lzdGVtLWxldmVsXG4gICAgICB0aGlzLnN5c3RlbS5pbnNwZWN0KHRvT2JzZXJ2ZXIoaW5zcGVjdCkpO1xuICAgIH1cbiAgICB0aGlzLnNlc3Npb25JZCA9IHRoaXMuc3lzdGVtLl9ib29rSWQoKTtcbiAgICB0aGlzLmlkID0gaWQgPz8gdGhpcy5zZXNzaW9uSWQ7XG4gICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zPy5sb2dnZXIgPz8gdGhpcy5zeXN0ZW0uX2xvZ2dlcjtcbiAgICB0aGlzLmNsb2NrID0gb3B0aW9ucz8uY2xvY2sgPz8gdGhpcy5zeXN0ZW0uX2Nsb2NrO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9zeW5jU25hcHNob3QgPSBzeW5jU25hcHNob3Q7XG4gICAgdGhpcy5vcHRpb25zID0gcmVzb2x2ZWRPcHRpb25zO1xuICAgIHRoaXMuc3JjID0gcmVzb2x2ZWRPcHRpb25zLnNyYyA/PyBsb2dpYztcbiAgICB0aGlzLnJlZiA9IHRoaXM7XG4gICAgdGhpcy5fYWN0b3JTY29wZSA9IHtcbiAgICAgIHNlbGY6IHRoaXMsXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNlc3Npb25JZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgZGVmZXI6IGZuID0+IHtcbiAgICAgICAgdGhpcy5fZGVmZXJyZWQucHVzaChmbik7XG4gICAgICB9LFxuICAgICAgc3lzdGVtOiB0aGlzLnN5c3RlbSxcbiAgICAgIHN0b3BDaGlsZDogY2hpbGQgPT4ge1xuICAgICAgICBpZiAoY2hpbGQuX3BhcmVudCAhPT0gdGhpcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHN0b3AgY2hpbGQgYWN0b3IgJHtjaGlsZC5pZH0gb2YgJHt0aGlzLmlkfSBiZWNhdXNlIGl0IGlzIG5vdCBhIGNoaWxkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuX3N0b3AoKTtcbiAgICAgIH0sXG4gICAgICBlbWl0OiBlbWl0dGVkRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChlbWl0dGVkRXZlbnQudHlwZSk7XG4gICAgICAgIGNvbnN0IHdpbGRjYXJkTGlzdGVuZXIgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldCgnKicpO1xuICAgICAgICBpZiAoIWxpc3RlbmVycyAmJiAhd2lsZGNhcmRMaXN0ZW5lcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbGxMaXN0ZW5lcnMgPSBbLi4uKGxpc3RlbmVycyA/IGxpc3RlbmVycy52YWx1ZXMoKSA6IFtdKSwgLi4uKHdpbGRjYXJkTGlzdGVuZXIgPyB3aWxkY2FyZExpc3RlbmVyLnZhbHVlcygpIDogW10pXTtcbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGFsbExpc3RlbmVycykge1xuICAgICAgICAgIGhhbmRsZXIoZW1pdHRlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkV4ZWN1dG9yOiBhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBleGVjID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2FjdG9yU2NvcGUuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6ICdAeHN0YXRlLmFjdGlvbicsXG4gICAgICAgICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgICAgICB0eXBlOiBhY3Rpb24udHlwZSxcbiAgICAgICAgICAgICAgcGFyYW1zOiBhY3Rpb24ucGFyYW1zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFhY3Rpb24uZXhlYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzYXZlRXhlY3V0aW5nQ3VzdG9tQWN0aW9uID0gZXhlY3V0aW5nQ3VzdG9tQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgYWN0aW9uLmV4ZWMoYWN0aW9uLmluZm8sIGFjdGlvbi5wYXJhbXMpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBleGVjdXRpbmdDdXN0b21BY3Rpb24gPSBzYXZlRXhlY3V0aW5nQ3VzdG9tQWN0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZykge1xuICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kZWZlcnJlZC5wdXNoKGV4ZWMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBzZW5kIG1ldGhvZCBpcyBib3VuZCB0byB0aGlzIEFjdG9yIGluc3RhbmNlXG4gICAgLy8gaWYgZGVzdHJ1Y3R1cmVkXG4gICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUuYWN0b3InLFxuICAgICAgYWN0b3JSZWY6IHRoaXNcbiAgICB9KTtcbiAgICBpZiAoc3lzdGVtSWQpIHtcbiAgICAgIHRoaXMuX3N5c3RlbUlkID0gc3lzdGVtSWQ7XG4gICAgICB0aGlzLnN5c3RlbS5fc2V0KHN5c3RlbUlkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdFN0YXRlKG9wdGlvbnM/LnNuYXBzaG90ID8/IG9wdGlvbnM/LnN0YXRlKTtcbiAgICBpZiAoc3lzdGVtSWQgJiYgdGhpcy5fc25hcHNob3Quc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgICAgdGhpcy5zeXN0ZW0uX3VucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIF9pbml0U3RhdGUocGVyc2lzdGVkU3RhdGUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fc25hcHNob3QgPSBwZXJzaXN0ZWRTdGF0ZSA/IHRoaXMubG9naWMucmVzdG9yZVNuYXBzaG90ID8gdGhpcy5sb2dpYy5yZXN0b3JlU25hcHNob3QocGVyc2lzdGVkU3RhdGUsIHRoaXMuX2FjdG9yU2NvcGUpIDogcGVyc2lzdGVkU3RhdGUgOiB0aGlzLmxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdCh0aGlzLl9hY3RvclNjb3BlLCB0aGlzLm9wdGlvbnM/LmlucHV0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGlmIHdlIGdldCBoZXJlIHRoZW4gaXQgbWVhbnMgdGhhdCB3ZSBhc3NpZ24gYSB2YWx1ZSB0byB0aGlzLl9zbmFwc2hvdCB0aGF0IGlzIG5vdCBvZiB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAvLyB3ZSBjYW4ndCBnZXQgdGhlIHRydWUgYFRTbmFwc2hvdCAmIHsgc3RhdHVzOiAnZXJyb3InOyB9YCwgaXQncyBpbXBvc3NpYmxlXG4gICAgICAvLyBzbyByaWdodCBub3cgdGhpcyBpcyBhIGxpZSBvZiBzb3J0c1xuICAgICAgdGhpcy5fc25hcHNob3QgPSB7XG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgb3V0cHV0OiB1bmRlZmluZWQsXG4gICAgICAgIGVycm9yOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHVwZGF0ZShzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICB0aGlzLl9zbmFwc2hvdCA9IHNuYXBzaG90O1xuXG4gICAgLy8gRXhlY3V0ZSBkZWZlcnJlZCBlZmZlY3RzXG4gICAgbGV0IGRlZmVycmVkRm47XG4gICAgd2hpbGUgKGRlZmVycmVkRm4gPSB0aGlzLl9kZWZlcnJlZC5zaGlmdCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkZWZlcnJlZEZuKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gdGhpcyBlcnJvciBjYW4gb25seSBiZSBjYXVnaHQgd2hlbiBleGVjdXRpbmcgKmluaXRpYWwqIGFjdGlvbnNcbiAgICAgICAgLy8gaXQncyB0aGUgb25seSB0aW1lIHdoZW4gd2UgY2FsbCBhY3Rpb25zIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIHRocm91Z2ggdGhvc2UgZGVmZXJyZWRzXG4gICAgICAgIC8vIHdoZW4gdGhlIGFjdG9yIGlzIGFscmVhZHkgcnVubmluZyB3ZSBhbHdheXMgZXhlY3V0ZSB0aGVtIHN5bmNocm9ub3VzbHkgd2hpbGUgdHJhbnNpdGlvbmluZ1xuICAgICAgICAvLyBubyBcImJ1aWx0aW4gZGVmZXJyZWRcIiBzaG91bGQgYWN0dWFsbHkgdGhyb3cgYW4gZXJyb3Igc2luY2UgdGhleSBhcmUgZWl0aGVyIHNhZmVcbiAgICAgICAgLy8gb3IgdGhlIGNvbnRyb2wgZmxvdyBpcyBwYXNzZWQgdGhyb3VnaCB0aGUgbWFpbGJveCBhbmQgZXJyb3JzIHNob3VsZCBiZSBjYXVnaHQgYnkgdGhlIGBfcHJvY2Vzc2AgdXNlZCBieSB0aGUgbWFpbGJveFxuICAgICAgICB0aGlzLl9kZWZlcnJlZC5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgICAuLi5zbmFwc2hvdCxcbiAgICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuX3NuYXBzaG90LnN0YXR1cykge1xuICAgICAgY2FzZSAnYWN0aXZlJzpcbiAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiB0aGlzLm9ic2VydmVycykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0Py4oc25hcHNob3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgLy8gbmV4dCBvYnNlcnZlcnMgYXJlIG1lYW50IHRvIGJlIG5vdGlmaWVkIGFib3V0IGRvbmUgc25hcHNob3RzXG4gICAgICAgIC8vIHRoaXMgY2FuIGJlIHNlZW4gYXMgc29tZXRoaW5nIHRoYXQgaXMgZGlmZmVyZW50IGZyb20gaG93IG9ic2VydmFibGUgd29ya1xuICAgICAgICAvLyBidXQgd2l0aCBvYnNlcnZhYmxlcyBgY29tcGxldGVgIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRob3V0IGFueSBhcmd1bWVudHNcbiAgICAgICAgLy8gaXQncyBtb3JlIGVyZ29ub21pYyBmb3IgWFN0YXRlIHRvIHRyZWF0IGEgZG9uZSBzbmFwc2hvdCBhcyBhIFwibmV4dFwiIHZhbHVlXG4gICAgICAgIC8vIGFuZCB0aGUgY29tcGxldGlvbiBldmVudCBhcyBzb21ldGhpbmcgdGhhdCBpcyBzZXBhcmF0ZSxcbiAgICAgICAgLy8gc29tZXRoaW5nIHRoYXQgbWVyZWx5IGZvbGxvd3MgZW1pdHRpbmcgdGhhdCBkb25lIHNuYXBzaG90XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHNuYXBzaG90KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlcG9ydFVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3BQcm9jZWR1cmUoKTtcbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fZG9uZUV2ZW50ID0gY3JlYXRlRG9uZUFjdG9yRXZlbnQodGhpcy5pZCwgdGhpcy5fc25hcHNob3Qub3V0cHV0KTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgIHRoaXMuc3lzdGVtLl9yZWxheSh0aGlzLCB0aGlzLl9wYXJlbnQsIHRoaXMuX2RvbmVFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHRoaXMuX2Vycm9yKHRoaXMuX3NuYXBzaG90LmVycm9yKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLl9zZW5kSW5zcGVjdGlvbkV2ZW50KHtcbiAgICAgIHR5cGU6ICdAeHN0YXRlLnNuYXBzaG90JyxcbiAgICAgIGFjdG9yUmVmOiB0aGlzLFxuICAgICAgZXZlbnQsXG4gICAgICBzbmFwc2hvdFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBhbiBvYnNlcnZlciB0byBhbiBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWVzLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgb2JzZXJ2ZXIgd2lsbCByZWNlaXZlIHRoZSBhY3RvcuKAmXMgc25hcHNob3QgdmFsdWUgd2hlbiBpdCBpcyBlbWl0dGVkLlxuICAgKiBUaGUgb2JzZXJ2ZXIgY2FuIGJlOlxuICAgKlxuICAgKiAtIEEgcGxhaW4gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0IHNuYXBzaG90LCBvclxuICAgKiAtIEFuIG9ic2VydmVyIG9iamVjdCB3aG9zZSBgLm5leHQoc25hcHNob3QpYCBtZXRob2QgcmVjZWl2ZXMgdGhlIGxhdGVzdFxuICAgKiAgIHNuYXBzaG90XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIC8vIE9ic2VydmVyIGFzIGEgcGxhaW4gZnVuY3Rpb25cbiAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHNuYXBzaG90KTtcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBgYGB0c1xuICAgKiAvLyBPYnNlcnZlciBhcyBhbiBvYmplY3RcbiAgICogY29uc3Qgc3Vic2NyaXB0aW9uID0gYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICogICBuZXh0KHNuYXBzaG90KSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gICAqICAgfSxcbiAgICogICBlcnJvcihlcnIpIHtcbiAgICogICAgIC8vIC4uLlxuICAgKiAgIH0sXG4gICAqICAgY29tcGxldGUoKSB7XG4gICAqICAgICAvLyAuLi5cbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICpcbiAgICogVGhlIHJldHVybiB2YWx1ZSBvZiBgYWN0b3Iuc3Vic2NyaWJlKG9ic2VydmVyKWAgaXMgYSBzdWJzY3JpcHRpb24gb2JqZWN0XG4gICAqIHRoYXQgaGFzIGFuIGAudW5zdWJzY3JpYmUoKWAgbWV0aG9kLiBZb3UgY2FuIGNhbGxcbiAgICogYHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpYCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2ZXI6XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFjdG9yLnN1YnNjcmliZSgoc25hcHNob3QpID0+IHtcbiAgICogICAvLyAuLi5cbiAgICogfSk7XG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIHRoZSBvYnNlcnZlclxuICAgKiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFdoZW4gdGhlIGFjdG9yIGlzIHN0b3BwZWQsIGFsbCBvZiBpdHMgb2JzZXJ2ZXJzIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgKiB1bnN1YnNjcmliZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvYnNlcnZlciAtIEVpdGhlciBhIHBsYWluIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdFxuICAgKiAgIHNuYXBzaG90LCBvciBhbiBvYnNlcnZlciBvYmplY3Qgd2hvc2UgYC5uZXh0KHNuYXBzaG90KWAgbWV0aG9kIHJlY2VpdmVzXG4gICAqICAgdGhlIGxhdGVzdCBzbmFwc2hvdFxuICAgKi9cblxuICBzdWJzY3JpYmUobmV4dExpc3RlbmVyT3JPYnNlcnZlciwgZXJyb3JMaXN0ZW5lciwgY29tcGxldGVMaXN0ZW5lcikge1xuICAgIGNvbnN0IG9ic2VydmVyID0gdG9PYnNlcnZlcihuZXh0TGlzdGVuZXJPck9ic2VydmVyLCBlcnJvckxpc3RlbmVyLCBjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICB0aGlzLm9ic2VydmVycy5hZGQob2JzZXJ2ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuX3NuYXBzaG90LnN0YXR1cykge1xuICAgICAgICBjYXNlICdkb25lJzpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSB0aGlzLl9zbmFwc2hvdC5lcnJvcjtcbiAgICAgICAgICAgIGlmICghb2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVycy5nZXQodHlwZSk7XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuc2V0KHR5cGUsIGxpc3RlbmVycyk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRIYW5kbGVyID0gaGFuZGxlci5iaW5kKHVuZGVmaW5lZCk7XG4gICAgbGlzdGVuZXJzLmFkZCh3cmFwcGVkSGFuZGxlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUod3JhcHBlZEhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiogU3RhcnRzIHRoZSBBY3RvciBmcm9tIHRoZSBpbml0aWFsIHN0YXRlICovXG4gIHN0YXJ0KCkge1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICAgIC8vIERvIG5vdCByZXN0YXJ0IHRoZSBzZXJ2aWNlIGlmIGl0IGlzIGFscmVhZHkgc3RhcnRlZFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zeW5jU25hcHNob3QpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogc25hcHNob3QgPT4ge1xuICAgICAgICAgIGlmIChzbmFwc2hvdC5zdGF0dXMgPT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICB0aGlzLnN5c3RlbS5fcmVsYXkodGhpcywgdGhpcy5fcGFyZW50LCB7XG4gICAgICAgICAgICAgIHR5cGU6IGB4c3RhdGUuc25hcHNob3QuJHt0aGlzLmlkfWAsXG4gICAgICAgICAgICAgIHNuYXBzaG90XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiAoKSA9PiB7fVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLl9yZWdpc3Rlcih0aGlzLnNlc3Npb25JZCwgdGhpcyk7XG4gICAgaWYgKHRoaXMuX3N5c3RlbUlkKSB7XG4gICAgICB0aGlzLnN5c3RlbS5fc2V0KHRoaXMuX3N5c3RlbUlkLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyA9IFByb2Nlc3NpbmdTdGF0dXMuUnVubmluZztcblxuICAgIC8vIFRPRE86IHRoaXMgaXNuJ3QgY29ycmVjdCB3aGVuIHJlaHlkcmF0aW5nXG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KHRoaXMub3B0aW9ucy5pbnB1dCk7XG4gICAgdGhpcy5zeXN0ZW0uX3NlbmRJbnNwZWN0aW9uRXZlbnQoe1xuICAgICAgdHlwZTogJ0B4c3RhdGUuZXZlbnQnLFxuICAgICAgc291cmNlUmVmOiB0aGlzLl9wYXJlbnQsXG4gICAgICBhY3RvclJlZjogdGhpcyxcbiAgICAgIGV2ZW50OiBpbml0RXZlbnRcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLl9zbmFwc2hvdC5zdGF0dXM7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgJ2RvbmUnOlxuICAgICAgICAvLyBhIHN0YXRlIG1hY2hpbmUgY2FuIGJlIFwiZG9uZVwiIHVwb24gaW5pdGlhbGl6YXRpb24gKGl0IGNvdWxkIHJlYWNoIGEgZmluYWwgc3RhdGUgdXNpbmcgaW5pdGlhbCBtaWNyb3N0ZXBzKVxuICAgICAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNvbXBsZXRlIG9ic2VydmVycywgZmx1c2ggZGVmZXJyZWRzIGV0Y1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLl9zbmFwc2hvdCwgaW5pdEV2ZW50KTtcbiAgICAgICAgLy8gVE9ETzogcmV0aGluayBjbGVhbnVwIG9mIG9ic2VydmVycywgbWFpbGJveCwgZXRjXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB0aGlzLl9lcnJvcih0aGlzLl9zbmFwc2hvdC5lcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5zeXN0ZW0uc3RhcnQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubG9naWMuc3RhcnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9naWMuc3RhcnQodGhpcy5fc25hcHNob3QsIHRoaXMuX2FjdG9yU2NvcGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX3NuYXBzaG90ID0ge1xuICAgICAgICAgIC4uLnRoaXMuX3NuYXBzaG90LFxuICAgICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgbm90aWZpZXMgYWxsIHN1YnNjcmliZXJzIGJ1dCB1c3VhbGx5IHRoaXMgaXMgcmVkdW5kYW50XG4gICAgLy8gdGhlcmUgaXMgbm8gcmVhbCBjaGFuZ2UgaGFwcGVuaW5nIGhlcmVcbiAgICAvLyB3ZSBuZWVkIHRvIHJldGhpbmsgaWYgdGhpcyBuZWVkcyB0byBiZSByZWZhY3RvcmVkXG4gICAgdGhpcy51cGRhdGUodGhpcy5fc25hcHNob3QsIGluaXRFdmVudCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZXZUb29scykge1xuICAgICAgdGhpcy5hdHRhY2hEZXZUb29scygpO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guc3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfcHJvY2VzcyhldmVudCkge1xuICAgIGxldCBuZXh0U3RhdGU7XG4gICAgbGV0IGNhdWdodEVycm9yO1xuICAgIHRyeSB7XG4gICAgICBuZXh0U3RhdGUgPSB0aGlzLmxvZ2ljLnRyYW5zaXRpb24odGhpcy5fc25hcHNob3QsIGV2ZW50LCB0aGlzLl9hY3RvclNjb3BlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHdlIHdyYXAgaXQgaW4gYSBib3ggc28gd2UgY2FuIHJldGhyb3cgaXQgbGF0ZXIgZXZlbiBpZiBmYWxzeSB2YWx1ZSBnZXRzIGNhdWdodCBoZXJlXG4gICAgICBjYXVnaHRFcnJvciA9IHtcbiAgICAgICAgZXJyXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyXG4gICAgICB9ID0gY2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLl9zbmFwc2hvdCA9IHtcbiAgICAgICAgLi4udGhpcy5fc25hcHNob3QsXG4gICAgICAgIHN0YXR1czogJ2Vycm9yJyxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgICAgfTtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKG5leHRTdGF0ZSwgZXZlbnQpO1xuICAgIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgICAgdGhpcy5fc3RvcFByb2NlZHVyZSgpO1xuICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMubWFpbGJveC5jbGVhcigpO1xuICAgIGlmICh0aGlzLl9wcm9jZXNzaW5nU3RhdHVzID09PSBQcm9jZXNzaW5nU3RhdHVzLk5vdFN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5tYWlsYm94LmVucXVldWUoe1xuICAgICAgdHlwZTogWFNUQVRFX1NUT1BcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBTdG9wcyB0aGUgQWN0b3IgYW5kIHVuc3Vic2NyaWJlIGFsbCBsaXN0ZW5lcnMuICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG5vbi1yb290IGFjdG9yIGNhbm5vdCBiZSBzdG9wcGVkIGRpcmVjdGx5LicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RvcCgpO1xuICB9XG4gIF9jb21wbGV0ZSgpIHtcbiAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuICBfcmVwb3J0RXJyb3IoZXJyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcmVwb3J0RXJyb3IgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBlcnJvckxpc3RlbmVyID0gb2JzZXJ2ZXIuZXJyb3I7XG4gICAgICByZXBvcnRFcnJvciB8fD0gIWVycm9yTGlzdGVuZXI7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckxpc3RlbmVyPy4oZXJyKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmNsZWFyKCk7XG4gICAgaWYgKHJlcG9ydEVycm9yKSB7XG4gICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICBfZXJyb3IoZXJyKSB7XG4gICAgdGhpcy5fc3RvcFByb2NlZHVyZSgpO1xuICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycik7XG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5zeXN0ZW0uX3JlbGF5KHRoaXMsIHRoaXMuX3BhcmVudCwgY3JlYXRlRXJyb3JBY3RvckV2ZW50KHRoaXMuaWQsIGVycikpO1xuICAgIH1cbiAgfVxuICAvLyBUT0RPOiBhdG0gY2hpbGRyZW4gZG9uJ3QgYmVsb25nIGVudGlyZWx5IHRvIHRoZSBhY3RvciBzb1xuICAvLyBpbiBhIHdheSAtIGl0J3Mgbm90IGV2ZW4gc3VwZXIgYXdhcmUgb2YgdGhlbVxuICAvLyBzbyB3ZSBjYW4ndCBzdG9wIHRoZW0gZnJvbSBoZXJlIGJ1dCB3ZSByZWFsbHkgc2hvdWxkIVxuICAvLyByaWdodCBub3csIHRoZXkgYXJlIGJlaW5nIHN0b3BwZWQgd2l0aGluIHRoZSBtYWNoaW5lJ3MgdHJhbnNpdGlvblxuICAvLyBidXQgdGhhdCBjb3VsZCB0aHJvdyBhbmQgbGVhdmUgdXMgd2l0aCBcIm9ycGhhbmVkXCIgYWN0aXZlIGFjdG9yc1xuICBfc3RvcFByb2NlZHVyZSgpIHtcbiAgICBpZiAodGhpcy5fcHJvY2Vzc2luZ1N0YXR1cyAhPT0gUHJvY2Vzc2luZ1N0YXR1cy5SdW5uaW5nKSB7XG4gICAgICAvLyBBY3RvciBhbHJlYWR5IHN0b3BwZWQ7IGRvIG5vdGhpbmdcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIENhbmNlbCBhbGwgZGVsYXllZCBldmVudHNcbiAgICB0aGlzLnN5c3RlbS5zY2hlZHVsZXIuY2FuY2VsQWxsKHRoaXMpO1xuXG4gICAgLy8gVE9ETzogbWFpbGJveC5yZXNldFxuICAgIHRoaXMubWFpbGJveC5jbGVhcigpO1xuICAgIC8vIFRPRE86IGFmdGVyIGBzdG9wYCB3ZSBtdXN0IHByZXBhcmUgb3Vyc2VsdmVzIGZvciByZWNlaXZpbmcgZXZlbnRzIGFnYWluXG4gICAgLy8gZXZlbnRzIHNlbnQgKmFmdGVyKiBzdG9wIHNpZ25hbCBtdXN0IGJlIHF1ZXVlZFxuICAgIC8vIGl0IHNlZW1zIGxpa2UgdGhpcyBzaG91bGQgYmUgdGhlIGNvbW1vbiBiZWhhdmlvciBmb3IgYWxsIG9mIG91ciBjb25zdW1lcnNcbiAgICAvLyBzbyBwZXJoYXBzIHRoaXMgc2hvdWxkIGJlIHVuaWZpZWQgc29tZWhvdyBmb3IgYWxsIG9mIHRoZW1cbiAgICB0aGlzLm1haWxib3ggPSBuZXcgTWFpbGJveCh0aGlzLl9wcm9jZXNzLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPSBQcm9jZXNzaW5nU3RhdHVzLlN0b3BwZWQ7XG4gICAgdGhpcy5zeXN0ZW0uX3VucmVnaXN0ZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9zZW5kKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX3Byb2Nlc3NpbmdTdGF0dXMgPT09IFByb2Nlc3NpbmdTdGF0dXMuU3RvcHBlZCkge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAge1xuICAgICAgICBjb25zdCBldmVudFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV2ZW50KTtcbiAgICAgICAgY29uc29sZS53YXJuKGBFdmVudCBcIiR7ZXZlbnQudHlwZX1cIiB3YXMgc2VudCB0byBzdG9wcGVkIGFjdG9yIFwiJHt0aGlzLmlkfSAoJHt0aGlzLnNlc3Npb25JZH0pXCIuIFRoaXMgYWN0b3IgaGFzIGFscmVhZHkgcmVhY2hlZCBpdHMgZmluYWwgc3RhdGUsIGFuZCB3aWxsIG5vdCB0cmFuc2l0aW9uLlxcbkV2ZW50OiAke2V2ZW50U3RyaW5nfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1haWxib3guZW5xdWV1ZShldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYW4gZXZlbnQgdG8gdGhlIHJ1bm5pbmcgQWN0b3IgdG8gdHJpZ2dlciBhIHRyYW5zaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gc2VuZFxuICAgKi9cbiAgc2VuZChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgZXZlbnQgb2JqZWN0cyBtYXkgYmUgc2VudCB0byBhY3RvcnM7IHVzZSAuc2VuZCh7IHR5cGU6IFwiJHtldmVudH1cIiB9KSBpbnN0ZWFkYCk7XG4gICAgfVxuICAgIHRoaXMuc3lzdGVtLl9yZWxheSh1bmRlZmluZWQsIHRoaXMsIGV2ZW50KTtcbiAgfVxuICBhdHRhY2hEZXZUb29scygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZXZUb29sc1xuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGRldlRvb2xzKSB7XG4gICAgICBjb25zdCByZXNvbHZlZERldlRvb2xzQWRhcHRlciA9IHR5cGVvZiBkZXZUb29scyA9PT0gJ2Z1bmN0aW9uJyA/IGRldlRvb2xzIDogZGV2VG9vbHNBZGFwdGVyO1xuICAgICAgcmVzb2x2ZWREZXZUb29sc0FkYXB0ZXIodGhpcyk7XG4gICAgfVxuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeHN0YXRlJCR0eXBlOiAkJEFDVE9SX1RZUEUsXG4gICAgICBpZDogdGhpcy5pZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogT2J0YWluIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgYWN0b3IsIHdoaWNoIGNhbiBiZSBwZXJzaXN0ZWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBpbnRlcm5hbCBzdGF0ZSBjYW4gYmUgcGVyc2lzdGVkIGZyb20gYW55IGFjdG9yLCBub3Qgb25seSBtYWNoaW5lcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBwZXJzaXN0ZWQgc3RhdGUgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzbmFwc2hvdCBmcm9tXG4gICAqIHtAbGluayBBY3Rvci5nZXRTbmFwc2hvdH0uIFBlcnNpc3RlZCBzdGF0ZSByZXByZXNlbnRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZlxuICAgKiB0aGUgYWN0b3IsIHdoaWxlIHNuYXBzaG90cyByZXByZXNlbnQgdGhlIGFjdG9yJ3MgbGFzdCBlbWl0dGVkIHZhbHVlLlxuICAgKlxuICAgKiBDYW4gYmUgcmVzdG9yZWQgd2l0aCB7QGxpbmsgQWN0b3JPcHRpb25zLnN0YXRlfVxuICAgKiBAc2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL3BlcnNpc3RlbmNlXG4gICAqL1xuXG4gIGdldFBlcnNpc3RlZFNuYXBzaG90KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5sb2dpYy5nZXRQZXJzaXN0ZWRTbmFwc2hvdCh0aGlzLl9zbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgW3N5bWJvbE9ic2VydmFibGVdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYW4gYWN0b3LigJlzIHNuYXBzaG90IHN5bmNocm9ub3VzbHkuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBzbmFwc2hvdCByZXByZXNlbnQgYW4gYWN0b3IncyBsYXN0IGVtaXR0ZWQgdmFsdWUuXG4gICAqXG4gICAqIFdoZW4gYW4gYWN0b3IgcmVjZWl2ZXMgYW4gZXZlbnQsIGl0cyBpbnRlcm5hbCBzdGF0ZSBtYXkgY2hhbmdlLiBBbiBhY3RvclxuICAgKiBtYXkgZW1pdCBhIHNuYXBzaG90IHdoZW4gYSBzdGF0ZSB0cmFuc2l0aW9uIG9jY3Vycy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNvbWUgYWN0b3JzLCBzdWNoIGFzIGNhbGxiYWNrIGFjdG9ycyBnZW5lcmF0ZWQgd2l0aFxuICAgKiBgZnJvbUNhbGxiYWNrYCwgd2lsbCBub3QgZW1pdCBzbmFwc2hvdHMuXG4gICAqIEBzZWUge0BsaW5rIEFjdG9yLnN1YnNjcmliZX0gdG8gc3Vic2NyaWJlIHRvIGFuIGFjdG9y4oCZcyBzbmFwc2hvdCB2YWx1ZXMuXG4gICAqIEBzZWUge0BsaW5rIEFjdG9yLmdldFBlcnNpc3RlZFNuYXBzaG90fSB0byBwZXJzaXN0IHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBhbiBhY3RvciAod2hpY2ggaXMgbW9yZSB0aGFuIGp1c3QgYSBzbmFwc2hvdCkuXG4gICAqL1xuICBnZXRTbmFwc2hvdCgpIHtcbiAgICBpZiAoIXRoaXMuX3NuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNuYXBzaG90IGNhbid0IGJlIHJlYWQgd2hpbGUgdGhlIGFjdG9yIGluaXRpYWxpemVzIGl0c2VsZmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc25hcHNob3Q7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBhY3RvciBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFjdG9yIGxvZ2ljIHdpdGggdGhlIHByb3ZpZGVkXG4gKiBvcHRpb25zLCBpZiBhbnkuXG4gKlxuICogQHJlbWFya3NcbiAqIFdoZW4geW91IGNyZWF0ZSBhbiBhY3RvciBmcm9tIGFjdG9yIGxvZ2ljIHZpYSBgY3JlYXRlQWN0b3IobG9naWMpYCwgeW91XG4gKiBpbXBsaWNpdGx5IGNyZWF0ZSBhbiBhY3RvciBzeXN0ZW0gd2hlcmUgdGhlIGNyZWF0ZWQgYWN0b3IgaXMgdGhlIHJvb3QgYWN0b3IuXG4gKiBBbnkgYWN0b3JzIHNwYXduZWQgZnJvbSB0aGlzIHJvb3QgYWN0b3IgYW5kIGl0cyBkZXNjZW5kYW50cyBhcmUgcGFydCBvZiB0aGF0XG4gKiBhY3RvciBzeXN0ZW0uXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBjcmVhdGVBY3RvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKiBpbXBvcnQgeyBzb21lQWN0b3JMb2dpYyB9IGZyb20gJy4vc29tZUFjdG9yTG9naWMudHMnO1xuICpcbiAqIC8vIENyZWF0aW5nIHRoZSBhY3Rvciwgd2hpY2ggaW1wbGljaXRseSBjcmVhdGVzIGFuIGFjdG9yIHN5c3RlbSB3aXRoIGl0c2VsZiBhcyB0aGUgcm9vdCBhY3RvclxuICogY29uc3QgYWN0b3IgPSBjcmVhdGVBY3Rvcihzb21lQWN0b3JMb2dpYyk7XG4gKlxuICogYWN0b3Iuc3Vic2NyaWJlKChzbmFwc2hvdCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhzbmFwc2hvdCk7XG4gKiB9KTtcbiAqXG4gKiAvLyBBY3RvcnMgbXVzdCBiZSBzdGFydGVkIGJ5IGNhbGxpbmcgYGFjdG9yLnN0YXJ0KClgLCB3aGljaCB3aWxsIGFsc28gc3RhcnQgdGhlIGFjdG9yIHN5c3RlbS5cbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogLy8gQWN0b3JzIGNhbiByZWNlaXZlIGV2ZW50c1xuICogYWN0b3Iuc2VuZCh7IHR5cGU6ICdzb21lRXZlbnQnIH0pO1xuICpcbiAqIC8vIFlvdSBjYW4gc3RvcCByb290IGFjdG9ycyBieSBjYWxsaW5nIGBhY3Rvci5zdG9wKClgLCB3aGljaCB3aWxsIGFsc28gc3RvcCB0aGUgYWN0b3Igc3lzdGVtIGFuZCBhbGwgYWN0b3JzIGluIHRoYXQgc3lzdGVtLlxuICogYWN0b3Iuc3RvcCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGxvZ2ljIC0gVGhlIGFjdG9yIGxvZ2ljIHRvIGNyZWF0ZSBhbiBhY3RvciBmcm9tLiBGb3IgYSBzdGF0ZSBtYWNoaW5lXG4gKiAgIGFjdG9yIGxvZ2ljIGNyZWF0b3IsIHNlZSB7QGxpbmsgY3JlYXRlTWFjaGluZX0uIE90aGVyIGFjdG9yIGxvZ2ljIGNyZWF0b3JzXG4gKiAgIGluY2x1ZGUge0BsaW5rIGZyb21DYWxsYmFja30sIHtAbGluayBmcm9tRXZlbnRPYnNlcnZhYmxlfSxcbiAqICAge0BsaW5rIGZyb21PYnNlcnZhYmxlfSwge0BsaW5rIGZyb21Qcm9taXNlfSwgYW5kIHtAbGluayBmcm9tVHJhbnNpdGlvbn0uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFjdG9yIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWN0b3IobG9naWMsIC4uLltvcHRpb25zXSkge1xuICByZXR1cm4gbmV3IEFjdG9yKGxvZ2ljLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEludGVycHJldGVyIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gbWFjaGluZSB3aXRoIHRoZSBwcm92aWRlZFxuICogb3B0aW9ucywgaWYgYW55LlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgY3JlYXRlQWN0b3JgIGluc3RlYWRcbiAqIEBhbGlhc1xuICovXG5jb25zdCBpbnRlcnByZXQgPSBjcmVhdGVBY3RvcjtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYEFjdG9yYCBpbnN0ZWFkLlxuICogQGFsaWFzXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUNhbmNlbChfLCBzbmFwc2hvdCwgYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIHNlbmRJZFxufSkge1xuICBjb25zdCByZXNvbHZlZFNlbmRJZCA9IHR5cGVvZiBzZW5kSWQgPT09ICdmdW5jdGlvbicgPyBzZW5kSWQoYWN0aW9uQXJncywgYWN0aW9uUGFyYW1zKSA6IHNlbmRJZDtcbiAgcmV0dXJuIFtzbmFwc2hvdCwge1xuICAgIHNlbmRJZDogcmVzb2x2ZWRTZW5kSWRcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVDYW5jZWwoYWN0b3JTY29wZSwgcGFyYW1zKSB7XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGFjdG9yU2NvcGUuc3lzdGVtLnNjaGVkdWxlci5jYW5jZWwoYWN0b3JTY29wZS5zZWxmLCBwYXJhbXMuc2VuZElkKTtcbiAgfSk7XG59XG4vKipcbiAqIENhbmNlbHMgYSBkZWxheWVkIGBzZW5kVG8oLi4uKWAgYWN0aW9uIHRoYXQgaXMgd2FpdGluZyB0byBiZSBleGVjdXRlZC4gVGhlXG4gKiBjYW5jZWxlZCBgc2VuZFRvKC4uLilgIGFjdGlvbiB3aWxsIG5vdCBzZW5kIGl0cyBldmVudCBvciBleGVjdXRlLCB1bmxlc3MgdGhlXG4gKiBgZGVsYXlgIGhhcyBhbHJlYWR5IGVsYXBzZWQgYmVmb3JlIGBjYW5jZWwoLi4uKWAgaXMgY2FsbGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUsIHNlbmRUbywgY2FuY2VsIH0gZnJvbSAneHN0YXRlJztcbiAqXG4gKiBjb25zdCBtYWNoaW5lID0gY3JlYXRlTWFjaGluZSh7XG4gKiAgIC8vIC4uLlxuICogICBvbjoge1xuICogICAgIHNlbmRFdmVudDoge1xuICogICAgICAgYWN0aW9uczogc2VuZFRvKFxuICogICAgICAgICAnc29tZS1hY3RvcicsXG4gKiAgICAgICAgIHsgdHlwZTogJ3NvbWVFdmVudCcgfSxcbiAqICAgICAgICAge1xuICogICAgICAgICAgIGlkOiAnc29tZS1pZCcsXG4gKiAgICAgICAgICAgZGVsYXk6IDEwMDBcbiAqICAgICAgICAgfVxuICogICAgICAgKVxuICogICAgIH0sXG4gKiAgICAgY2FuY2VsRXZlbnQ6IHtcbiAqICAgICAgIGFjdGlvbnM6IGNhbmNlbCgnc29tZS1pZCcpXG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZW5kSWQgVGhlIGBpZGAgb2YgdGhlIGBzZW5kVG8oLi4uKWAgYWN0aW9uIHRvIGNhbmNlbC5cbiAqL1xuZnVuY3Rpb24gY2FuY2VsKHNlbmRJZCkge1xuICBmdW5jdGlvbiBjYW5jZWwoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIGNhbmNlbC50eXBlID0gJ3hzdGF0ZS5jYW5jZWwnO1xuICBjYW5jZWwuc2VuZElkID0gc2VuZElkO1xuICBjYW5jZWwucmVzb2x2ZSA9IHJlc29sdmVDYW5jZWw7XG4gIGNhbmNlbC5leGVjdXRlID0gZXhlY3V0ZUNhbmNlbDtcbiAgcmV0dXJuIGNhbmNlbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNwYXduKGFjdG9yU2NvcGUsIHNuYXBzaG90LCBhY3Rpb25BcmdzLCBfYWN0aW9uUGFyYW1zLCB7XG4gIGlkLFxuICBzeXN0ZW1JZCxcbiAgc3JjLFxuICBpbnB1dCxcbiAgc3luY1NuYXBzaG90XG59KSB7XG4gIGNvbnN0IGxvZ2ljID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyByZXNvbHZlUmVmZXJlbmNlZEFjdG9yKHNuYXBzaG90Lm1hY2hpbmUsIHNyYykgOiBzcmM7XG4gIGNvbnN0IHJlc29sdmVkSWQgPSB0eXBlb2YgaWQgPT09ICdmdW5jdGlvbicgPyBpZChhY3Rpb25BcmdzKSA6IGlkO1xuICBsZXQgYWN0b3JSZWY7XG4gIGxldCByZXNvbHZlZElucHV0ID0gdW5kZWZpbmVkO1xuICBpZiAobG9naWMpIHtcbiAgICByZXNvbHZlZElucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID8gaW5wdXQoe1xuICAgICAgY29udGV4dDogc25hcHNob3QuY29udGV4dCxcbiAgICAgIGV2ZW50OiBhY3Rpb25BcmdzLmV2ZW50LFxuICAgICAgc2VsZjogYWN0b3JTY29wZS5zZWxmXG4gICAgfSkgOiBpbnB1dDtcbiAgICBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICBpZDogcmVzb2x2ZWRJZCxcbiAgICAgIHNyYyxcbiAgICAgIHBhcmVudDogYWN0b3JTY29wZS5zZWxmLFxuICAgICAgc3luY1NuYXBzaG90LFxuICAgICAgc3lzdGVtSWQsXG4gICAgICBpbnB1dDogcmVzb2x2ZWRJbnB1dFxuICAgIH0pO1xuICB9XG4gIGlmICghYWN0b3JSZWYpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC10ZW1wbGF0ZS1leHByZXNzaW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICBgQWN0b3IgdHlwZSAnJHtzcmN9JyBub3QgZm91bmQgaW4gbWFjaGluZSAnJHthY3RvclNjb3BlLmlkfScuYCk7XG4gIH1cbiAgcmV0dXJuIFtjbG9uZU1hY2hpbmVTbmFwc2hvdChzbmFwc2hvdCwge1xuICAgIGNoaWxkcmVuOiB7XG4gICAgICAuLi5zbmFwc2hvdC5jaGlsZHJlbixcbiAgICAgIFtyZXNvbHZlZElkXTogYWN0b3JSZWZcbiAgICB9XG4gIH0pLCB7XG4gICAgaWQsXG4gICAgc3lzdGVtSWQsXG4gICAgYWN0b3JSZWYsXG4gICAgc3JjLFxuICAgIGlucHV0OiByZXNvbHZlZElucHV0XG4gIH0sIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlU3Bhd24oYWN0b3JTY29wZSwge1xuICBhY3RvclJlZlxufSkge1xuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdG9yU2NvcGUuZGVmZXIoKCkgPT4ge1xuICAgIGlmIChhY3RvclJlZi5fcHJvY2Vzc2luZ1N0YXR1cyA9PT0gUHJvY2Vzc2luZ1N0YXR1cy5TdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdG9yUmVmLnN0YXJ0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3Bhd25DaGlsZCguLi5bc3JjLCB7XG4gIGlkLFxuICBzeXN0ZW1JZCxcbiAgaW5wdXQsXG4gIHN5bmNTbmFwc2hvdCA9IGZhbHNlXG59ID0ge31dKSB7XG4gIGZ1bmN0aW9uIHNwYXduQ2hpbGQoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHNwYXduQ2hpbGQudHlwZSA9ICd4c3RhdGUuc3Bhd25DaGlsZCc7XG4gIHNwYXduQ2hpbGQuaWQgPSBpZDtcbiAgc3Bhd25DaGlsZC5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuICBzcGF3bkNoaWxkLnNyYyA9IHNyYztcbiAgc3Bhd25DaGlsZC5pbnB1dCA9IGlucHV0O1xuICBzcGF3bkNoaWxkLnN5bmNTbmFwc2hvdCA9IHN5bmNTbmFwc2hvdDtcbiAgc3Bhd25DaGlsZC5yZXNvbHZlID0gcmVzb2x2ZVNwYXduO1xuICBzcGF3bkNoaWxkLmV4ZWN1dGUgPSBleGVjdXRlU3Bhd247XG4gIHJldHVybiBzcGF3bkNoaWxkO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU3RvcChfLCBzbmFwc2hvdCwgYXJncywgYWN0aW9uUGFyYW1zLCB7XG4gIGFjdG9yUmVmXG59KSB7XG4gIGNvbnN0IGFjdG9yUmVmT3JTdHJpbmcgPSB0eXBlb2YgYWN0b3JSZWYgPT09ICdmdW5jdGlvbicgPyBhY3RvclJlZihhcmdzLCBhY3Rpb25QYXJhbXMpIDogYWN0b3JSZWY7XG4gIGNvbnN0IHJlc29sdmVkQWN0b3JSZWYgPSB0eXBlb2YgYWN0b3JSZWZPclN0cmluZyA9PT0gJ3N0cmluZycgPyBzbmFwc2hvdC5jaGlsZHJlblthY3RvclJlZk9yU3RyaW5nXSA6IGFjdG9yUmVmT3JTdHJpbmc7XG4gIGxldCBjaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICBpZiAocmVzb2x2ZWRBY3RvclJlZikge1xuICAgIGNoaWxkcmVuID0ge1xuICAgICAgLi4uY2hpbGRyZW5cbiAgICB9O1xuICAgIGRlbGV0ZSBjaGlsZHJlbltyZXNvbHZlZEFjdG9yUmVmLmlkXTtcbiAgfVxuICByZXR1cm4gW2Nsb25lTWFjaGluZVNuYXBzaG90KHNuYXBzaG90LCB7XG4gICAgY2hpbGRyZW5cbiAgfSksIHJlc29sdmVkQWN0b3JSZWYsIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBleGVjdXRlU3RvcChhY3RvclNjb3BlLCBhY3RvclJlZikge1xuICBpZiAoIWFjdG9yUmVmKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2UgbmVlZCB0byBlYWdlcmx5IHVucmVnaXN0ZXIgaXQgaGVyZSBzbyBhIG5ldyBhY3RvciB3aXRoIHRoZSBzYW1lIHN5c3RlbUlkIGNhbiBiZSByZWdpc3RlcmVkIGltbWVkaWF0ZWx5XG4gIC8vIHNpbmNlIHdlIGRlZmVyIGFjdHVhbCBzdG9wcGluZyBvZiB0aGUgYWN0b3IgYnV0IHdlIGRvbid0IGRlZmVyIGFjdG9yIGNyZWF0aW9ucyAoYW5kIHdlIGNhbid0IGRvIHRoYXQpXG4gIC8vIHRoaXMgY291bGQgdGhyb3cgb24gYHN5c3RlbUlkYCBjb2xsaXNpb24sIGZvciBleGFtcGxlLCB3aGVuIGRlYWxpbmcgd2l0aCByZWVudGVyaW5nIHRyYW5zaXRpb25zXG4gIGFjdG9yU2NvcGUuc3lzdGVtLl91bnJlZ2lzdGVyKGFjdG9yUmVmKTtcblxuICAvLyB0aGlzIGFsbG93cyB1cyB0byBwcmV2ZW50IGFuIGFjdG9yIGZyb20gYmVpbmcgc3RhcnRlZCBpZiBpdCBnZXRzIHN0b3BwZWQgd2l0aGluIHRoZSBzYW1lIG1hY3Jvc3RlcFxuICAvLyB0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCB3aGVuIHRoZSBpbnZva2luZyBzdGF0ZSBpcyBiZWluZyBleGl0ZWQgaW1tZWRpYXRlbHkgYnkgYW4gYWx3YXlzIHRyYW5zaXRpb25cbiAgaWYgKGFjdG9yUmVmLl9wcm9jZXNzaW5nU3RhdHVzICE9PSBQcm9jZXNzaW5nU3RhdHVzLlJ1bm5pbmcpIHtcbiAgICBhY3RvclNjb3BlLnN0b3BDaGlsZChhY3RvclJlZik7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHN0b3BwaW5nIGEgY2hpbGQgZW5xdWV1ZXMgYSBzdG9wIGV2ZW50IGluIHRoZSBjaGlsZCBhY3RvcidzIG1haWxib3hcbiAgLy8gd2UgbmVlZCBmb3IgYWxsIG9mIHRoZSBhbHJlYWR5IGVucXVldWVkIGV2ZW50cyB0byBiZSBwcm9jZXNzZWQgYmVmb3JlIHdlIHN0b3AgdGhlIGNoaWxkXG4gIC8vIHRoZSBwYXJlbnQgaXRzZWxmIG1pZ2h0IHdhbnQgdG8gc2VuZCBzb21lIGV2ZW50cyB0byBhIGNoaWxkIChmb3IgZXhhbXBsZSBmcm9tIGV4aXQgYWN0aW9ucyBvbiB0aGUgaW52b2tpbmcgc3RhdGUpXG4gIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGlnbm9yZSB0aG9zZSBldmVudHNcbiAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgYWN0b3JTY29wZS5zdG9wQ2hpbGQoYWN0b3JSZWYpO1xuICB9KTtcbn1cbi8qKlxuICogU3RvcHMgYSBjaGlsZCBhY3Rvci5cbiAqXG4gKiBAcGFyYW0gYWN0b3JSZWYgVGhlIGFjdG9yIHRvIHN0b3AuXG4gKi9cbmZ1bmN0aW9uIHN0b3BDaGlsZChhY3RvclJlZikge1xuICBmdW5jdGlvbiBzdG9wKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBzdG9wLnR5cGUgPSAneHN0YXRlLnN0b3BDaGlsZCc7XG4gIHN0b3AuYWN0b3JSZWYgPSBhY3RvclJlZjtcbiAgc3RvcC5yZXNvbHZlID0gcmVzb2x2ZVN0b3A7XG4gIHN0b3AuZXhlY3V0ZSA9IGV4ZWN1dGVTdG9wO1xuICByZXR1cm4gc3RvcDtcbn1cblxuLyoqXG4gKiBTdG9wcyBhIGNoaWxkIGFjdG9yLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgc3RvcENoaWxkKC4uLilgIGluc3RlYWRcbiAqIEBhbGlhc1xuICovXG5jb25zdCBzdG9wID0gc3RvcENoaWxkO1xuXG5mdW5jdGlvbiBjaGVja1N0YXRlSW4oc25hcHNob3QsIF8sIHtcbiAgc3RhdGVWYWx1ZVxufSkge1xuICBpZiAodHlwZW9mIHN0YXRlVmFsdWUgPT09ICdzdHJpbmcnICYmIGlzU3RhdGVJZChzdGF0ZVZhbHVlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHNuYXBzaG90Lm1hY2hpbmUuZ2V0U3RhdGVOb2RlQnlJZChzdGF0ZVZhbHVlKTtcbiAgICByZXR1cm4gc25hcHNob3QuX25vZGVzLnNvbWUoc24gPT4gc24gPT09IHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHNuYXBzaG90Lm1hdGNoZXMoc3RhdGVWYWx1ZSk7XG59XG5mdW5jdGlvbiBzdGF0ZUluKHN0YXRlVmFsdWUpIHtcbiAgZnVuY3Rpb24gc3RhdGVJbigpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIHN0YXRlSW4uY2hlY2sgPSBjaGVja1N0YXRlSW47XG4gIHN0YXRlSW4uc3RhdGVWYWx1ZSA9IHN0YXRlVmFsdWU7XG4gIHJldHVybiBzdGF0ZUluO1xufVxuZnVuY3Rpb24gY2hlY2tOb3Qoc25hcHNob3QsIHtcbiAgY29udGV4dCxcbiAgZXZlbnRcbn0sIHtcbiAgZ3VhcmRzXG59KSB7XG4gIHJldHVybiAhZXZhbHVhdGVHdWFyZChndWFyZHNbMF0sIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiB0aGUgYGd1YXJkYCBwYXNzZWQgdG8gaXRcbiAqIGV2YWx1YXRlcyB0byBgZmFsc2VgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBub3QgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiBmYWxzZVxuICogICB9XG4gKiB9KS5jcmVhdGVNYWNoaW5lKHtcbiAqICAgb246IHtcbiAqICAgICBzb21lRXZlbnQ6IHtcbiAqICAgICAgIGd1YXJkOiBub3QoJ3NvbWVOYW1lZEd1YXJkJyksXG4gKiAgICAgICBhY3Rpb25zOiAoKSA9PiB7XG4gKiAgICAgICAgIC8vIHdpbGwgYmUgZXhlY3V0ZWQgaWYgZ3VhcmQgaW4gYG5vdCguLi4pYFxuICogICAgICAgICAvLyBldmFsdWF0ZXMgdG8gYGZhbHNlYFxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkXG4gKi9cbmZ1bmN0aW9uIG5vdChndWFyZCkge1xuICBmdW5jdGlvbiBub3QoX2FyZ3MsIF9wYXJhbXMpIHtcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgaXNuJ3Qgc3VwcG9zZWQgdG8gYmUgY2FsbGVkYCk7XG4gICAgfVxuICB9XG4gIG5vdC5jaGVjayA9IGNoZWNrTm90O1xuICBub3QuZ3VhcmRzID0gW2d1YXJkXTtcbiAgcmV0dXJuIG5vdDtcbn1cbmZ1bmN0aW9uIGNoZWNrQW5kKHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gZ3VhcmRzLmV2ZXJ5KGd1YXJkID0+IGV2YWx1YXRlR3VhcmQoZ3VhcmQsIGNvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCkpO1xufVxuXG4vKipcbiAqIEhpZ2hlci1vcmRlciBndWFyZCB0aGF0IGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgYWxsIGBndWFyZHNgIHBhc3NlZCB0byBpdFxuICogZXZhbHVhdGUgdG8gYHRydWVgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBhbmQgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IG1hY2hpbmUgPSBzZXR1cCh7XG4gKiAgIGd1YXJkczoge1xuICogICAgIHNvbWVOYW1lZEd1YXJkOiAoKSA9PiB0cnVlXG4gKiAgIH1cbiAqIH0pLmNyZWF0ZU1hY2hpbmUoe1xuICogICBvbjoge1xuICogICAgIHNvbWVFdmVudDoge1xuICogICAgICAgZ3VhcmQ6IGFuZChbKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnZhbHVlID4gMCwgJ3NvbWVOYW1lZEd1YXJkJ10pLFxuICogICAgICAgYWN0aW9uczogKCkgPT4ge1xuICogICAgICAgICAvLyB3aWxsIGJlIGV4ZWN1dGVkIGlmIGFsbCBndWFyZHMgaW4gYGFuZCguLi4pYFxuICogICAgICAgICAvLyBldmFsdWF0ZSB0byB0cnVlXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zIEEgZ3VhcmQgYWN0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBhbmQoZ3VhcmRzKSB7XG4gIGZ1bmN0aW9uIGFuZChfYXJncywgX3BhcmFtcykge1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhpcyBpc24ndCBzdXBwb3NlZCB0byBiZSBjYWxsZWRgKTtcbiAgICB9XG4gIH1cbiAgYW5kLmNoZWNrID0gY2hlY2tBbmQ7XG4gIGFuZC5ndWFyZHMgPSBndWFyZHM7XG4gIHJldHVybiBhbmQ7XG59XG5mdW5jdGlvbiBjaGVja09yKHNuYXBzaG90LCB7XG4gIGNvbnRleHQsXG4gIGV2ZW50XG59LCB7XG4gIGd1YXJkc1xufSkge1xuICByZXR1cm4gZ3VhcmRzLnNvbWUoZ3VhcmQgPT4gZXZhbHVhdGVHdWFyZChndWFyZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KSk7XG59XG5cbi8qKlxuICogSGlnaGVyLW9yZGVyIGd1YXJkIHRoYXQgZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGBndWFyZHNgIHBhc3NlZCB0b1xuICogaXQgZXZhbHVhdGUgdG8gYHRydWVgLlxuICpcbiAqIEBjYXRlZ29yeSBHdWFyZHNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IHNldHVwLCBvciB9IGZyb20gJ3hzdGF0ZSc7XG4gKlxuICogY29uc3QgbWFjaGluZSA9IHNldHVwKHtcbiAqICAgZ3VhcmRzOiB7XG4gKiAgICAgc29tZU5hbWVkR3VhcmQ6ICgpID0+IHRydWVcbiAqICAgfVxuICogfSkuY3JlYXRlTWFjaGluZSh7XG4gKiAgIG9uOiB7XG4gKiAgICAgc29tZUV2ZW50OiB7XG4gKiAgICAgICBndWFyZDogb3IoWyh7IGNvbnRleHQgfSkgPT4gY29udGV4dC52YWx1ZSA+IDAsICdzb21lTmFtZWRHdWFyZCddKSxcbiAqICAgICAgIGFjdGlvbnM6ICgpID0+IHtcbiAqICAgICAgICAgLy8gd2lsbCBiZSBleGVjdXRlZCBpZiBhbnkgb2YgdGhlIGd1YXJkcyBpbiBgb3IoLi4uKWBcbiAqICAgICAgICAgLy8gZXZhbHVhdGUgdG8gdHJ1ZVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBIGd1YXJkIGFjdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gb3IoZ3VhcmRzKSB7XG4gIGZ1bmN0aW9uIG9yKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICBvci5jaGVjayA9IGNoZWNrT3I7XG4gIG9yLmd1YXJkcyA9IGd1YXJkcztcbiAgcmV0dXJuIG9yO1xufVxuXG4vLyBUT0RPOiB0aHJvdyBvbiBjeWNsZXMgKGRlcHRoIGNoZWNrIHNob3VsZCBiZSBlbm91Z2gpXG5mdW5jdGlvbiBldmFsdWF0ZUd1YXJkKGd1YXJkLCBjb250ZXh0LCBldmVudCwgc25hcHNob3QpIHtcbiAgY29uc3Qge1xuICAgIG1hY2hpbmVcbiAgfSA9IHNuYXBzaG90O1xuICBjb25zdCBpc0lubGluZSA9IHR5cGVvZiBndWFyZCA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgcmVzb2x2ZWQgPSBpc0lubGluZSA/IGd1YXJkIDogbWFjaGluZS5pbXBsZW1lbnRhdGlvbnMuZ3VhcmRzW3R5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyBndWFyZCA6IGd1YXJkLnR5cGVdO1xuICBpZiAoIWlzSW5saW5lICYmICFyZXNvbHZlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgR3VhcmQgJyR7dHlwZW9mIGd1YXJkID09PSAnc3RyaW5nJyA/IGd1YXJkIDogZ3VhcmQudHlwZX0nIGlzIG5vdCBpbXBsZW1lbnRlZC4nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgcmVzb2x2ZWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVHdWFyZChyZXNvbHZlZCwgY29udGV4dCwgZXZlbnQsIHNuYXBzaG90KTtcbiAgfVxuICBjb25zdCBndWFyZEFyZ3MgPSB7XG4gICAgY29udGV4dCxcbiAgICBldmVudFxuICB9O1xuICBjb25zdCBndWFyZFBhcmFtcyA9IGlzSW5saW5lIHx8IHR5cGVvZiBndWFyZCA9PT0gJ3N0cmluZycgPyB1bmRlZmluZWQgOiAncGFyYW1zJyBpbiBndWFyZCA/IHR5cGVvZiBndWFyZC5wYXJhbXMgPT09ICdmdW5jdGlvbicgPyBndWFyZC5wYXJhbXMoe1xuICAgIGNvbnRleHQsXG4gICAgZXZlbnRcbiAgfSkgOiBndWFyZC5wYXJhbXMgOiB1bmRlZmluZWQ7XG4gIGlmICghKCdjaGVjaycgaW4gcmVzb2x2ZWQpKSB7XG4gICAgLy8gdGhlIGV4aXN0aW5nIHR5cGUgb2YgYC5ndWFyZHNgIGFzc3VtZXMgbm9uLW51bGxhYmxlIGBURXhwcmVzc2lvbkd1YXJkYFxuICAgIC8vIGlubGluZSBndWFyZHMgZXhwZWN0IGBURXhwcmVzc2lvbkd1YXJkYCB0byBiZSBzZXQgdG8gYHVuZGVmaW5lZGBcbiAgICAvLyBpdCdzIGZpbmUgdG8gY2FzdCB0aGlzIGhlcmUsIG91ciBsb2dpYyBtYWtlcyBzdXJlIHRoYXQgd2UgY2FsbCB0aG9zZSAyIFwidmFyaWFudHNcIiBjb3JyZWN0bHlcbiAgICByZXR1cm4gcmVzb2x2ZWQoZ3VhcmRBcmdzLCBndWFyZFBhcmFtcyk7XG4gIH1cbiAgY29uc3QgYnVpbHRpbkd1YXJkID0gcmVzb2x2ZWQ7XG4gIHJldHVybiBidWlsdGluR3VhcmQuY2hlY2soc25hcHNob3QsIGd1YXJkQXJncywgcmVzb2x2ZWQgLy8gdGhpcyBob2xkcyBhbGwgcGFyYW1zXG4gICk7XG59XG5cbmNvbnN0IGlzQXRvbWljU3RhdGVOb2RlID0gc3RhdGVOb2RlID0+IHN0YXRlTm9kZS50eXBlID09PSAnYXRvbWljJyB8fCBzdGF0ZU5vZGUudHlwZSA9PT0gJ2ZpbmFsJztcbmZ1bmN0aW9uIGdldENoaWxkcmVuKHN0YXRlTm9kZSkge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZU5vZGUuc3RhdGVzKS5maWx0ZXIoc24gPT4gc24udHlwZSAhPT0gJ2hpc3RvcnknKTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlKSB7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICBpZiAodG9TdGF0ZU5vZGUgPT09IHN0YXRlTm9kZSkge1xuICAgIHJldHVybiBhbmNlc3RvcnM7XG4gIH1cblxuICAvLyBhZGQgYWxsIGFuY2VzdG9yc1xuICBsZXQgbSA9IHN0YXRlTm9kZS5wYXJlbnQ7XG4gIHdoaWxlIChtICYmIG0gIT09IHRvU3RhdGVOb2RlKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gobSk7XG4gICAgbSA9IG0ucGFyZW50O1xuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5mdW5jdGlvbiBnZXRBbGxTdGF0ZU5vZGVzKHN0YXRlTm9kZXMpIHtcbiAgY29uc3Qgbm9kZVNldCA9IG5ldyBTZXQoc3RhdGVOb2Rlcyk7XG4gIGNvbnN0IGFkakxpc3QgPSBnZXRBZGpMaXN0KG5vZGVTZXQpO1xuXG4gIC8vIGFkZCBkZXNjZW5kYW50c1xuICBmb3IgKGNvbnN0IHMgb2Ygbm9kZVNldCkge1xuICAgIC8vIGlmIHByZXZpb3VzbHkgYWN0aXZlLCBhZGQgZXhpc3RpbmcgY2hpbGQgbm9kZXNcbiAgICBpZiAocy50eXBlID09PSAnY29tcG91bmQnICYmICghYWRqTGlzdC5nZXQocykgfHwgIWFkakxpc3QuZ2V0KHMpLmxlbmd0aCkpIHtcbiAgICAgIGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKHMpLmZvckVhY2goc24gPT4gbm9kZVNldC5hZGQoc24pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMudHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKHMpKSB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdoaXN0b3J5Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghbm9kZVNldC5oYXMoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsU3RhdGVzID0gZ2V0SW5pdGlhbFN0YXRlTm9kZXNXaXRoVGhlaXJBbmNlc3RvcnMoY2hpbGQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbml0aWFsU3RhdGVOb2RlIG9mIGluaXRpYWxTdGF0ZXMpIHtcbiAgICAgICAgICAgICAgbm9kZVNldC5hZGQoaW5pdGlhbFN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGFsbCBhbmNlc3RvcnNcbiAgZm9yIChjb25zdCBzIG9mIG5vZGVTZXQpIHtcbiAgICBsZXQgbSA9IHMucGFyZW50O1xuICAgIHdoaWxlIChtKSB7XG4gICAgICBub2RlU2V0LmFkZChtKTtcbiAgICAgIG0gPSBtLnBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVTZXQ7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21BZGooYmFzZU5vZGUsIGFkakxpc3QpIHtcbiAgY29uc3QgY2hpbGRTdGF0ZU5vZGVzID0gYWRqTGlzdC5nZXQoYmFzZU5vZGUpO1xuICBpZiAoIWNoaWxkU3RhdGVOb2Rlcykge1xuICAgIHJldHVybiB7fTsgLy8gdG9kbzogZml4P1xuICB9XG4gIGlmIChiYXNlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgY29uc3QgY2hpbGRTdGF0ZU5vZGUgPSBjaGlsZFN0YXRlTm9kZXNbMF07XG4gICAgaWYgKGNoaWxkU3RhdGVOb2RlKSB7XG4gICAgICBpZiAoaXNBdG9taWNTdGF0ZU5vZGUoY2hpbGRTdGF0ZU5vZGUpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFN0YXRlTm9kZS5rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RhdGVWYWx1ZSA9IHt9O1xuICBmb3IgKGNvbnN0IGNoaWxkU3RhdGVOb2RlIG9mIGNoaWxkU3RhdGVOb2Rlcykge1xuICAgIHN0YXRlVmFsdWVbY2hpbGRTdGF0ZU5vZGUua2V5XSA9IGdldFZhbHVlRnJvbUFkaihjaGlsZFN0YXRlTm9kZSwgYWRqTGlzdCk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlVmFsdWU7XG59XG5mdW5jdGlvbiBnZXRBZGpMaXN0KHN0YXRlTm9kZXMpIHtcbiAgY29uc3QgYWRqTGlzdCA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBzIG9mIHN0YXRlTm9kZXMpIHtcbiAgICBpZiAoIWFkakxpc3QuaGFzKHMpKSB7XG4gICAgICBhZGpMaXN0LnNldChzLCBbXSk7XG4gICAgfVxuICAgIGlmIChzLnBhcmVudCkge1xuICAgICAgaWYgKCFhZGpMaXN0LmhhcyhzLnBhcmVudCkpIHtcbiAgICAgICAgYWRqTGlzdC5zZXQocy5wYXJlbnQsIFtdKTtcbiAgICAgIH1cbiAgICAgIGFkakxpc3QuZ2V0KHMucGFyZW50KS5wdXNoKHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWRqTGlzdDtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlVmFsdWUocm9vdE5vZGUsIHN0YXRlTm9kZXMpIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0QWxsU3RhdGVOb2RlcyhzdGF0ZU5vZGVzKTtcbiAgcmV0dXJuIGdldFZhbHVlRnJvbUFkaihyb290Tm9kZSwgZ2V0QWRqTGlzdChjb25maWcpKTtcbn1cbmZ1bmN0aW9uIGlzSW5GaW5hbFN0YXRlKHN0YXRlTm9kZVNldCwgc3RhdGVOb2RlKSB7XG4gIGlmIChzdGF0ZU5vZGUudHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJldHVybiBnZXRDaGlsZHJlbihzdGF0ZU5vZGUpLnNvbWUocyA9PiBzLnR5cGUgPT09ICdmaW5hbCcgJiYgc3RhdGVOb2RlU2V0LmhhcyhzKSk7XG4gIH1cbiAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgcmV0dXJuIGdldENoaWxkcmVuKHN0YXRlTm9kZSkuZXZlcnkoc24gPT4gaXNJbkZpbmFsU3RhdGUoc3RhdGVOb2RlU2V0LCBzbikpO1xuICB9XG4gIHJldHVybiBzdGF0ZU5vZGUudHlwZSA9PT0gJ2ZpbmFsJztcbn1cbmNvbnN0IGlzU3RhdGVJZCA9IHN0ciA9PiBzdHJbMF0gPT09IFNUQVRFX0lERU5USUZJRVI7XG5mdW5jdGlvbiBnZXRDYW5kaWRhdGVzKHN0YXRlTm9kZSwgcmVjZWl2ZWRFdmVudFR5cGUpIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IHN0YXRlTm9kZS50cmFuc2l0aW9ucy5nZXQocmVjZWl2ZWRFdmVudFR5cGUpIHx8IFsuLi5zdGF0ZU5vZGUudHJhbnNpdGlvbnMua2V5cygpXS5maWx0ZXIoZXZlbnREZXNjcmlwdG9yID0+IHtcbiAgICAvLyBjaGVjayBpZiB0cmFuc2l0aW9uIGlzIGEgd2lsZGNhcmQgdHJhbnNpdGlvbixcbiAgICAvLyB3aGljaCBtYXRjaGVzIGFueSBub24tdHJhbnNpZW50IGV2ZW50c1xuICAgIGlmIChldmVudERlc2NyaXB0b3IgPT09IFdJTERDQVJEKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFldmVudERlc2NyaXB0b3IuZW5kc1dpdGgoJy4qJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKC8uKlxcKi4rLy50ZXN0KGV2ZW50RGVzY3JpcHRvcikpIHtcbiAgICAgIGNvbnNvbGUud2FybihgV2lsZGNhcmRzIGNhbiBvbmx5IGJlIHRoZSBsYXN0IHRva2VuIG9mIGFuIGV2ZW50IGRlc2NyaXB0b3IgKGUuZy4sIFwiZXZlbnQuKlwiKSBvciB0aGUgZW50aXJlIGV2ZW50IGRlc2NyaXB0b3IgKFwiKlwiKS4gQ2hlY2sgdGhlIFwiJHtldmVudERlc2NyaXB0b3J9XCIgZXZlbnQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpYWxFdmVudFRva2VucyA9IGV2ZW50RGVzY3JpcHRvci5zcGxpdCgnLicpO1xuICAgIGNvbnN0IGV2ZW50VG9rZW5zID0gcmVjZWl2ZWRFdmVudFR5cGUuc3BsaXQoJy4nKTtcbiAgICBmb3IgKGxldCB0b2tlbkluZGV4ID0gMDsgdG9rZW5JbmRleCA8IHBhcnRpYWxFdmVudFRva2Vucy5sZW5ndGg7IHRva2VuSW5kZXgrKykge1xuICAgICAgY29uc3QgcGFydGlhbEV2ZW50VG9rZW4gPSBwYXJ0aWFsRXZlbnRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgICBjb25zdCBldmVudFRva2VuID0gZXZlbnRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgICBpZiAocGFydGlhbEV2ZW50VG9rZW4gPT09ICcqJykge1xuICAgICAgICBjb25zdCBpc0xhc3RUb2tlbiA9IHRva2VuSW5kZXggPT09IHBhcnRpYWxFdmVudFRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoIWlzTGFzdFRva2VuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBJbmZpeCB3aWxkY2FyZHMgaW4gdHJhbnNpdGlvbiBldmVudHMgYXJlIG5vdCBhbGxvd2VkLiBDaGVjayB0aGUgXCIke2V2ZW50RGVzY3JpcHRvcn1cIiB0cmFuc2l0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0xhc3RUb2tlbjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0aWFsRXZlbnRUb2tlbiAhPT0gZXZlbnRUb2tlbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KS5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKS5mbGF0TWFwKGtleSA9PiBzdGF0ZU5vZGUudHJhbnNpdGlvbnMuZ2V0KGtleSkpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn1cblxuLyoqIEFsbCBkZWxheWVkIHRyYW5zaXRpb25zIGZyb20gdGhlIGNvbmZpZy4gKi9cbmZ1bmN0aW9uIGdldERlbGF5ZWRUcmFuc2l0aW9ucyhzdGF0ZU5vZGUpIHtcbiAgY29uc3QgYWZ0ZXJDb25maWcgPSBzdGF0ZU5vZGUuY29uZmlnLmFmdGVyO1xuICBpZiAoIWFmdGVyQ29uZmlnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IG11dGF0ZUVudHJ5RXhpdCA9IGRlbGF5ID0+IHtcbiAgICBjb25zdCBhZnRlckV2ZW50ID0gY3JlYXRlQWZ0ZXJFdmVudChkZWxheSwgc3RhdGVOb2RlLmlkKTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBhZnRlckV2ZW50LnR5cGU7XG4gICAgc3RhdGVOb2RlLmVudHJ5LnB1c2gocmFpc2UoYWZ0ZXJFdmVudCwge1xuICAgICAgaWQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5XG4gICAgfSkpO1xuICAgIHN0YXRlTm9kZS5leGl0LnB1c2goY2FuY2VsKGV2ZW50VHlwZSkpO1xuICAgIHJldHVybiBldmVudFR5cGU7XG4gIH07XG4gIGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9ucyA9IE9iamVjdC5rZXlzKGFmdGVyQ29uZmlnKS5mbGF0TWFwKGRlbGF5ID0+IHtcbiAgICBjb25zdCBjb25maWdUcmFuc2l0aW9uID0gYWZ0ZXJDb25maWdbZGVsYXldO1xuICAgIGNvbnN0IHJlc29sdmVkVHJhbnNpdGlvbiA9IHR5cGVvZiBjb25maWdUcmFuc2l0aW9uID09PSAnc3RyaW5nJyA/IHtcbiAgICAgIHRhcmdldDogY29uZmlnVHJhbnNpdGlvblxuICAgIH0gOiBjb25maWdUcmFuc2l0aW9uO1xuICAgIGNvbnN0IHJlc29sdmVkRGVsYXkgPSBOdW1iZXIuaXNOYU4oK2RlbGF5KSA/IGRlbGF5IDogK2RlbGF5O1xuICAgIGNvbnN0IGV2ZW50VHlwZSA9IG11dGF0ZUVudHJ5RXhpdChyZXNvbHZlZERlbGF5KTtcbiAgICByZXR1cm4gdG9BcnJheShyZXNvbHZlZFRyYW5zaXRpb24pLm1hcCh0cmFuc2l0aW9uID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSxcbiAgICAgIGRlbGF5OiByZXNvbHZlZERlbGF5XG4gICAgfSkpO1xuICB9KTtcbiAgcmV0dXJuIGRlbGF5ZWRUcmFuc2l0aW9ucy5tYXAoZGVsYXllZFRyYW5zaXRpb24gPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbGF5XG4gICAgfSA9IGRlbGF5ZWRUcmFuc2l0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVsYXllZFRyYW5zaXRpb24uZXZlbnQsIGRlbGF5ZWRUcmFuc2l0aW9uKSxcbiAgICAgIGRlbGF5XG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmb3JtYXRUcmFuc2l0aW9uKHN0YXRlTm9kZSwgZGVzY3JpcHRvciwgdHJhbnNpdGlvbkNvbmZpZykge1xuICBjb25zdCBub3JtYWxpemVkVGFyZ2V0ID0gbm9ybWFsaXplVGFyZ2V0KHRyYW5zaXRpb25Db25maWcudGFyZ2V0KTtcbiAgY29uc3QgcmVlbnRlciA9IHRyYW5zaXRpb25Db25maWcucmVlbnRlciA/PyBmYWxzZTtcbiAgY29uc3QgdGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChzdGF0ZU5vZGUsIG5vcm1hbGl6ZWRUYXJnZXQpO1xuXG4gIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIHBhcnQgb2YgYSBsaW50IHJ1bGUgaW5zdGVhZD9cbiAgaWYgKHRyYW5zaXRpb25Db25maWcuY29uZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU3RhdGUgXCIke3N0YXRlTm9kZS5pZH1cIiBoYXMgZGVjbGFyZWQgXFxgY29uZFxcYCBmb3Igb25lIG9mIGl0cyB0cmFuc2l0aW9ucy4gVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYGd1YXJkXFxgLiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZS5gKTtcbiAgfVxuICBjb25zdCB0cmFuc2l0aW9uID0ge1xuICAgIC4uLnRyYW5zaXRpb25Db25maWcsXG4gICAgYWN0aW9uczogdG9BcnJheSh0cmFuc2l0aW9uQ29uZmlnLmFjdGlvbnMpLFxuICAgIGd1YXJkOiB0cmFuc2l0aW9uQ29uZmlnLmd1YXJkLFxuICAgIHRhcmdldCxcbiAgICBzb3VyY2U6IHN0YXRlTm9kZSxcbiAgICByZWVudGVyLFxuICAgIGV2ZW50VHlwZTogZGVzY3JpcHRvcixcbiAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgc291cmNlOiBgIyR7c3RhdGVOb2RlLmlkfWAsXG4gICAgICB0YXJnZXQ6IHRhcmdldCA/IHRhcmdldC5tYXAodCA9PiBgIyR7dC5pZH1gKSA6IHVuZGVmaW5lZFxuICAgIH0pXG4gIH07XG4gIHJldHVybiB0cmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gZm9ybWF0VHJhbnNpdGlvbnMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICBpZiAoc3RhdGVOb2RlLmNvbmZpZy5vbikge1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBPYmplY3Qua2V5cyhzdGF0ZU5vZGUuY29uZmlnLm9uKSkge1xuICAgICAgaWYgKGRlc2NyaXB0b3IgPT09IE5VTExfRVZFTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdWxsIGV2ZW50cyAoXCJcIikgY2Fubm90IGJlIHNwZWNpZmllZCBhcyBhIHRyYW5zaXRpb24ga2V5LiBVc2UgYGFsd2F5czogeyAuLi4gfWAgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zaXRpb25zQ29uZmlnID0gc3RhdGVOb2RlLmNvbmZpZy5vbltkZXNjcmlwdG9yXTtcbiAgICAgIHRyYW5zaXRpb25zLnNldChkZXNjcmlwdG9yLCB0b1RyYW5zaXRpb25Db25maWdBcnJheSh0cmFuc2l0aW9uc0NvbmZpZykubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbihzdGF0ZU5vZGUsIGRlc2NyaXB0b3IsIHQpKSk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0ZU5vZGUuY29uZmlnLm9uRG9uZSkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmRvbmUuc3RhdGUuJHtzdGF0ZU5vZGUuaWR9YDtcbiAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoc3RhdGVOb2RlLmNvbmZpZy5vbkRvbmUpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICB9XG4gIGZvciAoY29uc3QgaW52b2tlRGVmIG9mIHN0YXRlTm9kZS5pbnZva2UpIHtcbiAgICBpZiAoaW52b2tlRGVmLm9uRG9uZSkge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGB4c3RhdGUuZG9uZS5hY3Rvci4ke2ludm9rZURlZi5pZH1gO1xuICAgICAgdHJhbnNpdGlvbnMuc2V0KGRlc2NyaXB0b3IsIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KGludm9rZURlZi5vbkRvbmUpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgICBpZiAoaW52b2tlRGVmLm9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLmVycm9yLmFjdG9yLiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uRXJyb3IpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgICBpZiAoaW52b2tlRGVmLm9uU25hcHNob3QpIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBgeHN0YXRlLnNuYXBzaG90LiR7aW52b2tlRGVmLmlkfWA7XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVzY3JpcHRvciwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkoaW52b2tlRGVmLm9uU25hcHNob3QpLm1hcCh0ID0+IGZvcm1hdFRyYW5zaXRpb24oc3RhdGVOb2RlLCBkZXNjcmlwdG9yLCB0KSkpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGRlbGF5ZWRUcmFuc2l0aW9uIG9mIHN0YXRlTm9kZS5hZnRlcikge1xuICAgIGxldCBleGlzdGluZyA9IHRyYW5zaXRpb25zLmdldChkZWxheWVkVHJhbnNpdGlvbi5ldmVudFR5cGUpO1xuICAgIGlmICghZXhpc3RpbmcpIHtcbiAgICAgIGV4aXN0aW5nID0gW107XG4gICAgICB0cmFuc2l0aW9ucy5zZXQoZGVsYXllZFRyYW5zaXRpb24uZXZlbnRUeXBlLCBleGlzdGluZyk7XG4gICAgfVxuICAgIGV4aXN0aW5nLnB1c2goZGVsYXllZFRyYW5zaXRpb24pO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9ucztcbn1cbmZ1bmN0aW9uIGZvcm1hdEluaXRpYWxUcmFuc2l0aW9uKHN0YXRlTm9kZSwgX3RhcmdldCkge1xuICBjb25zdCByZXNvbHZlZFRhcmdldCA9IHR5cGVvZiBfdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHN0YXRlTm9kZS5zdGF0ZXNbX3RhcmdldF0gOiBfdGFyZ2V0ID8gc3RhdGVOb2RlLnN0YXRlc1tfdGFyZ2V0LnRhcmdldF0gOiB1bmRlZmluZWQ7XG4gIGlmICghcmVzb2x2ZWRUYXJnZXQgJiYgX3RhcmdldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICBgSW5pdGlhbCBzdGF0ZSBub2RlIFwiJHtfdGFyZ2V0fVwiIG5vdCBmb3VuZCBvbiBwYXJlbnQgc3RhdGUgbm9kZSAjJHtzdGF0ZU5vZGUuaWR9YCk7XG4gIH1cbiAgY29uc3QgdHJhbnNpdGlvbiA9IHtcbiAgICBzb3VyY2U6IHN0YXRlTm9kZSxcbiAgICBhY3Rpb25zOiAhX3RhcmdldCB8fCB0eXBlb2YgX3RhcmdldCA9PT0gJ3N0cmluZycgPyBbXSA6IHRvQXJyYXkoX3RhcmdldC5hY3Rpb25zKSxcbiAgICBldmVudFR5cGU6IG51bGwsXG4gICAgcmVlbnRlcjogZmFsc2UsXG4gICAgdGFyZ2V0OiByZXNvbHZlZFRhcmdldCA/IFtyZXNvbHZlZFRhcmdldF0gOiBbXSxcbiAgICB0b0pTT046ICgpID0+ICh7XG4gICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgc291cmNlOiBgIyR7c3RhdGVOb2RlLmlkfWAsXG4gICAgICB0YXJnZXQ6IHJlc29sdmVkVGFyZ2V0ID8gW2AjJHtyZXNvbHZlZFRhcmdldC5pZH1gXSA6IFtdXG4gICAgfSlcbiAgfTtcbiAgcmV0dXJuIHRyYW5zaXRpb247XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHN0YXRlTm9kZSwgdGFyZ2V0cykge1xuICBpZiAodGFyZ2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gYW4gdW5kZWZpbmVkIHRhcmdldCBzaWduYWxzIHRoYXQgdGhlIHN0YXRlIG5vZGUgc2hvdWxkIG5vdCB0cmFuc2l0aW9uIGZyb20gdGhhdCBzdGF0ZSB3aGVuIHJlY2VpdmluZyB0aGF0IGV2ZW50XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChpc1N0YXRlSWQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQodGFyZ2V0KTtcbiAgICB9XG4gICAgY29uc3QgaXNJbnRlcm5hbFRhcmdldCA9IHRhcmdldFswXSA9PT0gU1RBVEVfREVMSU1JVEVSO1xuICAgIC8vIElmIGludGVybmFsIHRhcmdldCBpcyBkZWZpbmVkIG9uIG1hY2hpbmUsXG4gICAgLy8gZG8gbm90IGluY2x1ZGUgbWFjaGluZSBrZXkgb24gdGFyZ2V0XG4gICAgaWYgKGlzSW50ZXJuYWxUYXJnZXQgJiYgIXN0YXRlTm9kZS5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCB0YXJnZXQuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZFRhcmdldCA9IGlzSW50ZXJuYWxUYXJnZXQgPyBzdGF0ZU5vZGUua2V5ICsgdGFyZ2V0IDogdGFyZ2V0O1xuICAgIGlmIChzdGF0ZU5vZGUucGFyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLnBhcmVudCwgcmVzb2x2ZWRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0U3RhdGVOb2RlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmFuc2l0aW9uIGRlZmluaXRpb24gZm9yIHN0YXRlIG5vZGUgJyR7c3RhdGVOb2RlLmlkfSc6XFxuJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldDogXCIke3RhcmdldH1cIiBpcyBub3QgYSB2YWxpZCB0YXJnZXQgZnJvbSB0aGUgcm9vdCBub2RlLiBEaWQgeW91IG1lYW4gXCIuJHt0YXJnZXR9XCI/YCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRUYXJnZXQgPSBub3JtYWxpemVUYXJnZXQoc3RhdGVOb2RlLmNvbmZpZy50YXJnZXQpO1xuICBpZiAoIW5vcm1hbGl6ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gc3RhdGVOb2RlLnBhcmVudC5pbml0aWFsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGFyZ2V0OiBub3JtYWxpemVkVGFyZ2V0Lm1hcCh0ID0+IHR5cGVvZiB0ID09PSAnc3RyaW5nJyA/IGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUucGFyZW50LCB0KSA6IHQpXG4gIH07XG59XG5mdW5jdGlvbiBpc0hpc3RvcnlOb2RlKHN0YXRlTm9kZSkge1xuICByZXR1cm4gc3RhdGVOb2RlLnR5cGUgPT09ICdoaXN0b3J5Jztcbn1cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzKHN0YXRlTm9kZSkge1xuICBjb25zdCBzdGF0ZXMgPSBnZXRJbml0aWFsU3RhdGVOb2RlcyhzdGF0ZU5vZGUpO1xuICBmb3IgKGNvbnN0IGluaXRpYWxTdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGdldFByb3BlckFuY2VzdG9ycyhpbml0aWFsU3RhdGUsIHN0YXRlTm9kZSkpIHtcbiAgICAgIHN0YXRlcy5hZGQoYW5jZXN0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGVzO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlTm9kZXMoc3RhdGVOb2RlKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gaXRlcihkZXNjU3RhdGVOb2RlKSB7XG4gICAgaWYgKHNldC5oYXMoZGVzY1N0YXRlTm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0LmFkZChkZXNjU3RhdGVOb2RlKTtcbiAgICBpZiAoZGVzY1N0YXRlTm9kZS50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBpdGVyKGRlc2NTdGF0ZU5vZGUuaW5pdGlhbC50YXJnZXRbMF0pO1xuICAgIH0gZWxzZSBpZiAoZGVzY1N0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGRlc2NTdGF0ZU5vZGUpKSB7XG4gICAgICAgIGl0ZXIoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpdGVyKHN0YXRlTm9kZSk7XG4gIHJldHVybiBzZXQ7XG59XG4vKiogUmV0dXJucyB0aGUgY2hpbGQgc3RhdGUgbm9kZSBmcm9tIGl0cyByZWxhdGl2ZSBgc3RhdGVLZXlgLCBvciB0aHJvd3MuICovXG5mdW5jdGlvbiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdGF0ZUtleSkge1xuICBpZiAoaXNTdGF0ZUlkKHN0YXRlS2V5KSkge1xuICAgIHJldHVybiBzdGF0ZU5vZGUubWFjaGluZS5nZXRTdGF0ZU5vZGVCeUlkKHN0YXRlS2V5KTtcbiAgfVxuICBpZiAoIXN0YXRlTm9kZS5zdGF0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byByZXRyaWV2ZSBjaGlsZCBzdGF0ZSAnJHtzdGF0ZUtleX0nIGZyb20gJyR7c3RhdGVOb2RlLmlkfSc7IG5vIGNoaWxkIHN0YXRlcyBleGlzdC5gKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBzdGF0ZU5vZGUuc3RhdGVzW3N0YXRlS2V5XTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlICcke3N0YXRlS2V5fScgZG9lcyBub3QgZXhpc3Qgb24gJyR7c3RhdGVOb2RlLmlkfSdgKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlbGF0aXZlIHN0YXRlIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gYHN0YXRlUGF0aGAsIG9yIHRocm93cy5cbiAqXG4gKiBAcGFyYW0gc3RhdGVQYXRoIFRoZSBzdHJpbmcgb3Igc3RyaW5nIGFycmF5IHJlbGF0aXZlIHBhdGggdG8gdGhlIHN0YXRlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlTm9kZUJ5UGF0aChzdGF0ZU5vZGUsIHN0YXRlUGF0aCkge1xuICBpZiAodHlwZW9mIHN0YXRlUGF0aCA9PT0gJ3N0cmluZycgJiYgaXNTdGF0ZUlkKHN0YXRlUGF0aCkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZS5tYWNoaW5lLmdldFN0YXRlTm9kZUJ5SWQoc3RhdGVQYXRoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIHRyeSBpbmRpdmlkdWFsIHBhdGhzXG4gICAgICAvLyB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBjb25zdCBhcnJheVN0YXRlUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlUGF0aCkuc2xpY2UoKTtcbiAgbGV0IGN1cnJlbnRTdGF0ZU5vZGUgPSBzdGF0ZU5vZGU7XG4gIHdoaWxlIChhcnJheVN0YXRlUGF0aC5sZW5ndGgpIHtcbiAgICBjb25zdCBrZXkgPSBhcnJheVN0YXRlUGF0aC5zaGlmdCgpO1xuICAgIGlmICgha2V5Lmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnRTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoY3VycmVudFN0YXRlTm9kZSwga2V5KTtcbiAgfVxuICByZXR1cm4gY3VycmVudFN0YXRlTm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdGF0ZSBub2RlcyByZXByZXNlbnRlZCBieSB0aGUgY3VycmVudCBzdGF0ZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVWYWx1ZSBUaGUgc3RhdGUgdmFsdWUgb3IgU3RhdGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVOb2RlcyhzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNoaWxkU3RhdGVOb2RlID0gc3RhdGVOb2RlLnN0YXRlc1tzdGF0ZVZhbHVlXTtcbiAgICBpZiAoIWNoaWxkU3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YXRlICcke3N0YXRlVmFsdWV9JyBkb2VzIG5vdCBleGlzdCBvbiAnJHtzdGF0ZU5vZGUuaWR9J2ApO1xuICAgIH1cbiAgICByZXR1cm4gW3N0YXRlTm9kZSwgY2hpbGRTdGF0ZU5vZGVdO1xuICB9XG4gIGNvbnN0IGNoaWxkU3RhdGVLZXlzID0gT2JqZWN0LmtleXMoc3RhdGVWYWx1ZSk7XG4gIGNvbnN0IGNoaWxkU3RhdGVOb2RlcyA9IGNoaWxkU3RhdGVLZXlzLm1hcChzdWJTdGF0ZUtleSA9PiBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSkpLmZpbHRlcihCb29sZWFuKTtcbiAgcmV0dXJuIFtzdGF0ZU5vZGUubWFjaGluZS5yb290LCBzdGF0ZU5vZGVdLmNvbmNhdChjaGlsZFN0YXRlTm9kZXMsIGNoaWxkU3RhdGVLZXlzLnJlZHVjZSgoYWxsU3ViU3RhdGVOb2Rlcywgc3ViU3RhdGVLZXkpID0+IHtcbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgaWYgKCFzdWJTdGF0ZU5vZGUpIHtcbiAgICAgIHJldHVybiBhbGxTdWJTdGF0ZU5vZGVzO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGVzID0gZ2V0U3RhdGVOb2RlcyhzdWJTdGF0ZU5vZGUsIHN0YXRlVmFsdWVbc3ViU3RhdGVLZXldKTtcbiAgICByZXR1cm4gYWxsU3ViU3RhdGVOb2Rlcy5jb25jYXQoc3ViU3RhdGVOb2Rlcyk7XG4gIH0sIFtdKSk7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUpO1xuICBjb25zdCBuZXh0ID0gY2hpbGRTdGF0ZU5vZGUubmV4dChzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uQ29tcG91bmROb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IHN1YlN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlVmFsdWUpO1xuICBjb25zdCBjaGlsZFN0YXRlTm9kZSA9IGdldFN0YXRlTm9kZShzdGF0ZU5vZGUsIHN1YlN0YXRlS2V5c1swXSk7XG4gIGNvbnN0IG5leHQgPSB0cmFuc2l0aW9uTm9kZShjaGlsZFN0YXRlTm9kZSwgc3RhdGVWYWx1ZVtzdWJTdGF0ZUtleXNbMF1dLCBzbmFwc2hvdCwgZXZlbnQpO1xuICBpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KSB7XG4gIGNvbnN0IGFsbElubmVyVHJhbnNpdGlvbnMgPSBbXTtcbiAgZm9yIChjb25zdCBzdWJTdGF0ZUtleSBvZiBPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKSkge1xuICAgIGNvbnN0IHN1YlN0YXRlVmFsdWUgPSBzdGF0ZVZhbHVlW3N1YlN0YXRlS2V5XTtcbiAgICBpZiAoIXN1YlN0YXRlVmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWJTdGF0ZU5vZGUgPSBnZXRTdGF0ZU5vZGUoc3RhdGVOb2RlLCBzdWJTdGF0ZUtleSk7XG4gICAgY29uc3QgaW5uZXJUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25Ob2RlKHN1YlN0YXRlTm9kZSwgc3ViU3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbiAgICBpZiAoaW5uZXJUcmFuc2l0aW9ucykge1xuICAgICAgYWxsSW5uZXJUcmFuc2l0aW9ucy5wdXNoKC4uLmlubmVyVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpZiAoIWFsbElubmVyVHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHN0YXRlTm9kZS5uZXh0KHNuYXBzaG90LCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIGFsbElubmVyVHJhbnNpdGlvbnM7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCkge1xuICAvLyBsZWFmIG5vZGVcbiAgaWYgKHR5cGVvZiBzdGF0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cmFuc2l0aW9uQXRvbWljTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBjb21wb3VuZCBub2RlXG4gIGlmIChPYmplY3Qua2V5cyhzdGF0ZVZhbHVlKS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkNvbXBvdW5kTm9kZShzdGF0ZU5vZGUsIHN0YXRlVmFsdWUsIHNuYXBzaG90LCBldmVudCk7XG4gIH1cblxuICAvLyBwYXJhbGxlbCBub2RlXG4gIHJldHVybiB0cmFuc2l0aW9uUGFyYWxsZWxOb2RlKHN0YXRlTm9kZSwgc3RhdGVWYWx1ZSwgc25hcHNob3QsIGV2ZW50KTtcbn1cbmZ1bmN0aW9uIGdldEhpc3RvcnlOb2RlcyhzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcChrZXkgPT4gc3RhdGVOb2RlLnN0YXRlc1trZXldKS5maWx0ZXIoc24gPT4gc24udHlwZSA9PT0gJ2hpc3RvcnknKTtcbn1cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudChjaGlsZFN0YXRlTm9kZSwgcGFyZW50U3RhdGVOb2RlKSB7XG4gIGxldCBtYXJrZXIgPSBjaGlsZFN0YXRlTm9kZTtcbiAgd2hpbGUgKG1hcmtlci5wYXJlbnQgJiYgbWFya2VyLnBhcmVudCAhPT0gcGFyZW50U3RhdGVOb2RlKSB7XG4gICAgbWFya2VyID0gbWFya2VyLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbWFya2VyLnBhcmVudCA9PT0gcGFyZW50U3RhdGVOb2RlO1xufVxuZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uKHMxLCBzMikge1xuICBjb25zdCBzZXQxID0gbmV3IFNldChzMSk7XG4gIGNvbnN0IHNldDIgPSBuZXcgU2V0KHMyKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldDEpIHtcbiAgICBpZiAoc2V0Mi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2V0Mikge1xuICAgIGlmIChzZXQxLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnMoZW5hYmxlZFRyYW5zaXRpb25zLCBzdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSkge1xuICBjb25zdCBmaWx0ZXJlZFRyYW5zaXRpb25zID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQxIG9mIGVuYWJsZWRUcmFuc2l0aW9ucykge1xuICAgIGxldCB0MVByZWVtcHRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB0MiBvZiBmaWx0ZXJlZFRyYW5zaXRpb25zKSB7XG4gICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uKGNvbXB1dGVFeGl0U2V0KFt0MV0sIHN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKSwgY29tcHV0ZUV4aXRTZXQoW3QyXSwgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpKSkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHQxLnNvdXJjZSwgdDIuc291cmNlKSkge1xuICAgICAgICAgIHRyYW5zaXRpb25zVG9SZW1vdmUuYWRkKHQyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0MVByZWVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0MVByZWVtcHRlZCkge1xuICAgICAgZm9yIChjb25zdCB0MyBvZiB0cmFuc2l0aW9uc1RvUmVtb3ZlKSB7XG4gICAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuZGVsZXRlKHQzKTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcmVkVHJhbnNpdGlvbnMuYWRkKHQxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oZmlsdGVyZWRUcmFuc2l0aW9ucyk7XG59XG5mdW5jdGlvbiBmaW5kTGVhc3RDb21tb25BbmNlc3RvcihzdGF0ZU5vZGVzKSB7XG4gIGNvbnN0IFtoZWFkLCAuLi50YWlsXSA9IHN0YXRlTm9kZXM7XG4gIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgZ2V0UHJvcGVyQW5jZXN0b3JzKGhlYWQsIHVuZGVmaW5lZCkpIHtcbiAgICBpZiAodGFpbC5ldmVyeShzbiA9PiBpc0Rlc2NlbmRhbnQoc24sIGFuY2VzdG9yKSkpIHtcbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgaWYgKCF0cmFuc2l0aW9uLnRhcmdldCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHRhcmdldE5vZGUgb2YgdHJhbnNpdGlvbi50YXJnZXQpIHtcbiAgICBpZiAoaXNIaXN0b3J5Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGhpc3RvcnlWYWx1ZVt0YXJnZXROb2RlLmlkXSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGlzdG9yeVZhbHVlW3RhcmdldE5vZGUuaWRdKSB7XG4gICAgICAgICAgdGFyZ2V0cy5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBnZXRFZmZlY3RpdmVUYXJnZXRTdGF0ZXMocmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbih0YXJnZXROb2RlKSwgaGlzdG9yeVZhbHVlKSkge1xuICAgICAgICAgIHRhcmdldHMuYWRkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldHMuYWRkKHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnRhcmdldHNdO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkRvbWFpbih0cmFuc2l0aW9uLCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVzID0gZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzKHRyYW5zaXRpb24sIGhpc3RvcnlWYWx1ZSk7XG4gIGlmICghdGFyZ2V0U3RhdGVzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghdHJhbnNpdGlvbi5yZWVudGVyICYmIHRhcmdldFN0YXRlcy5ldmVyeSh0YXJnZXQgPT4gdGFyZ2V0ID09PSB0cmFuc2l0aW9uLnNvdXJjZSB8fCBpc0Rlc2NlbmRhbnQodGFyZ2V0LCB0cmFuc2l0aW9uLnNvdXJjZSkpKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24uc291cmNlO1xuICB9XG4gIGNvbnN0IGxjYSA9IGZpbmRMZWFzdENvbW1vbkFuY2VzdG9yKHRhcmdldFN0YXRlcy5jb25jYXQodHJhbnNpdGlvbi5zb3VyY2UpKTtcbiAgaWYgKGxjYSkge1xuICAgIHJldHVybiBsY2E7XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCBpdCdzIGEgcm9vdCB0cmFuc2l0aW9uIHNpbmNlIExDQSBjb3VsZG4ndCBiZSBmb3VuZFxuICBpZiAodHJhbnNpdGlvbi5yZWVudGVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0cmFuc2l0aW9uLnNvdXJjZS5tYWNoaW5lLnJvb3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRXhpdFNldCh0cmFuc2l0aW9ucywgc3RhdGVOb2RlU2V0LCBoaXN0b3J5VmFsdWUpIHtcbiAgY29uc3Qgc3RhdGVzVG9FeGl0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHQgb2YgdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodC50YXJnZXQ/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZG9tYWluID0gZ2V0VHJhbnNpdGlvbkRvbWFpbih0LCBoaXN0b3J5VmFsdWUpO1xuICAgICAgaWYgKHQucmVlbnRlciAmJiB0LnNvdXJjZSA9PT0gZG9tYWluKSB7XG4gICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoZG9tYWluKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc3RhdGVOb2RlIG9mIHN0YXRlTm9kZVNldCkge1xuICAgICAgICBpZiAoaXNEZXNjZW5kYW50KHN0YXRlTm9kZSwgZG9tYWluKSkge1xuICAgICAgICAgIHN0YXRlc1RvRXhpdC5hZGQoc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gWy4uLnN0YXRlc1RvRXhpdF07XG59XG5mdW5jdGlvbiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKHByZXZTdGF0ZU5vZGVzLCBuZXh0U3RhdGVOb2RlU2V0KSB7XG4gIGlmIChwcmV2U3RhdGVOb2Rlcy5sZW5ndGggIT09IG5leHRTdGF0ZU5vZGVTZXQuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGUgb2YgcHJldlN0YXRlTm9kZXMpIHtcbiAgICBpZiAoIW5leHRTdGF0ZU5vZGVTZXQuaGFzKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKiogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNtaWNyb3N0ZXBQcm9jZWR1cmUgKi9cbmZ1bmN0aW9uIG1pY3Jvc3RlcCh0cmFuc2l0aW9ucywgY3VycmVudFNuYXBzaG90LCBhY3RvclNjb3BlLCBldmVudCwgaXNJbml0aWFsLCBpbnRlcm5hbFF1ZXVlKSB7XG4gIGlmICghdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTbmFwc2hvdDtcbiAgfVxuICBjb25zdCBtdXRTdGF0ZU5vZGVTZXQgPSBuZXcgU2V0KGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMpO1xuICBsZXQgaGlzdG9yeVZhbHVlID0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZTtcbiAgY29uc3QgZmlsdGVyZWRUcmFuc2l0aW9ucyA9IHJlbW92ZUNvbmZsaWN0aW5nVHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlKTtcbiAgbGV0IG5leHRTdGF0ZSA9IGN1cnJlbnRTbmFwc2hvdDtcblxuICAvLyBFeGl0IHN0YXRlc1xuICBpZiAoIWlzSW5pdGlhbCkge1xuICAgIFtuZXh0U3RhdGUsIGhpc3RvcnlWYWx1ZV0gPSBleGl0U3RhdGVzKG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUsIGZpbHRlcmVkVHJhbnNpdGlvbnMsIG11dFN0YXRlTm9kZVNldCwgaGlzdG9yeVZhbHVlLCBpbnRlcm5hbFF1ZXVlLCBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yKTtcbiAgfVxuXG4gIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbiBjb250ZW50XG4gIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLmZsYXRNYXAodCA9PiB0LmFjdGlvbnMpLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuXG4gIC8vIEVudGVyIHN0YXRlc1xuICBuZXh0U3RhdGUgPSBlbnRlclN0YXRlcyhuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKTtcbiAgY29uc3QgbmV4dFN0YXRlTm9kZXMgPSBbLi4ubXV0U3RhdGVOb2RlU2V0XTtcbiAgaWYgKG5leHRTdGF0ZS5zdGF0dXMgPT09ICdkb25lJykge1xuICAgIG5leHRTdGF0ZSA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U3RhdGUsIGV2ZW50LCBhY3RvclNjb3BlLCBuZXh0U3RhdGVOb2Rlcy5zb3J0KChhLCBiKSA9PiBiLm9yZGVyIC0gYS5vcmRlcikuZmxhdE1hcChzdGF0ZSA9PiBzdGF0ZS5leGl0KSwgaW50ZXJuYWxRdWV1ZSwgdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhdGNoXG4gIHRyeSB7XG4gICAgaWYgKGhpc3RvcnlWYWx1ZSA9PT0gY3VycmVudFNuYXBzaG90Lmhpc3RvcnlWYWx1ZSAmJiBhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsKGN1cnJlbnRTbmFwc2hvdC5fbm9kZXMsIG11dFN0YXRlTm9kZVNldCkpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZU1hY2hpbmVTbmFwc2hvdChuZXh0U3RhdGUsIHtcbiAgICAgIF9ub2RlczogbmV4dFN0YXRlTm9kZXMsXG4gICAgICBoaXN0b3J5VmFsdWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgb25jZSBwcm9wZXIgZXJyb3IgaGFuZGxpbmcgaXMgaW1wbGVtZW50ZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGF0ZWx5YWkvcmZjcy9wdWxsLzRcbiAgICB0aHJvdyBlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRNYWNoaW5lT3V0cHV0KHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgcm9vdE5vZGUsIHJvb3RDb21wbGV0aW9uTm9kZSkge1xuICBpZiAocm9vdE5vZGUub3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZG9uZVN0YXRlRXZlbnQgPSBjcmVhdGVEb25lU3RhdGVFdmVudChyb290Q29tcGxldGlvbk5vZGUuaWQsIHJvb3RDb21wbGV0aW9uTm9kZS5vdXRwdXQgIT09IHVuZGVmaW5lZCAmJiByb290Q29tcGxldGlvbk5vZGUucGFyZW50ID8gcmVzb2x2ZU91dHB1dChyb290Q29tcGxldGlvbk5vZGUub3V0cHV0LCBzbmFwc2hvdC5jb250ZXh0LCBldmVudCwgYWN0b3JTY29wZS5zZWxmKSA6IHVuZGVmaW5lZCk7XG4gIHJldHVybiByZXNvbHZlT3V0cHV0KHJvb3ROb2RlLm91dHB1dCwgc25hcHNob3QuY29udGV4dCwgZG9uZVN0YXRlRXZlbnQsIGFjdG9yU2NvcGUuc2VsZik7XG59XG5mdW5jdGlvbiBlbnRlclN0YXRlcyhjdXJyZW50U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBmaWx0ZXJlZFRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGludGVybmFsUXVldWUsIGhpc3RvcnlWYWx1ZSwgaXNJbml0aWFsKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRW50ZXIgPSBuZXcgU2V0KCk7XG4gIC8vIHRob3NlIGFyZSBzdGF0ZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IHRhcmdldGVkIG9yIGluZGlyZWN0bHkgdGFyZ2V0ZWQgYnkgdGhlIGV4cGxpY2l0IHRhcmdldFxuICAvLyBpbiBvdGhlciB3b3JkcywgdGhvc2UgYXJlIHN0YXRlcyBmb3Igd2hpY2ggaW5pdGlhbCBhY3Rpb25zIHNob3VsZCBiZSBleGVjdXRlZFxuICAvLyB3aGVuIHdlIHRhcmdldCBgI2RlZXBfY2hpbGRgIGluaXRpYWwgYWN0aW9ucyBvZiBpdHMgYW5jZXN0b3JzIHNob3VsZG4ndCBiZSBleGVjdXRlZFxuICBjb25zdCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkgPSBuZXcgU2V0KCk7XG4gIGNvbXB1dGVFbnRyeVNldChmaWx0ZXJlZFRyYW5zaXRpb25zLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG5cbiAgLy8gSW4gdGhlIGluaXRpYWwgc3RhdGUsIHRoZSByb290IHN0YXRlIG5vZGUgaXMgXCJlbnRlcmVkXCIuXG4gIGlmIChpc0luaXRpYWwpIHtcbiAgICBzdGF0ZXNGb3JEZWZhdWx0RW50cnkuYWRkKGN1cnJlbnRTbmFwc2hvdC5tYWNoaW5lLnJvb3QpO1xuICB9XG4gIGNvbnN0IGNvbXBsZXRlZE5vZGVzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHN0YXRlTm9kZVRvRW50ZXIgb2YgWy4uLnN0YXRlc1RvRW50ZXJdLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKSkge1xuICAgIG11dFN0YXRlTm9kZVNldC5hZGQoc3RhdGVOb2RlVG9FbnRlcik7XG4gICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuXG4gICAgLy8gQWRkIGVudHJ5IGFjdGlvbnNcbiAgICBhY3Rpb25zLnB1c2goLi4uc3RhdGVOb2RlVG9FbnRlci5lbnRyeSk7XG4gICAgZm9yIChjb25zdCBpbnZva2VEZWYgb2Ygc3RhdGVOb2RlVG9FbnRlci5pbnZva2UpIHtcbiAgICAgIGFjdGlvbnMucHVzaChzcGF3bkNoaWxkKGludm9rZURlZi5zcmMsIHtcbiAgICAgICAgLi4uaW52b2tlRGVmLFxuICAgICAgICBzeW5jU25hcHNob3Q6ICEhaW52b2tlRGVmLm9uU25hcHNob3RcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5oYXMoc3RhdGVOb2RlVG9FbnRlcikpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxBY3Rpb25zID0gc3RhdGVOb2RlVG9FbnRlci5pbml0aWFsLmFjdGlvbnM7XG4gICAgICBhY3Rpb25zLnB1c2goLi4uaW5pdGlhbEFjdGlvbnMpO1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgaW50ZXJuYWxRdWV1ZSwgc3RhdGVOb2RlVG9FbnRlci5pbnZva2UubWFwKGludm9rZURlZiA9PiBpbnZva2VEZWYuaWQpKTtcbiAgICBpZiAoc3RhdGVOb2RlVG9FbnRlci50eXBlID09PSAnZmluYWwnKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGF0ZU5vZGVUb0VudGVyLnBhcmVudDtcbiAgICAgIGxldCBhbmNlc3Rvck1hcmtlciA9IHBhcmVudD8udHlwZSA9PT0gJ3BhcmFsbGVsJyA/IHBhcmVudCA6IHBhcmVudD8ucGFyZW50O1xuICAgICAgbGV0IHJvb3RDb21wbGV0aW9uTm9kZSA9IGFuY2VzdG9yTWFya2VyIHx8IHN0YXRlTm9kZVRvRW50ZXI7XG4gICAgICBpZiAocGFyZW50Py50eXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgIGludGVybmFsUXVldWUucHVzaChjcmVhdGVEb25lU3RhdGVFdmVudChwYXJlbnQuaWQsIHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0ICE9PSB1bmRlZmluZWQgPyByZXNvbHZlT3V0cHV0KHN0YXRlTm9kZVRvRW50ZXIub3V0cHV0LCBuZXh0U25hcHNob3QuY29udGV4dCwgZXZlbnQsIGFjdG9yU2NvcGUuc2VsZikgOiB1bmRlZmluZWQpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhbmNlc3Rvck1hcmtlcj8udHlwZSA9PT0gJ3BhcmFsbGVsJyAmJiAhY29tcGxldGVkTm9kZXMuaGFzKGFuY2VzdG9yTWFya2VyKSAmJiBpc0luRmluYWxTdGF0ZShtdXRTdGF0ZU5vZGVTZXQsIGFuY2VzdG9yTWFya2VyKSkge1xuICAgICAgICBjb21wbGV0ZWROb2Rlcy5hZGQoYW5jZXN0b3JNYXJrZXIpO1xuICAgICAgICBpbnRlcm5hbFF1ZXVlLnB1c2goY3JlYXRlRG9uZVN0YXRlRXZlbnQoYW5jZXN0b3JNYXJrZXIuaWQpKTtcbiAgICAgICAgcm9vdENvbXBsZXRpb25Ob2RlID0gYW5jZXN0b3JNYXJrZXI7XG4gICAgICAgIGFuY2VzdG9yTWFya2VyID0gYW5jZXN0b3JNYXJrZXIucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKGFuY2VzdG9yTWFya2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmV4dFNuYXBzaG90ID0gY2xvbmVNYWNoaW5lU25hcHNob3QobmV4dFNuYXBzaG90LCB7XG4gICAgICAgIHN0YXR1czogJ2RvbmUnLFxuICAgICAgICBvdXRwdXQ6IGdldE1hY2hpbmVPdXRwdXQobmV4dFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgbmV4dFNuYXBzaG90Lm1hY2hpbmUucm9vdCwgcm9vdENvbXBsZXRpb25Ob2RlKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlRW50cnlTZXQodHJhbnNpdGlvbnMsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKSB7XG4gIGZvciAoY29uc3QgdCBvZiB0cmFuc2l0aW9ucykge1xuICAgIGNvbnN0IGRvbWFpbiA9IGdldFRyYW5zaXRpb25Eb21haW4odCwgaGlzdG9yeVZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdC50YXJnZXQgfHwgW10pIHtcbiAgICAgIGlmICghaXNIaXN0b3J5Tm9kZShzKSAmJiAoXG4gICAgICAvLyBpZiB0aGUgdGFyZ2V0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCB3aWxsICpkZWZpbml0ZWx5KiBiZSBlbnRlcmVkXG4gICAgICB0LnNvdXJjZSAhPT0gcyB8fFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBkb21haW4gY2FuJ3QgbGllIHdpdGhpbiB0aGUgc291cmNlXG4gICAgICAvLyBpZiBpdCdzIGRpZmZlcmVudCB0aGFuIHRoZSBzb3VyY2UgdGhlbiBpdCdzIG91dHNpZGUgb2YgaXQgYW5kIGl0IG1lYW5zIHRoYXQgdGhlIHRhcmdldCBoYXMgdG8gYmUgZW50ZXJlZCBhcyB3ZWxsXG4gICAgICB0LnNvdXJjZSAhPT0gZG9tYWluIHx8XG4gICAgICAvLyByZWVudGVyaW5nIHRyYW5zaXRpb25zIGFsd2F5cyBlbnRlciB0aGUgdGFyZ2V0LCBldmVuIGlmIGl0J3MgdGhlIHNvdXJjZSBpdHNlbGZcbiAgICAgIHQucmVlbnRlcikpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQocyk7XG4gICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQocyk7XG4gICAgICB9XG4gICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFN0YXRlcyA9IGdldEVmZmVjdGl2ZVRhcmdldFN0YXRlcyh0LCBoaXN0b3J5VmFsdWUpO1xuICAgIGZvciAoY29uc3QgcyBvZiB0YXJnZXRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IGdldFByb3BlckFuY2VzdG9ycyhzLCBkb21haW4pO1xuICAgICAgaWYgKGRvbWFpbj8udHlwZSA9PT0gJ3BhcmFsbGVsJykge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChkb21haW4pO1xuICAgICAgfVxuICAgICAgYWRkQW5jZXN0b3JTdGF0ZXNUb0VudGVyKHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBhbmNlc3RvcnMsICF0LnNvdXJjZS5wYXJlbnQgJiYgdC5yZWVudGVyID8gdW5kZWZpbmVkIDogZG9tYWluKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKHN0YXRlTm9kZSwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpIHtcbiAgaWYgKGlzSGlzdG9yeU5vZGUoc3RhdGVOb2RlKSkge1xuICAgIGlmIChoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXSkge1xuICAgICAgY29uc3QgaGlzdG9yeVN0YXRlTm9kZXMgPSBoaXN0b3J5VmFsdWVbc3RhdGVOb2RlLmlkXTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5U3RhdGVOb2Rlcykge1xuICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChzKTtcbiAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIocywgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIHN0YXRlc1RvRW50ZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzIG9mIGhpc3RvcnlTdGF0ZU5vZGVzKSB7XG4gICAgICAgIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzLCBzdGF0ZU5vZGUucGFyZW50LCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiA9IHJlc29sdmVIaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24oc3RhdGVOb2RlKTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBoaXN0b3J5RGVmYXVsdFRyYW5zaXRpb24udGFyZ2V0KSB7XG4gICAgICAgIHN0YXRlc1RvRW50ZXIuYWRkKHMpO1xuICAgICAgICBpZiAoaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uID09PSBzdGF0ZU5vZGUucGFyZW50Py5pbml0aWFsKSB7XG4gICAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChzdGF0ZU5vZGUucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlcihzLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uLnRhcmdldCkge1xuICAgICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIocywgc3RhdGVOb2RlLnBhcmVudCwgc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhdGVOb2RlLnR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIGNvbnN0IFtpbml0aWFsU3RhdGVdID0gc3RhdGVOb2RlLmluaXRpYWwudGFyZ2V0O1xuICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGluaXRpYWxTdGF0ZSkpIHtcbiAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LmFkZChpbml0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICBhZGRQcm9wZXJBbmNlc3RvclN0YXRlc1RvRW50ZXIoaW5pdGlhbFN0YXRlLCBzdGF0ZU5vZGUsIHN0YXRlc1RvRW50ZXIsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlTm9kZS50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlKS5maWx0ZXIoc24gPT4gIWlzSGlzdG9yeU5vZGUoc24pKSkge1xuICAgICAgICAgIGlmICghWy4uLnN0YXRlc1RvRW50ZXJdLnNvbWUocyA9PiBpc0Rlc2NlbmRhbnQocywgY2hpbGQpKSkge1xuICAgICAgICAgICAgaWYgKCFpc0hpc3RvcnlOb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgICBzdGF0ZXNUb0VudGVyLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgIHN0YXRlc0ZvckRlZmF1bHRFbnRyeS5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRGVzY2VuZGFudFN0YXRlc1RvRW50ZXIoY2hpbGQsIGhpc3RvcnlWYWx1ZSwgc3RhdGVzRm9yRGVmYXVsdEVudHJ5LCBzdGF0ZXNUb0VudGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgYW5jZXN0b3JzLCByZWVudHJhbmN5RG9tYWluKSB7XG4gIGZvciAoY29uc3QgYW5jIG9mIGFuY2VzdG9ycykge1xuICAgIGlmICghcmVlbnRyYW5jeURvbWFpbiB8fCBpc0Rlc2NlbmRhbnQoYW5jLCByZWVudHJhbmN5RG9tYWluKSkge1xuICAgICAgc3RhdGVzVG9FbnRlci5hZGQoYW5jKTtcbiAgICB9XG4gICAgaWYgKGFuYy50eXBlID09PSAncGFyYWxsZWwnKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGdldENoaWxkcmVuKGFuYykuZmlsdGVyKHNuID0+ICFpc0hpc3RvcnlOb2RlKHNuKSkpIHtcbiAgICAgICAgaWYgKCFbLi4uc3RhdGVzVG9FbnRlcl0uc29tZShzID0+IGlzRGVzY2VuZGFudChzLCBjaGlsZCkpKSB7XG4gICAgICAgICAgc3RhdGVzVG9FbnRlci5hZGQoY2hpbGQpO1xuICAgICAgICAgIGFkZERlc2NlbmRhbnRTdGF0ZXNUb0VudGVyKGNoaWxkLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSwgc3RhdGVzVG9FbnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFByb3BlckFuY2VzdG9yU3RhdGVzVG9FbnRlcihzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlLCBzdGF0ZXNUb0VudGVyLCBoaXN0b3J5VmFsdWUsIHN0YXRlc0ZvckRlZmF1bHRFbnRyeSkge1xuICBhZGRBbmNlc3RvclN0YXRlc1RvRW50ZXIoc3RhdGVzVG9FbnRlciwgaGlzdG9yeVZhbHVlLCBzdGF0ZXNGb3JEZWZhdWx0RW50cnksIGdldFByb3BlckFuY2VzdG9ycyhzdGF0ZU5vZGUsIHRvU3RhdGVOb2RlKSk7XG59XG5mdW5jdGlvbiBleGl0U3RhdGVzKGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSwgaW50ZXJuYWxRdWV1ZSwgX2FjdGlvbkV4ZWN1dG9yKSB7XG4gIGxldCBuZXh0U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gIGNvbnN0IHN0YXRlc1RvRXhpdCA9IGNvbXB1dGVFeGl0U2V0KHRyYW5zaXRpb25zLCBtdXRTdGF0ZU5vZGVTZXQsIGhpc3RvcnlWYWx1ZSk7XG4gIHN0YXRlc1RvRXhpdC5zb3J0KChhLCBiKSA9PiBiLm9yZGVyIC0gYS5vcmRlcik7XG4gIGxldCBjaGFuZ2VkSGlzdG9yeTtcblxuICAvLyBGcm9tIFNDWE1MIGFsZ29yaXRobTogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NjeG1sLyNleGl0U3RhdGVzXG4gIGZvciAoY29uc3QgZXhpdFN0YXRlTm9kZSBvZiBzdGF0ZXNUb0V4aXQpIHtcbiAgICBmb3IgKGNvbnN0IGhpc3RvcnlOb2RlIG9mIGdldEhpc3RvcnlOb2RlcyhleGl0U3RhdGVOb2RlKSkge1xuICAgICAgbGV0IHByZWRpY2F0ZTtcbiAgICAgIGlmIChoaXN0b3J5Tm9kZS5oaXN0b3J5ID09PSAnZGVlcCcpIHtcbiAgICAgICAgcHJlZGljYXRlID0gc24gPT4gaXNBdG9taWNTdGF0ZU5vZGUoc24pICYmIGlzRGVzY2VuZGFudChzbiwgZXhpdFN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVkaWNhdGUgPSBzbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNuLnBhcmVudCA9PT0gZXhpdFN0YXRlTm9kZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNoYW5nZWRIaXN0b3J5ID8/PSB7XG4gICAgICAgIC4uLmhpc3RvcnlWYWx1ZVxuICAgICAgfTtcbiAgICAgIGNoYW5nZWRIaXN0b3J5W2hpc3RvcnlOb2RlLmlkXSA9IEFycmF5LmZyb20obXV0U3RhdGVOb2RlU2V0KS5maWx0ZXIocHJlZGljYXRlKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBzIG9mIHN0YXRlc1RvRXhpdCkge1xuICAgIG5leHRTbmFwc2hvdCA9IHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChuZXh0U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlLCBbLi4ucy5leGl0LCAuLi5zLmludm9rZS5tYXAoZGVmID0+IHN0b3BDaGlsZChkZWYuaWQpKV0sIGludGVybmFsUXVldWUsIHVuZGVmaW5lZCk7XG4gICAgbXV0U3RhdGVOb2RlU2V0LmRlbGV0ZShzKTtcbiAgfVxuICByZXR1cm4gW25leHRTbmFwc2hvdCwgY2hhbmdlZEhpc3RvcnkgfHwgaGlzdG9yeVZhbHVlXTtcbn1cbmZ1bmN0aW9uIGdldEFjdGlvbihtYWNoaW5lLCBhY3Rpb25UeXBlKSB7XG4gIHJldHVybiBtYWNoaW5lLmltcGxlbWVudGF0aW9ucy5hY3Rpb25zW2FjdGlvblR5cGVdO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywgZXh0cmEsIHJldHJpZXMpIHtcbiAgY29uc3Qge1xuICAgIG1hY2hpbmVcbiAgfSA9IGN1cnJlbnRTbmFwc2hvdDtcbiAgbGV0IGludGVybWVkaWF0ZVNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90O1xuICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgY29uc3QgaXNJbmxpbmUgPSB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nO1xuICAgIGNvbnN0IHJlc29sdmVkQWN0aW9uID0gaXNJbmxpbmUgPyBhY3Rpb24gOlxuICAgIC8vIHRoZSBleGlzdGluZyB0eXBlIG9mIGAuYWN0aW9uc2AgYXNzdW1lcyBub24tbnVsbGFibGUgYFRFeHByZXNzaW9uQWN0aW9uYFxuICAgIC8vIGl0J3MgZmluZSB0byBjYXN0IHRoaXMgaGVyZSB0byBnZXQgYSBjb21tb24gdHlwZSBhbmQgbGFjayBvZiBlcnJvcnMgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGVcbiAgICAvLyBvdXIgbG9naWMgYmVsb3cgbWFrZXMgc3VyZSB0aGF0IHdlIGNhbGwgdGhvc2UgMiBcInZhcmlhbnRzXCIgY29ycmVjdGx5XG5cbiAgICBnZXRBY3Rpb24obWFjaGluZSwgdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyBhY3Rpb24gOiBhY3Rpb24udHlwZSk7XG4gICAgY29uc3QgYWN0aW9uQXJncyA9IHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudCxcbiAgICAgIHNlbGY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIHN5c3RlbTogYWN0b3JTY29wZS5zeXN0ZW1cbiAgICB9O1xuICAgIGNvbnN0IGFjdGlvblBhcmFtcyA9IGlzSW5saW5lIHx8IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gdW5kZWZpbmVkIDogJ3BhcmFtcycgaW4gYWN0aW9uID8gdHlwZW9mIGFjdGlvbi5wYXJhbXMgPT09ICdmdW5jdGlvbicgPyBhY3Rpb24ucGFyYW1zKHtcbiAgICAgIGNvbnRleHQ6IGludGVybWVkaWF0ZVNuYXBzaG90LmNvbnRleHQsXG4gICAgICBldmVudFxuICAgIH0pIDogYWN0aW9uLnBhcmFtcyA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXJlc29sdmVkQWN0aW9uIHx8ICEoJ3Jlc29sdmUnIGluIHJlc29sdmVkQWN0aW9uKSkge1xuICAgICAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvcih7XG4gICAgICAgIHR5cGU6IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gYWN0aW9uIDogdHlwZW9mIGFjdGlvbiA9PT0gJ29iamVjdCcgPyBhY3Rpb24udHlwZSA6IGFjdGlvbi5uYW1lIHx8ICcoYW5vbnltb3VzKScsXG4gICAgICAgIGluZm86IGFjdGlvbkFyZ3MsXG4gICAgICAgIHBhcmFtczogYWN0aW9uUGFyYW1zLFxuICAgICAgICBleGVjOiByZXNvbHZlZEFjdGlvblxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYnVpbHRpbkFjdGlvbiA9IHJlc29sdmVkQWN0aW9uO1xuICAgIGNvbnN0IFtuZXh0U3RhdGUsIHBhcmFtcywgYWN0aW9uc10gPSBidWlsdGluQWN0aW9uLnJlc29sdmUoYWN0b3JTY29wZSwgaW50ZXJtZWRpYXRlU25hcHNob3QsIGFjdGlvbkFyZ3MsIGFjdGlvblBhcmFtcywgcmVzb2x2ZWRBY3Rpb24sXG4gICAgLy8gdGhpcyBob2xkcyBhbGwgcGFyYW1zXG4gICAgZXh0cmEpO1xuICAgIGludGVybWVkaWF0ZVNuYXBzaG90ID0gbmV4dFN0YXRlO1xuICAgIGlmICgncmV0cnlSZXNvbHZlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICByZXRyaWVzPy5wdXNoKFtidWlsdGluQWN0aW9uLCBwYXJhbXNdKTtcbiAgICB9XG4gICAgaWYgKCdleGVjdXRlJyBpbiBidWlsdGluQWN0aW9uKSB7XG4gICAgICBhY3RvclNjb3BlLmFjdGlvbkV4ZWN1dG9yKHtcbiAgICAgICAgdHlwZTogYnVpbHRpbkFjdGlvbi50eXBlLFxuICAgICAgICBpbmZvOiBhY3Rpb25BcmdzLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGV4ZWM6IGJ1aWx0aW5BY3Rpb24uZXhlY3V0ZS5iaW5kKG51bGwsIGFjdG9yU2NvcGUsIHBhcmFtcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYWN0aW9ucykge1xuICAgICAgaW50ZXJtZWRpYXRlU25hcHNob3QgPSByZXNvbHZlQW5kRXhlY3V0ZUFjdGlvbnNXaXRoQ29udGV4dChpbnRlcm1lZGlhdGVTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGV4dHJhLCByZXRyaWVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVybWVkaWF0ZVNuYXBzaG90O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KGN1cnJlbnRTbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIGFjdGlvbnMsIGludGVybmFsUXVldWUsIGRlZmVycmVkQWN0b3JJZHMpIHtcbiAgY29uc3QgcmV0cmllcyA9IGRlZmVycmVkQWN0b3JJZHMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbmV4dFN0YXRlID0gcmVzb2x2ZUFuZEV4ZWN1dGVBY3Rpb25zV2l0aENvbnRleHQoY3VycmVudFNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgYWN0aW9ucywge1xuICAgIGludGVybmFsUXVldWUsXG4gICAgZGVmZXJyZWRBY3Rvcklkc1xuICB9LCByZXRyaWVzKTtcbiAgcmV0cmllcz8uZm9yRWFjaCgoW2J1aWx0aW5BY3Rpb24sIHBhcmFtc10pID0+IHtcbiAgICBidWlsdGluQWN0aW9uLnJldHJ5UmVzb2x2ZShhY3RvclNjb3BlLCBuZXh0U3RhdGUsIHBhcmFtcyk7XG4gIH0pO1xuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuZnVuY3Rpb24gbWFjcm9zdGVwKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSkge1xuICBpZiAoZXZlbnQudHlwZSA9PT0gV0lMRENBUkQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGV2ZW50IGNhbm5vdCBoYXZlIHRoZSB3aWxkY2FyZCB0eXBlICgnJHtXSUxEQ0FSRH0nKWApO1xuICB9XG4gIGxldCBuZXh0U25hcHNob3QgPSBzbmFwc2hvdDtcbiAgY29uc3QgbWljcm9zdGF0ZXMgPSBbXTtcbiAgZnVuY3Rpb24gYWRkTWljcm9zdGF0ZShtaWNyb3N0YXRlLCBldmVudCwgdHJhbnNpdGlvbnMpIHtcbiAgICBhY3RvclNjb3BlLnN5c3RlbS5fc2VuZEluc3BlY3Rpb25FdmVudCh7XG4gICAgICB0eXBlOiAnQHhzdGF0ZS5taWNyb3N0ZXAnLFxuICAgICAgYWN0b3JSZWY6IGFjdG9yU2NvcGUuc2VsZixcbiAgICAgIGV2ZW50LFxuICAgICAgc25hcHNob3Q6IG1pY3Jvc3RhdGUsXG4gICAgICBfdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zXG4gICAgfSk7XG4gICAgbWljcm9zdGF0ZXMucHVzaChtaWNyb3N0YXRlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBzdG9wIGV2ZW50XG4gIGlmIChldmVudC50eXBlID09PSBYU1RBVEVfU1RPUCkge1xuICAgIG5leHRTbmFwc2hvdCA9IGNsb25lTWFjaGluZVNuYXBzaG90KHN0b3BDaGlsZHJlbihuZXh0U25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSwge1xuICAgICAgc3RhdHVzOiAnc3RvcHBlZCdcbiAgICB9KTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgZXZlbnQsIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgc25hcHNob3Q6IG5leHRTbmFwc2hvdCxcbiAgICAgIG1pY3Jvc3RhdGVzXG4gICAgfTtcbiAgfVxuICBsZXQgbmV4dEV2ZW50ID0gZXZlbnQ7XG5cbiAgLy8gQXNzdW1lIHRoZSBzdGF0ZSBpcyBhdCByZXN0IChubyByYWlzZWQgZXZlbnRzKVxuICAvLyBEZXRlcm1pbmUgdGhlIG5leHQgc3RhdGUgYmFzZWQgb24gdGhlIG5leHQgbWljcm9zdGVwXG4gIGlmIChuZXh0RXZlbnQudHlwZSAhPT0gWFNUQVRFX0lOSVQpIHtcbiAgICBjb25zdCBjdXJyZW50RXZlbnQgPSBuZXh0RXZlbnQ7XG4gICAgY29uc3QgaXNFcnIgPSBpc0Vycm9yQWN0b3JFdmVudChjdXJyZW50RXZlbnQpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25zID0gc2VsZWN0VHJhbnNpdGlvbnMoY3VycmVudEV2ZW50LCBuZXh0U25hcHNob3QpO1xuICAgIGlmIChpc0VyciAmJiAhdHJhbnNpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbGlrZWx5IG9ubHkgYWxsb3cgdHJhbnNpdGlvbnMgc2VsZWN0ZWQgYnkgdmVyeSBleHBsaWNpdCBkZXNjcmlwdG9yc1xuICAgICAgLy8gYCpgIHNob3VsZG4ndCBiZSBtYXRjaGVkLCBsaWtlbHkgYHhzdGF0ZS5lcnJvci4qYCBzaG91bGRudCBiZSBlaXRoZXJcbiAgICAgIC8vIHNpbWlsYXJseSBgeHN0YXRlLmVycm9yLmFjdG9yLipgIGFuZCBgeHN0YXRlLmVycm9yLmFjdG9yLnRvZG8uKmAgaGF2ZSB0byBiZSBjb25zaWRlcmVkIHRvb1xuICAgICAgbmV4dFNuYXBzaG90ID0gY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIHtcbiAgICAgICAgc3RhdHVzOiAnZXJyb3InLFxuICAgICAgICBlcnJvcjogY3VycmVudEV2ZW50LmVycm9yXG4gICAgICB9KTtcbiAgICAgIGFkZE1pY3Jvc3RhdGUobmV4dFNuYXBzaG90LCBjdXJyZW50RXZlbnQsIFtdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNuYXBzaG90OiBuZXh0U25hcHNob3QsXG4gICAgICAgIG1pY3Jvc3RhdGVzXG4gICAgICB9O1xuICAgIH1cbiAgICBuZXh0U25hcHNob3QgPSBtaWNyb3N0ZXAodHJhbnNpdGlvbnMsIHNuYXBzaG90LCBhY3RvclNjb3BlLCBuZXh0RXZlbnQsIGZhbHNlLFxuICAgIC8vIGlzSW5pdGlhbFxuICAgIGludGVybmFsUXVldWUpO1xuICAgIGFkZE1pY3Jvc3RhdGUobmV4dFNuYXBzaG90LCBjdXJyZW50RXZlbnQsIHRyYW5zaXRpb25zKTtcbiAgfVxuICBsZXQgc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMgPSB0cnVlO1xuICB3aGlsZSAobmV4dFNuYXBzaG90LnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICBsZXQgZW5hYmxlZFRyYW5zaXRpb25zID0gc2hvdWxkU2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMgPyBzZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyhuZXh0U25hcHNob3QsIG5leHRFdmVudCkgOiBbXTtcblxuICAgIC8vIGV2ZW50bGVzcyB0cmFuc2l0aW9ucyBzaG91bGQgYWx3YXlzIGJlIHNlbGVjdGVkIGFmdGVyIHNlbGVjdGluZyAqcmVndWxhciogdHJhbnNpdGlvbnNcbiAgICAvLyBieSBhc3NpZ25pbmcgYHVuZGVmaW5lZGAgdG8gYHByZXZpb3VzU3RhdGVgIHdlIGVuc3VyZSB0aGF0IGBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9uc2AgZ2V0cyBhbHdheXMgY29tcHV0ZWQgdG8gdHJ1ZSBpbiBzdWNoIGEgY2FzZVxuICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBlbmFibGVkVHJhbnNpdGlvbnMubGVuZ3RoID8gbmV4dFNuYXBzaG90IDogdW5kZWZpbmVkO1xuICAgIGlmICghZW5hYmxlZFRyYW5zaXRpb25zLmxlbmd0aCkge1xuICAgICAgaWYgKCFpbnRlcm5hbFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5leHRFdmVudCA9IGludGVybmFsUXVldWUuc2hpZnQoKTtcbiAgICAgIGVuYWJsZWRUcmFuc2l0aW9ucyA9IHNlbGVjdFRyYW5zaXRpb25zKG5leHRFdmVudCwgbmV4dFNuYXBzaG90KTtcbiAgICB9XG4gICAgbmV4dFNuYXBzaG90ID0gbWljcm9zdGVwKGVuYWJsZWRUcmFuc2l0aW9ucywgbmV4dFNuYXBzaG90LCBhY3RvclNjb3BlLCBuZXh0RXZlbnQsIGZhbHNlLCBpbnRlcm5hbFF1ZXVlKTtcbiAgICBzaG91bGRTZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyA9IG5leHRTbmFwc2hvdCAhPT0gcHJldmlvdXNTdGF0ZTtcbiAgICBhZGRNaWNyb3N0YXRlKG5leHRTbmFwc2hvdCwgbmV4dEV2ZW50LCBlbmFibGVkVHJhbnNpdGlvbnMpO1xuICB9XG4gIGlmIChuZXh0U25hcHNob3Quc3RhdHVzICE9PSAnYWN0aXZlJykge1xuICAgIHN0b3BDaGlsZHJlbihuZXh0U25hcHNob3QsIG5leHRFdmVudCwgYWN0b3JTY29wZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzbmFwc2hvdDogbmV4dFNuYXBzaG90LFxuICAgIG1pY3Jvc3RhdGVzXG4gIH07XG59XG5mdW5jdGlvbiBzdG9wQ2hpbGRyZW4obmV4dFN0YXRlLCBldmVudCwgYWN0b3JTY29wZSkge1xuICByZXR1cm4gcmVzb2x2ZUFjdGlvbnNBbmRDb250ZXh0KG5leHRTdGF0ZSwgZXZlbnQsIGFjdG9yU2NvcGUsIE9iamVjdC52YWx1ZXMobmV4dFN0YXRlLmNoaWxkcmVuKS5tYXAoY2hpbGQgPT4gc3RvcENoaWxkKGNoaWxkKSksIFtdLCB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gc2VsZWN0VHJhbnNpdGlvbnMoZXZlbnQsIG5leHRTdGF0ZSkge1xuICByZXR1cm4gbmV4dFN0YXRlLm1hY2hpbmUuZ2V0VHJhbnNpdGlvbkRhdGEobmV4dFN0YXRlLCBldmVudCk7XG59XG5mdW5jdGlvbiBzZWxlY3RFdmVudGxlc3NUcmFuc2l0aW9ucyhuZXh0U3RhdGUsIGV2ZW50KSB7XG4gIGNvbnN0IGVuYWJsZWRUcmFuc2l0aW9uU2V0ID0gbmV3IFNldCgpO1xuICBjb25zdCBhdG9taWNTdGF0ZXMgPSBuZXh0U3RhdGUuX25vZGVzLmZpbHRlcihpc0F0b21pY1N0YXRlTm9kZSk7XG4gIGZvciAoY29uc3Qgc3RhdGVOb2RlIG9mIGF0b21pY1N0YXRlcykge1xuICAgIGxvb3A6IGZvciAoY29uc3QgcyBvZiBbc3RhdGVOb2RlXS5jb25jYXQoZ2V0UHJvcGVyQW5jZXN0b3JzKHN0YXRlTm9kZSwgdW5kZWZpbmVkKSkpIHtcbiAgICAgIGlmICghcy5hbHdheXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2Ygcy5hbHdheXMpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24uZ3VhcmQgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZUd1YXJkKHRyYW5zaXRpb24uZ3VhcmQsIG5leHRTdGF0ZS5jb250ZXh0LCBldmVudCwgbmV4dFN0YXRlKSkge1xuICAgICAgICAgIGVuYWJsZWRUcmFuc2l0aW9uU2V0LmFkZCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZW1vdmVDb25mbGljdGluZ1RyYW5zaXRpb25zKEFycmF5LmZyb20oZW5hYmxlZFRyYW5zaXRpb25TZXQpLCBuZXcgU2V0KG5leHRTdGF0ZS5fbm9kZXMpLCBuZXh0U3RhdGUuaGlzdG9yeVZhbHVlKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIHBhcnRpYWwgc3RhdGUgdmFsdWUgd2l0aCBpdHMgZnVsbCByZXByZXNlbnRhdGlvbiBpbiB0aGUgc3RhdGVcbiAqIG5vZGUncyBtYWNoaW5lLlxuICpcbiAqIEBwYXJhbSBzdGF0ZVZhbHVlIFRoZSBwYXJ0aWFsIHN0YXRlIHZhbHVlIHRvIHJlc29sdmUuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTdGF0ZVZhbHVlKHJvb3ROb2RlLCBzdGF0ZVZhbHVlKSB7XG4gIGNvbnN0IGFsbFN0YXRlTm9kZXMgPSBnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXMocm9vdE5vZGUsIHN0YXRlVmFsdWUpKTtcbiAgcmV0dXJuIGdldFN0YXRlVmFsdWUocm9vdE5vZGUsIFsuLi5hbGxTdGF0ZU5vZGVzXSk7XG59XG5cbmZ1bmN0aW9uIGlzTWFjaGluZVNuYXBzaG90KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgJ21hY2hpbmUnIGluIHZhbHVlICYmICd2YWx1ZScgaW4gdmFsdWU7XG59XG5jb25zdCBtYWNoaW5lU25hcHNob3RNYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyh0ZXN0VmFsdWUpIHtcbiAgcmV0dXJuIG1hdGNoZXNTdGF0ZSh0ZXN0VmFsdWUsIHRoaXMudmFsdWUpO1xufTtcbmNvbnN0IG1hY2hpbmVTbmFwc2hvdEhhc1RhZyA9IGZ1bmN0aW9uIGhhc1RhZyh0YWcpIHtcbiAgcmV0dXJuIHRoaXMudGFncy5oYXModGFnKTtcbn07XG5jb25zdCBtYWNoaW5lU25hcHNob3RDYW4gPSBmdW5jdGlvbiBjYW4oZXZlbnQpIHtcbiAgaWYgKCF0aGlzLm1hY2hpbmUpIHtcbiAgICBjb25zb2xlLndhcm4oYHN0YXRlLmNhbiguLi4pIHVzZWQgb3V0c2lkZSBvZiBhIG1hY2hpbmUtY3JlYXRlZCBTdGF0ZSBvYmplY3Q7IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLmApO1xuICB9XG4gIGNvbnN0IHRyYW5zaXRpb25EYXRhID0gdGhpcy5tYWNoaW5lLmdldFRyYW5zaXRpb25EYXRhKHRoaXMsIGV2ZW50KTtcbiAgcmV0dXJuICEhdHJhbnNpdGlvbkRhdGE/Lmxlbmd0aCAmJlxuICAvLyBDaGVjayB0aGF0IGF0IGxlYXN0IG9uZSB0cmFuc2l0aW9uIGlzIG5vdCBmb3JiaWRkZW5cbiAgdHJhbnNpdGlvbkRhdGEuc29tZSh0ID0+IHQudGFyZ2V0ICE9PSB1bmRlZmluZWQgfHwgdC5hY3Rpb25zLmxlbmd0aCk7XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90VG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBjb25zdCB7XG4gICAgX25vZGVzOiBub2RlcyxcbiAgICB0YWdzLFxuICAgIG1hY2hpbmUsXG4gICAgZ2V0TWV0YSxcbiAgICB0b0pTT04sXG4gICAgY2FuLFxuICAgIGhhc1RhZyxcbiAgICBtYXRjaGVzLFxuICAgIC4uLmpzb25WYWx1ZXNcbiAgfSA9IHRoaXM7XG4gIHJldHVybiB7XG4gICAgLi4uanNvblZhbHVlcyxcbiAgICB0YWdzOiBBcnJheS5mcm9tKHRhZ3MpXG4gIH07XG59O1xuY29uc3QgbWFjaGluZVNuYXBzaG90R2V0TWV0YSA9IGZ1bmN0aW9uIGdldE1ldGEoKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlcy5yZWR1Y2UoKGFjYywgc3RhdGVOb2RlKSA9PiB7XG4gICAgaWYgKHN0YXRlTm9kZS5tZXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFjY1tzdGF0ZU5vZGUuaWRdID0gc3RhdGVOb2RlLm1ldGE7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVNYWNoaW5lU25hcHNob3QoY29uZmlnLCBtYWNoaW5lKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzOiBjb25maWcuc3RhdHVzLFxuICAgIG91dHB1dDogY29uZmlnLm91dHB1dCxcbiAgICBlcnJvcjogY29uZmlnLmVycm9yLFxuICAgIG1hY2hpbmUsXG4gICAgY29udGV4dDogY29uZmlnLmNvbnRleHQsXG4gICAgX25vZGVzOiBjb25maWcuX25vZGVzLFxuICAgIHZhbHVlOiBnZXRTdGF0ZVZhbHVlKG1hY2hpbmUucm9vdCwgY29uZmlnLl9ub2RlcyksXG4gICAgdGFnczogbmV3IFNldChjb25maWcuX25vZGVzLmZsYXRNYXAoc24gPT4gc24udGFncykpLFxuICAgIGNoaWxkcmVuOiBjb25maWcuY2hpbGRyZW4sXG4gICAgaGlzdG9yeVZhbHVlOiBjb25maWcuaGlzdG9yeVZhbHVlIHx8IHt9LFxuICAgIG1hdGNoZXM6IG1hY2hpbmVTbmFwc2hvdE1hdGNoZXMsXG4gICAgaGFzVGFnOiBtYWNoaW5lU25hcHNob3RIYXNUYWcsXG4gICAgY2FuOiBtYWNoaW5lU25hcHNob3RDYW4sXG4gICAgZ2V0TWV0YTogbWFjaGluZVNuYXBzaG90R2V0TWV0YSxcbiAgICB0b0pTT046IG1hY2hpbmVTbmFwc2hvdFRvSlNPTlxuICB9O1xufVxuZnVuY3Rpb24gY2xvbmVNYWNoaW5lU25hcHNob3Qoc25hcHNob3QsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgIC4uLnNuYXBzaG90LFxuICAgIC4uLmNvbmZpZ1xuICB9LCBzbmFwc2hvdC5tYWNoaW5lKTtcbn1cbmZ1bmN0aW9uIGdldFBlcnNpc3RlZFNuYXBzaG90KHNuYXBzaG90LCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBfbm9kZXM6IG5vZGVzLFxuICAgIHRhZ3MsXG4gICAgbWFjaGluZSxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0LFxuICAgIGNhbixcbiAgICBoYXNUYWcsXG4gICAgbWF0Y2hlcyxcbiAgICBnZXRNZXRhLFxuICAgIHRvSlNPTixcbiAgICAuLi5qc29uVmFsdWVzXG4gIH0gPSBzbmFwc2hvdDtcbiAgY29uc3QgY2hpbGRyZW5Kc29uID0ge307XG4gIGZvciAoY29uc3QgaWQgaW4gY2hpbGRyZW4pIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2lkXTtcbiAgICBpZiAodHlwZW9mIGNoaWxkLnNyYyAhPT0gJ3N0cmluZycgJiYgKCFvcHRpb25zIHx8ICEoJ19fdW5zYWZlQWxsb3dJbmxpbmVBY3RvcnMnIGluIG9wdGlvbnMpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpbmxpbmUgY2hpbGQgYWN0b3IgY2Fubm90IGJlIHBlcnNpc3RlZC4nKTtcbiAgICB9XG4gICAgY2hpbGRyZW5Kc29uW2lkXSA9IHtcbiAgICAgIHNuYXBzaG90OiBjaGlsZC5nZXRQZXJzaXN0ZWRTbmFwc2hvdChvcHRpb25zKSxcbiAgICAgIHNyYzogY2hpbGQuc3JjLFxuICAgICAgc3lzdGVtSWQ6IGNoaWxkLl9zeXN0ZW1JZCxcbiAgICAgIHN5bmNTbmFwc2hvdDogY2hpbGQuX3N5bmNTbmFwc2hvdFxuICAgIH07XG4gIH1cbiAgY29uc3QgcGVyc2lzdGVkID0ge1xuICAgIC4uLmpzb25WYWx1ZXMsXG4gICAgY29udGV4dDogcGVyc2lzdENvbnRleHQoY29udGV4dCksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuSnNvblxuICB9O1xuICByZXR1cm4gcGVyc2lzdGVkO1xufVxuZnVuY3Rpb24gcGVyc2lzdENvbnRleHQoY29udGV4dFBhcnQpIHtcbiAgbGV0IGNvcHk7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbnRleHRQYXJ0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoJ3Nlc3Npb25JZCcgaW4gdmFsdWUgJiYgJ3NlbmQnIGluIHZhbHVlICYmICdyZWYnIGluIHZhbHVlKSB7XG4gICAgICAgIGNvcHkgPz89IEFycmF5LmlzQXJyYXkoY29udGV4dFBhcnQpID8gY29udGV4dFBhcnQuc2xpY2UoKSA6IHtcbiAgICAgICAgICAuLi5jb250ZXh0UGFydFxuICAgICAgICB9O1xuICAgICAgICBjb3B5W2tleV0gPSB7XG4gICAgICAgICAgeHN0YXRlJCR0eXBlOiAkJEFDVE9SX1RZUEUsXG4gICAgICAgICAgaWQ6IHZhbHVlLmlkXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwZXJzaXN0Q29udGV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgY29weSA/Pz0gQXJyYXkuaXNBcnJheShjb250ZXh0UGFydCkgPyBjb250ZXh0UGFydC5zbGljZSgpIDoge1xuICAgICAgICAgICAgLi4uY29udGV4dFBhcnRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvcHlba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29weSA/PyBjb250ZXh0UGFydDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJhaXNlKF8sIHNuYXBzaG90LCBhcmdzLCBhY3Rpb25QYXJhbXMsIHtcbiAgZXZlbnQ6IGV2ZW50T3JFeHByLFxuICBpZCxcbiAgZGVsYXlcbn0sIHtcbiAgaW50ZXJuYWxRdWV1ZVxufSkge1xuICBjb25zdCBkZWxheXNNYXAgPSBzbmFwc2hvdC5tYWNoaW5lLmltcGxlbWVudGF0aW9ucy5kZWxheXM7XG4gIGlmICh0eXBlb2YgZXZlbnRPckV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtdGVtcGxhdGUtZXhwcmVzc2lvbnNcbiAgICBgT25seSBldmVudCBvYmplY3RzIG1heSBiZSB1c2VkIHdpdGggcmFpc2U7IHVzZSByYWlzZSh7IHR5cGU6IFwiJHtldmVudE9yRXhwcn1cIiB9KSBpbnN0ZWFkYCk7XG4gIH1cbiAgY29uc3QgcmVzb2x2ZWRFdmVudCA9IHR5cGVvZiBldmVudE9yRXhwciA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3JFeHByKGFyZ3MsIGFjdGlvblBhcmFtcykgOiBldmVudE9yRXhwcjtcbiAgbGV0IHJlc29sdmVkRGVsYXk7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY29uZmlnRGVsYXkgPSBkZWxheXNNYXAgJiYgZGVsYXlzTWFwW2RlbGF5XTtcbiAgICByZXNvbHZlZERlbGF5ID0gdHlwZW9mIGNvbmZpZ0RlbGF5ID09PSAnZnVuY3Rpb24nID8gY29uZmlnRGVsYXkoYXJncywgYWN0aW9uUGFyYW1zKSA6IGNvbmZpZ0RlbGF5O1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmVkRGVsYXkgPSB0eXBlb2YgZGVsYXkgPT09ICdmdW5jdGlvbicgPyBkZWxheShhcmdzLCBhY3Rpb25QYXJhbXMpIDogZGVsYXk7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXNvbHZlZERlbGF5ICE9PSAnbnVtYmVyJykge1xuICAgIGludGVybmFsUXVldWUucHVzaChyZXNvbHZlZEV2ZW50KTtcbiAgfVxuICByZXR1cm4gW3NuYXBzaG90LCB7XG4gICAgZXZlbnQ6IHJlc29sdmVkRXZlbnQsXG4gICAgaWQsXG4gICAgZGVsYXk6IHJlc29sdmVkRGVsYXlcbiAgfSwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVSYWlzZShhY3RvclNjb3BlLCBwYXJhbXMpIHtcbiAgY29uc3Qge1xuICAgIGV2ZW50LFxuICAgIGRlbGF5LFxuICAgIGlkXG4gIH0gPSBwYXJhbXM7XG4gIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgYWN0b3JTY29wZS5kZWZlcigoKSA9PiB7XG4gICAgICBjb25zdCBzZWxmID0gYWN0b3JTY29wZS5zZWxmO1xuICAgICAgYWN0b3JTY29wZS5zeXN0ZW0uc2NoZWR1bGVyLnNjaGVkdWxlKHNlbGYsIHNlbGYsIGV2ZW50LCBkZWxheSwgaWQpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxufVxuLyoqXG4gKiBSYWlzZXMgYW4gZXZlbnQuIFRoaXMgcGxhY2VzIHRoZSBldmVudCBpbiB0aGUgaW50ZXJuYWwgZXZlbnQgcXVldWUsIHNvIHRoYXRcbiAqIHRoZSBldmVudCBpcyBpbW1lZGlhdGVseSBjb25zdW1lZCBieSB0aGUgbWFjaGluZSBpbiB0aGUgY3VycmVudCBzdGVwLlxuICpcbiAqIEBwYXJhbSBldmVudFR5cGUgVGhlIGV2ZW50IHRvIHJhaXNlLlxuICovXG5mdW5jdGlvbiByYWlzZShldmVudE9yRXhwciwgb3B0aW9ucykge1xuICBpZiAoZXhlY3V0aW5nQ3VzdG9tQWN0aW9uKSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gYWN0aW9ucyBzaG91bGQgbm90IGNhbGwgYHJhaXNlKClgIGRpcmVjdGx5LCBhcyBpdCBpcyBub3QgaW1wZXJhdGl2ZS4gU2VlIGh0dHBzOi8vc3RhdGVseS5haS9kb2NzL2FjdGlvbnMjYnVpbHQtaW4tYWN0aW9ucyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICB9XG4gIGZ1bmN0aW9uIHJhaXNlKF9hcmdzLCBfcGFyYW1zKSB7XG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGlzIGlzbid0IHN1cHBvc2VkIHRvIGJlIGNhbGxlZGApO1xuICAgIH1cbiAgfVxuICByYWlzZS50eXBlID0gJ3hzdGF0ZS5yYWlzZSc7XG4gIHJhaXNlLmV2ZW50ID0gZXZlbnRPckV4cHI7XG4gIHJhaXNlLmlkID0gb3B0aW9ucz8uaWQ7XG4gIHJhaXNlLmRlbGF5ID0gb3B0aW9ucz8uZGVsYXk7XG4gIHJhaXNlLnJlc29sdmUgPSByZXNvbHZlUmFpc2U7XG4gIHJhaXNlLmV4ZWN1dGUgPSBleGVjdXRlUmFpc2U7XG4gIHJldHVybiByYWlzZTtcbn1cblxuZXhwb3J0IHsgJCRBQ1RPUl9UWVBFIGFzICQsIGNyZWF0ZUFjdG9yIGFzIEEsIEFjdG9yIGFzIEIsIGludGVycHJldCBhcyBDLCBhbmQgYXMgRCwgbm90IGFzIEUsIG9yIGFzIEYsIHN0YXRlSW4gYXMgRywgaXNNYWNoaW5lU25hcHNob3QgYXMgSCwgZ2V0QWxsT3duRXZlbnREZXNjcmlwdG9ycyBhcyBJLCBtYXRjaGVzU3RhdGUgYXMgSiwgcGF0aFRvU3RhdGVWYWx1ZSBhcyBLLCB0b09ic2VydmVyIGFzIEwsIGNhbmNlbCBhcyBNLCBOVUxMX0VWRU5UIGFzIE4sIHJhaXNlIGFzIE8sIHNwYXduQ2hpbGQgYXMgUCwgc3RvcCBhcyBRLCBzdG9wQ2hpbGQgYXMgUiwgU1RBVEVfREVMSU1JVEVSIGFzIFMsIFByb2Nlc3NpbmdTdGF0dXMgYXMgVCwgY2xvbmVNYWNoaW5lU25hcHNob3QgYXMgVSwgZXhlY3V0aW5nQ3VzdG9tQWN0aW9uIGFzIFYsIFhTVEFURV9FUlJPUiBhcyBXLCBYU1RBVEVfU1RPUCBhcyBYLCBjcmVhdGVFcnJvckFjdG9yRXZlbnQgYXMgWSwgdG9UcmFuc2l0aW9uQ29uZmlnQXJyYXkgYXMgYSwgZm9ybWF0VHJhbnNpdGlvbiBhcyBiLCBjcmVhdGVJbnZva2VJZCBhcyBjLCBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiBhcyBkLCBldmFsdWF0ZUd1YXJkIGFzIGUsIGZvcm1hdFRyYW5zaXRpb25zIGFzIGYsIGdldERlbGF5ZWRUcmFuc2l0aW9ucyBhcyBnLCBnZXRDYW5kaWRhdGVzIGFzIGgsIGdldEFsbFN0YXRlTm9kZXMgYXMgaSwgZ2V0U3RhdGVOb2RlcyBhcyBqLCBjcmVhdGVNYWNoaW5lU25hcHNob3QgYXMgaywgaXNJbkZpbmFsU3RhdGUgYXMgbCwgbWFwVmFsdWVzIGFzIG0sIG1hY3Jvc3RlcCBhcyBuLCB0cmFuc2l0aW9uTm9kZSBhcyBvLCByZXNvbHZlQWN0aW9uc0FuZENvbnRleHQgYXMgcCwgY3JlYXRlSW5pdEV2ZW50IGFzIHEsIHJlc29sdmVTdGF0ZVZhbHVlIGFzIHIsIG1pY3Jvc3RlcCBhcyBzLCB0b0FycmF5IGFzIHQsIGdldEluaXRpYWxTdGF0ZU5vZGVzIGFzIHUsIHRvU3RhdGVQYXRoIGFzIHYsIGlzU3RhdGVJZCBhcyB3LCBnZXRTdGF0ZU5vZGVCeVBhdGggYXMgeCwgZ2V0UGVyc2lzdGVkU25hcHNob3QgYXMgeSwgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciBhcyB6IH07XG4iXSwibmFtZXMiOlsiZGV2VG9vbHNBZGFwdGVyIiwiTWFpbGJveCIsInN0YXJ0IiwiX2FjdGl2ZSIsImZsdXNoIiwiY2xlYXIiLCJfY3VycmVudCIsIm5leHQiLCJfbGFzdCIsImVucXVldWUiLCJldmVudCIsImVucXVldWVkIiwidmFsdWUiLCJjb25zdW1lZCIsIl9wcm9jZXNzIiwiY29uc3RydWN0b3IiLCJTVEFURV9ERUxJTUlURVIiLCJUQVJHRVRMRVNTX0tFWSIsIk5VTExfRVZFTlQiLCJTVEFURV9JREVOVElGSUVSIiwiV0lMRENBUkQiLCJYU1RBVEVfSU5JVCIsIlhTVEFURV9FUlJPUiIsIlhTVEFURV9TVE9QIiwiY3JlYXRlQWZ0ZXJFdmVudCIsImRlbGF5UmVmIiwiaWQiLCJ0eXBlIiwiY3JlYXRlRG9uZVN0YXRlRXZlbnQiLCJvdXRwdXQiLCJjcmVhdGVEb25lQWN0b3JFdmVudCIsImludm9rZUlkIiwiYWN0b3JJZCIsImNyZWF0ZUVycm9yQWN0b3JFdmVudCIsImVycm9yIiwiY3JlYXRlSW5pdEV2ZW50IiwiaW5wdXQiLCJyZXBvcnRVbmhhbmRsZWRFcnJvciIsImVyciIsInNldFRpbWVvdXQiLCJzeW1ib2xPYnNlcnZhYmxlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsIm1hdGNoZXNTdGF0ZSIsInBhcmVudFN0YXRlSWQiLCJjaGlsZFN0YXRlSWQiLCJwYXJlbnRTdGF0ZVZhbHVlIiwidG9TdGF0ZVZhbHVlIiwiY2hpbGRTdGF0ZVZhbHVlIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5Iiwia2V5IiwidG9TdGF0ZVBhdGgiLCJzdGF0ZUlkIiwiaXNBcnJheSIsInJlc3VsdCIsInNlZ21lbnQiLCJpIiwibGVuZ3RoIiwiY2hhciIsImNoYXJDb2RlQXQiLCJwdXNoIiwic3RhdGVWYWx1ZSIsImlzTWFjaGluZVNuYXBzaG90Iiwic3RhdGVQYXRoIiwicGF0aFRvU3RhdGVWYWx1ZSIsIm1hcmtlciIsInByZXZpb3VzIiwibWFwVmFsdWVzIiwiY29sbGVjdGlvbiIsIml0ZXJhdGVlIiwiY29sbGVjdGlvbktleXMiLCJ0b0FycmF5U3RyaWN0IiwidG9BcnJheSIsInVuZGVmaW5lZCIsInJlc29sdmVPdXRwdXQiLCJtYXBwZXIiLCJjb250ZXh0Iiwic2VsZiIsInZhbHVlcyIsInNvbWUiLCJ2YWwiLCJjb25zb2xlIiwid2FybiIsImVudHJpZXMiLCJmaWx0ZXIiLCJtYXAiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJqb2luIiwiQXJyYXkiLCJpc0Vycm9yQWN0b3JFdmVudCIsInN0YXJ0c1dpdGgiLCJ0b1RyYW5zaXRpb25Db25maWdBcnJheSIsImNvbmZpZ0xpa2UiLCJ0cmFuc2l0aW9uTGlrZSIsInRhcmdldCIsIm5vcm1hbGl6ZVRhcmdldCIsInRvT2JzZXJ2ZXIiLCJuZXh0SGFuZGxlciIsImVycm9ySGFuZGxlciIsImNvbXBsZXRpb25IYW5kbGVyIiwiaXNPYnNlcnZlciIsImJpbmQiLCJjb21wbGV0ZSIsImNyZWF0ZUludm9rZUlkIiwic3RhdGVOb2RlSWQiLCJpbmRleCIsInJlc29sdmVSZWZlcmVuY2VkQWN0b3IiLCJtYWNoaW5lIiwic3JjIiwibWF0Y2giLCJpbXBsZW1lbnRhdGlvbnMiLCJhY3RvcnMiLCJpbmRleFN0ciIsIm5vZGVJZCIsIm5vZGUiLCJnZXRTdGF0ZU5vZGVCeUlkIiwiaW52b2tlQ29uZmlnIiwiY29uZmlnIiwiaW52b2tlIiwiZ2V0QWxsT3duRXZlbnREZXNjcmlwdG9ycyIsInNuYXBzaG90IiwiU2V0IiwiX25vZGVzIiwiZmxhdE1hcCIsInNuIiwib3duRXZlbnRzIiwiY3JlYXRlU2NoZWR1bGVkRXZlbnRJZCIsImFjdG9yUmVmIiwic2Vzc2lvbklkIiwiaWRDb3VudGVyIiwiY3JlYXRlU3lzdGVtIiwicm9vdEFjdG9yIiwib3B0aW9ucyIsImNoaWxkcmVuIiwiTWFwIiwia2V5ZWRBY3RvcnMiLCJyZXZlcnNlS2V5ZWRBY3RvcnMiLCJXZWFrTWFwIiwiaW5zcGVjdGlvbk9ic2VydmVycyIsInRpbWVyTWFwIiwiY2xvY2siLCJsb2dnZXIiLCJzY2hlZHVsZXIiLCJzY2hlZHVsZSIsInNvdXJjZSIsImRlbGF5IiwiTWF0aCIsInJhbmRvbSIsInNsaWNlIiwic2NoZWR1bGVkRXZlbnQiLCJzdGFydGVkQXQiLCJEYXRlIiwibm93Iiwic2NoZWR1bGVkRXZlbnRJZCIsInN5c3RlbSIsIl9zbmFwc2hvdCIsIl9zY2hlZHVsZWRFdmVudHMiLCJ0aW1lb3V0IiwiX3JlbGF5IiwiY2FuY2VsIiwiY2xlYXJUaW1lb3V0IiwiY2FuY2VsQWxsIiwic2VuZEluc3BlY3Rpb25FdmVudCIsInNpemUiLCJyZXNvbHZlZEluc3BlY3Rpb25FdmVudCIsInJvb3RJZCIsImZvckVhY2giLCJvYnNlcnZlciIsIl9ib29rSWQiLCJfcmVnaXN0ZXIiLCJzZXQiLCJfdW5yZWdpc3RlciIsImRlbGV0ZSIsInN5c3RlbUlkIiwiZ2V0IiwiX3NldCIsImV4aXN0aW5nIiwiRXJyb3IiLCJpbnNwZWN0Iiwib2JzZXJ2ZXJPckZuIiwiYWRkIiwidW5zdWJzY3JpYmUiLCJfc2VuZEluc3BlY3Rpb25FdmVudCIsInNvdXJjZVJlZiIsIl9zZW5kIiwiZ2V0U25hcHNob3QiLCJzY2hlZHVsZWRFdmVudHMiLCJzY2hlZHVsZWRJZCIsIl9jbG9jayIsIl9sb2dnZXIiLCJleGVjdXRpbmdDdXN0b21BY3Rpb24iLCIkJEFDVE9SX1RZUEUiLCJQcm9jZXNzaW5nU3RhdHVzIiwiZGVmYXVsdE9wdGlvbnMiLCJmbiIsIm1zIiwibG9nIiwiZGV2VG9vbHMiLCJBY3RvciIsIl9pbml0U3RhdGUiLCJwZXJzaXN0ZWRTdGF0ZSIsImxvZ2ljIiwicmVzdG9yZVNuYXBzaG90IiwiX2FjdG9yU2NvcGUiLCJnZXRJbml0aWFsU25hcHNob3QiLCJzdGF0dXMiLCJ1cGRhdGUiLCJkZWZlcnJlZEZuIiwiX2RlZmVycmVkIiwic2hpZnQiLCJvYnNlcnZlcnMiLCJfc3RvcFByb2NlZHVyZSIsIl9jb21wbGV0ZSIsIl9kb25lRXZlbnQiLCJfcGFyZW50IiwiX2Vycm9yIiwic3Vic2NyaWJlIiwibmV4dExpc3RlbmVyT3JPYnNlcnZlciIsImVycm9yTGlzdGVuZXIiLCJjb21wbGV0ZUxpc3RlbmVyIiwiX3Byb2Nlc3NpbmdTdGF0dXMiLCJTdG9wcGVkIiwib24iLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwiZXZlbnRMaXN0ZW5lcnMiLCJ3cmFwcGVkSGFuZGxlciIsIlJ1bm5pbmciLCJfc3luY1NuYXBzaG90IiwiX3N5c3RlbUlkIiwiaW5pdEV2ZW50IiwiYXR0YWNoRGV2VG9vbHMiLCJtYWlsYm94IiwibmV4dFN0YXRlIiwiY2F1Z2h0RXJyb3IiLCJ0cmFuc2l0aW9uIiwiX3N0b3AiLCJOb3RTdGFydGVkIiwic3RvcCIsIl9yZXBvcnRFcnJvciIsInJlcG9ydEVycm9yIiwiZXJyMiIsImV2ZW50U3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlbmQiLCJyZXNvbHZlZERldlRvb2xzQWRhcHRlciIsInRvSlNPTiIsInhzdGF0ZSQkdHlwZSIsImdldFBlcnNpc3RlZFNuYXBzaG90IiwicmVmIiwicmVzb2x2ZWRPcHRpb25zIiwicGFyZW50Iiwic3luY1NuYXBzaG90IiwiZGVmZXIiLCJzdG9wQ2hpbGQiLCJjaGlsZCIsImVtaXQiLCJlbWl0dGVkRXZlbnQiLCJ3aWxkY2FyZExpc3RlbmVyIiwiYWxsTGlzdGVuZXJzIiwiYWN0aW9uRXhlY3V0b3IiLCJhY3Rpb24iLCJleGVjIiwicGFyYW1zIiwic2F2ZUV4ZWN1dGluZ0N1c3RvbUFjdGlvbiIsImluZm8iLCJzdGF0ZSIsImNyZWF0ZUFjdG9yIiwiaW50ZXJwcmV0IiwicmVzb2x2ZUNhbmNlbCIsIl8iLCJhY3Rpb25BcmdzIiwiYWN0aW9uUGFyYW1zIiwic2VuZElkIiwicmVzb2x2ZWRTZW5kSWQiLCJleGVjdXRlQ2FuY2VsIiwiYWN0b3JTY29wZSIsIl9hcmdzIiwiX3BhcmFtcyIsInJlc29sdmUiLCJleGVjdXRlIiwicmVzb2x2ZVNwYXduIiwiX2FjdGlvblBhcmFtcyIsInJlc29sdmVkSWQiLCJyZXNvbHZlZElucHV0IiwiY2xvbmVNYWNoaW5lU25hcHNob3QiLCJleGVjdXRlU3Bhd24iLCJzcGF3bkNoaWxkIiwicmVzb2x2ZVN0b3AiLCJhcmdzIiwiYWN0b3JSZWZPclN0cmluZyIsInJlc29sdmVkQWN0b3JSZWYiLCJleGVjdXRlU3RvcCIsImNoZWNrU3RhdGVJbiIsImlzU3RhdGVJZCIsIm1hdGNoZXMiLCJzdGF0ZUluIiwiY2hlY2siLCJjaGVja05vdCIsImd1YXJkcyIsImV2YWx1YXRlR3VhcmQiLCJub3QiLCJndWFyZCIsImNoZWNrQW5kIiwiYW5kIiwiY2hlY2tPciIsIm9yIiwiaXNJbmxpbmUiLCJyZXNvbHZlZCIsImd1YXJkQXJncyIsImd1YXJkUGFyYW1zIiwiYnVpbHRpbkd1YXJkIiwiaXNBdG9taWNTdGF0ZU5vZGUiLCJzdGF0ZU5vZGUiLCJnZXRDaGlsZHJlbiIsInN0YXRlcyIsImdldFByb3BlckFuY2VzdG9ycyIsInRvU3RhdGVOb2RlIiwiYW5jZXN0b3JzIiwibSIsImdldEFsbFN0YXRlTm9kZXMiLCJzdGF0ZU5vZGVzIiwibm9kZVNldCIsImFkakxpc3QiLCJnZXRBZGpMaXN0IiwicyIsImdldEluaXRpYWxTdGF0ZU5vZGVzV2l0aFRoZWlyQW5jZXN0b3JzIiwiaGFzIiwiaW5pdGlhbFN0YXRlcyIsImluaXRpYWxTdGF0ZU5vZGUiLCJnZXRWYWx1ZUZyb21BZGoiLCJiYXNlTm9kZSIsImNoaWxkU3RhdGVOb2RlcyIsImNoaWxkU3RhdGVOb2RlIiwiZ2V0U3RhdGVWYWx1ZSIsInJvb3ROb2RlIiwiaXNJbkZpbmFsU3RhdGUiLCJzdGF0ZU5vZGVTZXQiLCJzdHIiLCJnZXRDYW5kaWRhdGVzIiwicmVjZWl2ZWRFdmVudFR5cGUiLCJjYW5kaWRhdGVzIiwidHJhbnNpdGlvbnMiLCJldmVudERlc2NyaXB0b3IiLCJlbmRzV2l0aCIsInRlc3QiLCJwYXJ0aWFsRXZlbnRUb2tlbnMiLCJzcGxpdCIsImV2ZW50VG9rZW5zIiwidG9rZW5JbmRleCIsInBhcnRpYWxFdmVudFRva2VuIiwiZXZlbnRUb2tlbiIsImlzTGFzdFRva2VuIiwic29ydCIsImEiLCJiIiwiZ2V0RGVsYXllZFRyYW5zaXRpb25zIiwiYWZ0ZXJDb25maWciLCJhZnRlciIsIm11dGF0ZUVudHJ5RXhpdCIsImFmdGVyRXZlbnQiLCJldmVudFR5cGUiLCJlbnRyeSIsInJhaXNlIiwiZXhpdCIsImRlbGF5ZWRUcmFuc2l0aW9ucyIsImNvbmZpZ1RyYW5zaXRpb24iLCJyZXNvbHZlZFRyYW5zaXRpb24iLCJyZXNvbHZlZERlbGF5IiwiTnVtYmVyIiwiaXNOYU4iLCJkZWxheWVkVHJhbnNpdGlvbiIsImZvcm1hdFRyYW5zaXRpb24iLCJkZXNjcmlwdG9yIiwidHJhbnNpdGlvbkNvbmZpZyIsIm5vcm1hbGl6ZWRUYXJnZXQiLCJyZWVudGVyIiwicmVzb2x2ZVRhcmdldCIsImNvbmQiLCJhY3Rpb25zIiwidCIsImZvcm1hdFRyYW5zaXRpb25zIiwidHJhbnNpdGlvbnNDb25maWciLCJvbkRvbmUiLCJpbnZva2VEZWYiLCJvbkVycm9yIiwib25TbmFwc2hvdCIsImZvcm1hdEluaXRpYWxUcmFuc2l0aW9uIiwiX3RhcmdldCIsInJlc29sdmVkVGFyZ2V0IiwidGFyZ2V0cyIsImlzSW50ZXJuYWxUYXJnZXQiLCJnZXRTdGF0ZU5vZGVCeVBhdGgiLCJ0YXJnZXRTdGF0ZU5vZGUiLCJtZXNzYWdlIiwicmVzb2x2ZUhpc3RvcnlEZWZhdWx0VHJhbnNpdGlvbiIsImluaXRpYWwiLCJpc0hpc3RvcnlOb2RlIiwiZ2V0SW5pdGlhbFN0YXRlTm9kZXMiLCJpbml0aWFsU3RhdGUiLCJhbmNlc3RvciIsIml0ZXIiLCJkZXNjU3RhdGVOb2RlIiwiZ2V0U3RhdGVOb2RlIiwic3RhdGVLZXkiLCJhcnJheVN0YXRlUGF0aCIsImN1cnJlbnRTdGF0ZU5vZGUiLCJnZXRTdGF0ZU5vZGVzIiwiY2hpbGRTdGF0ZUtleXMiLCJzdWJTdGF0ZUtleSIsIkJvb2xlYW4iLCJyb290IiwiY29uY2F0IiwicmVkdWNlIiwiYWxsU3ViU3RhdGVOb2RlcyIsInN1YlN0YXRlTm9kZSIsInN1YlN0YXRlTm9kZXMiLCJ0cmFuc2l0aW9uQXRvbWljTm9kZSIsInRyYW5zaXRpb25Db21wb3VuZE5vZGUiLCJzdWJTdGF0ZUtleXMiLCJ0cmFuc2l0aW9uTm9kZSIsInRyYW5zaXRpb25QYXJhbGxlbE5vZGUiLCJhbGxJbm5lclRyYW5zaXRpb25zIiwic3ViU3RhdGVWYWx1ZSIsImlubmVyVHJhbnNpdGlvbnMiLCJnZXRIaXN0b3J5Tm9kZXMiLCJpc0Rlc2NlbmRhbnQiLCJwYXJlbnRTdGF0ZU5vZGUiLCJoYXNJbnRlcnNlY3Rpb24iLCJzMSIsInMyIiwic2V0MSIsInNldDIiLCJpdGVtIiwicmVtb3ZlQ29uZmxpY3RpbmdUcmFuc2l0aW9ucyIsImVuYWJsZWRUcmFuc2l0aW9ucyIsImhpc3RvcnlWYWx1ZSIsImZpbHRlcmVkVHJhbnNpdGlvbnMiLCJ0MSIsInQxUHJlZW1wdGVkIiwidHJhbnNpdGlvbnNUb1JlbW92ZSIsInQyIiwiY29tcHV0ZUV4aXRTZXQiLCJ0MyIsImZyb20iLCJmaW5kTGVhc3RDb21tb25BbmNlc3RvciIsImhlYWQiLCJ0YWlsIiwiZ2V0RWZmZWN0aXZlVGFyZ2V0U3RhdGVzIiwidGFyZ2V0Tm9kZSIsImdldFRyYW5zaXRpb25Eb21haW4iLCJ0YXJnZXRTdGF0ZXMiLCJsY2EiLCJzdGF0ZXNUb0V4aXQiLCJkb21haW4iLCJhcmVTdGF0ZU5vZGVDb2xsZWN0aW9uc0VxdWFsIiwicHJldlN0YXRlTm9kZXMiLCJuZXh0U3RhdGVOb2RlU2V0IiwibWljcm9zdGVwIiwiY3VycmVudFNuYXBzaG90IiwiaXNJbml0aWFsIiwiaW50ZXJuYWxRdWV1ZSIsIm11dFN0YXRlTm9kZVNldCIsImV4aXRTdGF0ZXMiLCJyZXNvbHZlQWN0aW9uc0FuZENvbnRleHQiLCJlbnRlclN0YXRlcyIsIm5leHRTdGF0ZU5vZGVzIiwib3JkZXIiLCJlIiwiZ2V0TWFjaGluZU91dHB1dCIsInJvb3RDb21wbGV0aW9uTm9kZSIsImRvbmVTdGF0ZUV2ZW50IiwibmV4dFNuYXBzaG90Iiwic3RhdGVzVG9FbnRlciIsInN0YXRlc0ZvckRlZmF1bHRFbnRyeSIsImNvbXB1dGVFbnRyeVNldCIsImNvbXBsZXRlZE5vZGVzIiwic3RhdGVOb2RlVG9FbnRlciIsImluaXRpYWxBY3Rpb25zIiwiYW5jZXN0b3JNYXJrZXIiLCJhZGREZXNjZW5kYW50U3RhdGVzVG9FbnRlciIsImFkZEFuY2VzdG9yU3RhdGVzVG9FbnRlciIsImhpc3RvcnlTdGF0ZU5vZGVzIiwiYWRkUHJvcGVyQW5jZXN0b3JTdGF0ZXNUb0VudGVyIiwiaGlzdG9yeURlZmF1bHRUcmFuc2l0aW9uIiwicmVlbnRyYW5jeURvbWFpbiIsImFuYyIsIl9hY3Rpb25FeGVjdXRvciIsImNoYW5nZWRIaXN0b3J5IiwiZXhpdFN0YXRlTm9kZSIsImhpc3RvcnlOb2RlIiwicHJlZGljYXRlIiwiaGlzdG9yeSIsImRlZiIsImdldEFjdGlvbiIsImFjdGlvblR5cGUiLCJyZXNvbHZlQW5kRXhlY3V0ZUFjdGlvbnNXaXRoQ29udGV4dCIsImV4dHJhIiwicmV0cmllcyIsImludGVybWVkaWF0ZVNuYXBzaG90IiwicmVzb2x2ZWRBY3Rpb24iLCJuYW1lIiwiYnVpbHRpbkFjdGlvbiIsImRlZmVycmVkQWN0b3JJZHMiLCJyZXRyeVJlc29sdmUiLCJtYWNyb3N0ZXAiLCJtaWNyb3N0YXRlcyIsImFkZE1pY3Jvc3RhdGUiLCJtaWNyb3N0YXRlIiwiX3RyYW5zaXRpb25zIiwic3RvcENoaWxkcmVuIiwibmV4dEV2ZW50IiwiY3VycmVudEV2ZW50IiwiaXNFcnIiLCJzZWxlY3RUcmFuc2l0aW9ucyIsInNob3VsZFNlbGVjdEV2ZW50bGVzc1RyYW5zaXRpb25zIiwic2VsZWN0RXZlbnRsZXNzVHJhbnNpdGlvbnMiLCJwcmV2aW91c1N0YXRlIiwiZ2V0VHJhbnNpdGlvbkRhdGEiLCJlbmFibGVkVHJhbnNpdGlvblNldCIsImF0b21pY1N0YXRlcyIsImxvb3AiLCJhbHdheXMiLCJyZXNvbHZlU3RhdGVWYWx1ZSIsImFsbFN0YXRlTm9kZXMiLCJtYWNoaW5lU25hcHNob3RNYXRjaGVzIiwidGVzdFZhbHVlIiwibWFjaGluZVNuYXBzaG90SGFzVGFnIiwiaGFzVGFnIiwidGFnIiwidGFncyIsIm1hY2hpbmVTbmFwc2hvdENhbiIsImNhbiIsInRyYW5zaXRpb25EYXRhIiwibWFjaGluZVNuYXBzaG90VG9KU09OIiwibm9kZXMiLCJnZXRNZXRhIiwianNvblZhbHVlcyIsIm1hY2hpbmVTbmFwc2hvdEdldE1ldGEiLCJhY2MiLCJtZXRhIiwiY3JlYXRlTWFjaGluZVNuYXBzaG90IiwiY2hpbGRyZW5Kc29uIiwicGVyc2lzdGVkIiwicGVyc2lzdENvbnRleHQiLCJjb250ZXh0UGFydCIsImNvcHkiLCJyZXNvbHZlUmFpc2UiLCJldmVudE9yRXhwciIsImRlbGF5c01hcCIsImRlbGF5cyIsInJlc29sdmVkRXZlbnQiLCJjb25maWdEZWxheSIsImV4ZWN1dGVSYWlzZSIsIiQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiTiIsIk8iLCJQIiwiUSIsIlIiLCJTIiwiVCIsIlUiLCJWIiwiVyIsIlgiLCJZIiwiYyIsImQiLCJmIiwiZyIsImgiLCJqIiwiayIsImwiLCJuIiwibyIsInAiLCJxIiwiciIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/xstate/dist/xstate.development.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/xstate/dist/xstate.development.esm.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actor: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.B; },\n/* harmony export */   SimulatedClock: function() { return /* binding */ SimulatedClock; },\n/* harmony export */   SpecialTargets: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.S; },\n/* harmony export */   StateMachine: function() { return /* binding */ StateMachine; },\n/* harmony export */   StateNode: function() { return /* binding */ StateNode; },\n/* harmony export */   __unsafe_getAllOwnEventDescriptors: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.I; },\n/* harmony export */   and: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.D; },\n/* harmony export */   assertEvent: function() { return /* binding */ assertEvent; },\n/* harmony export */   assign: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a; },\n/* harmony export */   cancel: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.M; },\n/* harmony export */   createActor: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A; },\n/* harmony export */   createEmptyActor: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.createEmptyActor; },\n/* harmony export */   createMachine: function() { return /* binding */ createMachine; },\n/* harmony export */   emit: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.e; },\n/* harmony export */   enqueueActions: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.b; },\n/* harmony export */   forwardTo: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.f; },\n/* harmony export */   fromCallback: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromCallback; },\n/* harmony export */   fromEventObservable: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromEventObservable; },\n/* harmony export */   fromObservable: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromObservable; },\n/* harmony export */   fromPromise: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromPromise; },\n/* harmony export */   fromTransition: function() { return /* reexport safe */ _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__.fromTransition; },\n/* harmony export */   getInitialSnapshot: function() { return /* binding */ getInitialSnapshot; },\n/* harmony export */   getNextSnapshot: function() { return /* binding */ getNextSnapshot; },\n/* harmony export */   getStateNodes: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j; },\n/* harmony export */   initialTransition: function() { return /* binding */ initialTransition; },\n/* harmony export */   interpret: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.C; },\n/* harmony export */   isMachineSnapshot: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.H; },\n/* harmony export */   log: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.l; },\n/* harmony export */   matchesState: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.J; },\n/* harmony export */   not: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.E; },\n/* harmony export */   or: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.F; },\n/* harmony export */   pathToStateValue: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.K; },\n/* harmony export */   raise: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.O; },\n/* harmony export */   sendParent: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.s; },\n/* harmony export */   sendTo: function() { return /* reexport safe */ _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.c; },\n/* harmony export */   setup: function() { return /* binding */ setup; },\n/* harmony export */   spawnChild: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.P; },\n/* harmony export */   stateIn: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.G; },\n/* harmony export */   stop: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.Q; },\n/* harmony export */   stopChild: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.R; },\n/* harmony export */   toObserver: function() { return /* reexport safe */ _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.L; },\n/* harmony export */   toPromise: function() { return /* binding */ toPromise; },\n/* harmony export */   transition: function() { return /* binding */ transition; },\n/* harmony export */   waitFor: function() { return /* binding */ waitFor; }\n/* harmony export */ });\n/* harmony import */ var _actors_dist_xstate_actors_development_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../actors/dist/xstate-actors.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raise-1db27a82.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./log-0acd9069.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var _dev_dist_xstate_dev_development_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dev/dist/xstate-dev.development.esm.js */ \"(app-pages-browser)/./node_modules/xstate/dev/dist/xstate-dev.development.esm.js\");\n\n\n\n\n\n\n/**\n * Asserts that the given event object is of the specified type or types. Throws\n * an error if the event object is not of the specified types.\n *\n * @example\n *\n * ```ts\n * // ...\n * entry: ({ event }) => {\n *   assertEvent(event, 'doNothing');\n *   // event is { type: 'doNothing' }\n * },\n * // ...\n * exit: ({ event }) => {\n *   assertEvent(event, 'greet');\n *   // event is { type: 'greet'; message: string }\n *\n *   assertEvent(event, ['greet', 'notify']);\n *   // event is { type: 'greet'; message: string }\n *   // or { type: 'notify'; message: string; level: 'info' | 'error' }\n * },\n * ```\n */ function assertEvent(event, type) {\n    const types = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(type);\n    if (!types.includes(event.type)) {\n        const typesText = types.length === 1 ? 'type \"'.concat(types[0], '\"') : 'one of types \"'.concat(types.join('\", \"'), '\"');\n        throw new Error(\"Expected event \".concat(JSON.stringify(event), \" to have \").concat(typesText));\n    }\n}\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n    let memoizedData = cache.get(object);\n    if (!memoizedData) {\n        memoizedData = {\n            [key]: fn()\n        };\n        cache.set(object, memoizedData);\n    } else if (!(key in memoizedData)) {\n        memoizedData[key] = fn();\n    }\n    return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = (action)=>{\n    if (typeof action === \"string\") {\n        return {\n            type: action\n        };\n    }\n    if (typeof action === \"function\") {\n        if (\"resolve\" in action) {\n            return {\n                type: action.type\n            };\n        }\n        return {\n            type: action.name\n        };\n    }\n    return action;\n};\nclass StateNode {\n    /** @internal */ _initialize() {\n        this.transitions = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(this);\n        if (this.config.always) {\n            this.always = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this.config.always).map((t)=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.N, t));\n        }\n        Object.keys(this.states).forEach((key)=>{\n            this.states[key]._initialize();\n        });\n    }\n    /** The well-structured state node definition. */ get definition() {\n        return {\n            id: this.id,\n            key: this.key,\n            version: this.machine.version,\n            type: this.type,\n            initial: this.initial ? {\n                target: this.initial.target,\n                source: this,\n                actions: this.initial.actions.map(toSerializableAction),\n                eventType: null,\n                reenter: false,\n                toJSON: ()=>({\n                        target: this.initial.target.map((t)=>\"#\".concat(t.id)),\n                        source: \"#\".concat(this.id),\n                        actions: this.initial.actions.map(toSerializableAction),\n                        eventType: null\n                    })\n            } : undefined,\n            history: this.history,\n            states: (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.states, (state)=>{\n                return state.definition;\n            }),\n            on: this.on,\n            transitions: [\n                ...this.transitions.values()\n            ].flat().map((t)=>({\n                    ...t,\n                    actions: t.actions.map(toSerializableAction)\n                })),\n            entry: this.entry.map(toSerializableAction),\n            exit: this.exit.map(toSerializableAction),\n            meta: this.meta,\n            order: this.order || -1,\n            output: this.output,\n            invoke: this.invoke,\n            description: this.description,\n            tags: this.tags\n        };\n    }\n    /** @internal */ toJSON() {\n        return this.definition;\n    }\n    /** The logic invoked as actors by this state node. */ get invoke() {\n        return memo(this, \"invoke\", ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.invoke).map((invokeConfig, i)=>{\n                const { src, systemId } = invokeConfig;\n                var _invokeConfig_id;\n                const resolvedId = (_invokeConfig_id = invokeConfig.id) !== null && _invokeConfig_id !== void 0 ? _invokeConfig_id : (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i);\n                const sourceName = typeof src === \"string\" ? src : \"xstate.invoke.\".concat((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this.id, i));\n                return {\n                    ...invokeConfig,\n                    src: sourceName,\n                    id: resolvedId,\n                    systemId: systemId,\n                    toJSON () {\n                        const { onDone, onError, ...invokeDefValues } = invokeConfig;\n                        return {\n                            ...invokeDefValues,\n                            type: \"xstate.invoke\",\n                            src: sourceName,\n                            id: resolvedId\n                        };\n                    }\n                };\n            }));\n    }\n    /** The mapping of events to transitions. */ get on() {\n        return memo(this, \"on\", ()=>{\n            const transitions = this.transitions;\n            return [\n                ...transitions\n            ].flatMap((param)=>{\n                let [descriptor, t] = param;\n                return t.map((t)=>[\n                        descriptor,\n                        t\n                    ]);\n            }).reduce((map, param)=>{\n                let [descriptor, transition] = param;\n                map[descriptor] = map[descriptor] || [];\n                map[descriptor].push(transition);\n                return map;\n            }, {});\n        });\n    }\n    get after() {\n        return memo(this, \"delayedTransitions\", ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.g)(this));\n    }\n    get initial() {\n        return memo(this, \"initial\", ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(this, this.config.initial));\n    }\n    /** @internal */ next(snapshot, event) {\n        const eventType = event.type;\n        const actions = [];\n        let selectedTransition;\n        const candidates = memo(this, \"candidates-\".concat(eventType), ()=>(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.h)(this, eventType));\n        for (const candidate of candidates){\n            const { guard } = candidate;\n            const resolvedContext = snapshot.context;\n            let guardPassed = false;\n            try {\n                guardPassed = !guard || (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.e)(guard, resolvedContext, event, snapshot);\n            } catch (err) {\n                const guardType = typeof guard === \"string\" ? guard : typeof guard === \"object\" ? guard.type : undefined;\n                throw new Error(\"Unable to evaluate guard \".concat(guardType ? \"'\".concat(guardType, \"' \") : \"\", \"in transition for event '\").concat(eventType, \"' in state node '\").concat(this.id, \"':\\n\").concat(err.message));\n            }\n            if (guardPassed) {\n                actions.push(...candidate.actions);\n                selectedTransition = candidate;\n                break;\n            }\n        }\n        return selectedTransition ? [\n            selectedTransition\n        ] : undefined;\n    }\n    /** All the event types accepted by this state node and its descendants. */ get events() {\n        return memo(this, \"events\", ()=>{\n            const { states } = this;\n            const events = new Set(this.ownEvents);\n            if (states) {\n                for (const stateId of Object.keys(states)){\n                    const state = states[stateId];\n                    if (state.states) {\n                        for (const event of state.events){\n                            events.add(\"\".concat(event));\n                        }\n                    }\n                }\n            }\n            return Array.from(events);\n        });\n    }\n    /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */ get ownEvents() {\n        const events = new Set([\n            ...this.transitions.keys()\n        ].filter((descriptor)=>{\n            return this.transitions.get(descriptor).some((transition)=>!(!transition.target && !transition.actions.length && !transition.reenter));\n        }));\n        return Array.from(events);\n    }\n    constructor(/** The raw config used to create the machine. */ config, options){\n        this.config = config;\n        /**\n     * The relative key of the state node, which represents its location in the\n     * overall state value.\n     */ this.key = void 0;\n        /** The unique ID of the state node. */ this.id = void 0;\n        /**\n     * The type of this state node:\n     *\n     * - `'atomic'` - no child state nodes\n     * - `'compound'` - nested child state nodes (XOR)\n     * - `'parallel'` - orthogonal nested child state nodes (AND)\n     * - `'history'` - history state node\n     * - `'final'` - final state node\n     */ this.type = void 0;\n        /** The string path from the root machine node to this node. */ this.path = void 0;\n        /** The child state nodes. */ this.states = void 0;\n        /**\n     * The type of history on this state node. Can be:\n     *\n     * - `'shallow'` - recalls only top-level historical state value\n     * - `'deep'` - recalls historical state value at all levels\n     */ this.history = void 0;\n        /** The action(s) to be executed upon entering the state node. */ this.entry = void 0;\n        /** The action(s) to be executed upon exiting the state node. */ this.exit = void 0;\n        /** The parent state node. */ this.parent = void 0;\n        /** The root machine node. */ this.machine = void 0;\n        /**\n     * The meta data associated with this state node, which will be returned in\n     * State instances.\n     */ this.meta = void 0;\n        /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a\n     * final state node.\n     */ this.output = void 0;\n        /**\n     * The order this state node appears. Corresponds to the implicit document\n     * order.\n     */ this.order = -1;\n        this.description = void 0;\n        this.tags = [];\n        this.transitions = void 0;\n        this.always = void 0;\n        this.parent = options._parent;\n        this.key = options._key;\n        this.machine = options._machine;\n        this.path = this.parent ? this.parent.path.concat(this.key) : [];\n        this.id = this.config.id || [\n            this.machine.id,\n            ...this.path\n        ].join(_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.S);\n        this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? \"compound\" : this.config.history ? \"history\" : \"atomic\");\n        this.description = this.config.description;\n        this.order = this.machine.idMap.size;\n        this.machine.idMap.set(this.id, this);\n        this.states = this.config.states ? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.m)(this.config.states, (stateConfig, key)=>{\n            const stateNode = new StateNode(stateConfig, {\n                _parent: this,\n                _key: key,\n                _machine: this.machine\n            });\n            return stateNode;\n        }) : EMPTY_OBJECT;\n        if (this.type === \"compound\" && !this.config.initial) {\n            throw new Error('No initial state specified for compound state node \"#'.concat(this.id, '\". Try adding { initial: \"').concat(Object.keys(this.states)[0], '\" } to the state config.'));\n        }\n        // History config\n        this.history = this.config.history === true ? \"shallow\" : this.config.history || false;\n        this.entry = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.entry).slice();\n        this.exit = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(this.config.exit).slice();\n        this.meta = this.config.meta;\n        this.output = this.type === \"final\" || !this.parent ? this.config.output : undefined;\n        this.tags = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.t)(config.tags).slice();\n    }\n}\nconst STATE_IDENTIFIER = \"#\";\nclass StateMachine {\n    /**\n   * Clones this state machine with the provided implementations and merges the\n   * `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,\n   *   `context`) to recursively merge with the existing options.\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */ provide(implementations) {\n        const { actions, guards, actors, delays } = this.implementations;\n        return new StateMachine(this.config, {\n            actions: {\n                ...actions,\n                ...implementations.actions\n            },\n            guards: {\n                ...guards,\n                ...implementations.guards\n            },\n            actors: {\n                ...actors,\n                ...implementations.actors\n            },\n            delays: {\n                ...delays,\n                ...implementations.delays\n            }\n        });\n    }\n    resolveState(config) {\n        const resolvedStateValue = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.r)(this.root, config.value);\n        const nodeSet = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, resolvedStateValue));\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            _nodes: [\n                ...nodeSet\n            ],\n            context: config.context || {},\n            children: {},\n            status: (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.l)(nodeSet, this.root) ? \"done\" : config.status || \"active\",\n            output: config.output,\n            error: config.error,\n            historyValue: config.historyValue\n        }, this);\n    }\n    /**\n   * Determines the next snapshot given the current `snapshot` and received\n   * `event`. Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */ transition(snapshot, event, actorScope) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope, []).snapshot;\n    }\n    /**\n   * Determines the next state given the current `state` and `event`. Calculates\n   * a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */ microstep(snapshot, event, actorScope) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(snapshot, event, actorScope, []).microstates;\n    }\n    getTransitionData(snapshot, event) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.o)(this.root, snapshot.value, snapshot, event) || [];\n    }\n    /**\n   * The initial state _before_ evaluating any microsteps. This \"pre-initial\"\n   * state is provided to initial actions executed in the initial state.\n   */ getPreInitialState(actorScope, initEvent, internalQueue) {\n        const { context } = this.config;\n        const preInitial = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            context: typeof context !== \"function\" && context ? context : {},\n            _nodes: [\n                this.root\n            ],\n            children: {},\n            status: \"active\"\n        }, this);\n        if (typeof context === \"function\") {\n            const assignment = (param)=>{\n                let { spawn, event, self } = param;\n                return context({\n                    spawn,\n                    input: event.input,\n                    self\n                });\n            };\n            return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.p)(preInitial, initEvent, actorScope, [\n                (0,_log_0acd9069_development_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(assignment)\n            ], internalQueue, undefined);\n        }\n        return preInitial;\n    }\n    /**\n   * Returns the initial `State` instance, with reference to `self` as an\n   * `ActorRef`.\n   */ getInitialSnapshot(actorScope, input) {\n        const initEvent = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.q)(input); // TODO: fix;\n        const internalQueue = [];\n        const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n        const nextState = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.s)([\n            {\n                target: [\n                    ...(0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.u)(this.root)\n                ],\n                source: this.root,\n                reenter: true,\n                actions: [],\n                eventType: null,\n                toJSON: null // TODO: fix\n            }\n        ], preInitialState, actorScope, initEvent, true, internalQueue);\n        const { snapshot: macroState } = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.n)(nextState, initEvent, actorScope, internalQueue);\n        return macroState;\n    }\n    start(snapshot) {\n        Object.values(snapshot.children).forEach((child)=>{\n            if (child.getSnapshot().status === \"active\") {\n                child.start();\n            }\n        });\n    }\n    getStateNodeById(stateId) {\n        const fullPath = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.v)(stateId);\n        const relativePath = fullPath.slice(1);\n        const resolvedStateId = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.w)(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n        const stateNode = this.idMap.get(resolvedStateId);\n        if (!stateNode) {\n            throw new Error(\"Child state node '#\".concat(resolvedStateId, \"' does not exist on machine '\").concat(this.id, \"'\"));\n        }\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.x)(stateNode, relativePath);\n    }\n    get definition() {\n        return this.root.definition;\n    }\n    toJSON() {\n        return this.definition;\n    }\n    getPersistedSnapshot(snapshot, options) {\n        return (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.y)(snapshot, options);\n    }\n    restoreSnapshot(snapshot, _actorScope) {\n        const children = {};\n        const snapshotChildren = snapshot.children;\n        Object.keys(snapshotChildren).forEach((actorId)=>{\n            const actorData = snapshotChildren[actorId];\n            const childState = actorData.snapshot;\n            const src = actorData.src;\n            const logic = typeof src === \"string\" ? (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.z)(this, src) : src;\n            if (!logic) {\n                return;\n            }\n            const actorRef = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(logic, {\n                id: actorId,\n                parent: _actorScope.self,\n                syncSnapshot: actorData.syncSnapshot,\n                snapshot: childState,\n                src,\n                systemId: actorData.systemId\n            });\n            children[actorId] = actorRef;\n        });\n        const restoredSnapshot = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.k)({\n            ...snapshot,\n            children,\n            _nodes: Array.from((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)((0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.j)(this.root, snapshot.value)))\n        }, this);\n        const seen = new Set();\n        function reviveContext(contextPart, children) {\n            if (seen.has(contextPart)) {\n                return;\n            }\n            seen.add(contextPart);\n            for(const key in contextPart){\n                const value = contextPart[key];\n                if (value && typeof value === \"object\") {\n                    if (\"xstate$$type\" in value && value.xstate$$type === _raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.$) {\n                        contextPart[key] = children[value.id];\n                        continue;\n                    }\n                    reviveContext(value, children);\n                }\n            }\n        }\n        reviveContext(restoredSnapshot.context, children);\n        return restoredSnapshot;\n    }\n    constructor(/** The raw config used to create the machine. */ config, implementations){\n        this.config = config;\n        /** The machine's own version. */ this.version = void 0;\n        this.schemas = void 0;\n        this.implementations = void 0;\n        /** @internal */ this.__xstatenode = true;\n        /** @internal */ this.idMap = new Map();\n        this.root = void 0;\n        this.id = void 0;\n        this.states = void 0;\n        this.events = void 0;\n        this.id = config.id || \"(machine)\";\n        var _implementations_actors, _implementations_actions, _implementations_delays, _implementations_guards;\n        this.implementations = {\n            actors: (_implementations_actors = implementations === null || implementations === void 0 ? void 0 : implementations.actors) !== null && _implementations_actors !== void 0 ? _implementations_actors : {},\n            actions: (_implementations_actions = implementations === null || implementations === void 0 ? void 0 : implementations.actions) !== null && _implementations_actions !== void 0 ? _implementations_actions : {},\n            delays: (_implementations_delays = implementations === null || implementations === void 0 ? void 0 : implementations.delays) !== null && _implementations_delays !== void 0 ? _implementations_delays : {},\n            guards: (_implementations_guards = implementations === null || implementations === void 0 ? void 0 : implementations.guards) !== null && _implementations_guards !== void 0 ? _implementations_guards : {}\n        };\n        this.version = this.config.version;\n        this.schemas = this.config.schemas;\n        this.transition = this.transition.bind(this);\n        this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n        this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n        this.restoreSnapshot = this.restoreSnapshot.bind(this);\n        this.start = this.start.bind(this);\n        this.root = new StateNode(config, {\n            _key: this.id,\n            _machine: this\n        });\n        this.root._initialize();\n        this.states = this.root.states; // TODO: remove!\n        this.events = this.root.events;\n        if (!(\"output\" in this.root) && Object.values(this.states).some((state)=>state.type === \"final\" && \"output\" in state)) {\n            console.warn(\"Missing `machine.output` declaration (top-level final state with output detected)\");\n        }\n    }\n}\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @example\n *\n * ```ts\n * import { createMachine } from 'xstate';\n *\n * const lightMachine = createMachine({\n *   id: 'light',\n *   initial: 'green',\n *   states: {\n *     green: {\n *       on: {\n *         TIMER: { target: 'yellow' }\n *       }\n *     },\n *     yellow: {\n *       on: {\n *         TIMER: { target: 'red' }\n *       }\n *     },\n *     red: {\n *       on: {\n *         TIMER: { target: 'green' }\n *       }\n *     }\n *   }\n * });\n *\n * const lightActor = createActor(lightMachine);\n * lightActor.start();\n *\n * lightActor.send({ type: 'TIMER' });\n * ```\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })`\n *   to provide machine implementations instead.\n */ function createMachine(config, implementations) {\n    return new StateMachine(config, implementations);\n}\n/** @internal */ function createInertActorScope(actorLogic) {\n    const self = (0,_raise_1db27a82_development_esm_js__WEBPACK_IMPORTED_MODULE_1__.A)(actorLogic);\n    const inertActorScope = {\n        self,\n        defer: ()=>{},\n        id: \"\",\n        logger: ()=>{},\n        sessionId: \"\",\n        stopChild: ()=>{},\n        system: self.system,\n        emit: ()=>{},\n        actionExecutor: ()=>{}\n    };\n    return inertActorScope;\n}\n/** @deprecated Use `initialTransition(…)` instead. */ function getInitialSnapshot(actorLogic) {\n    for(var _len = arguments.length, _tmp = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        _tmp[_key - 1] = arguments[_key];\n    }\n    let [input] = _tmp;\n    const actorScope = createInertActorScope(actorLogic);\n    return actorLogic.getInitialSnapshot(actorScope, input);\n}\n/**\n * Determines the next snapshot for the given `actorLogic` based on the given\n * `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the `actorLogic` is\n * used.\n *\n * @deprecated Use `transition(…)` instead.\n * @example\n *\n * ```ts\n * import { getNextSnapshot } from 'xstate';\n * import { trafficLightMachine } from './trafficLightMachine.ts';\n *\n * const nextSnapshot = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   undefined, // snapshot (or initial state if undefined)\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot.value);\n * // => 'yellow'\n *\n * const nextSnapshot2 = getNextSnapshot(\n *   trafficLightMachine, // actor logic\n *   nextSnapshot, // snapshot\n *   { type: 'TIMER' }\n * ); // event object\n *\n * console.log(nextSnapshot2.value);\n * // =>'red'\n * ```\n */ function getNextSnapshot(actorLogic, snapshot, event) {\n    const inertActorScope = createInertActorScope(actorLogic);\n    inertActorScope.self._snapshot = snapshot;\n    return actorLogic.transition(snapshot, event, inertActorScope);\n}\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup(param) {\n    let { schemas, actors, actions, guards, delays } = param;\n    return {\n        createMachine: (config)=>createMachine({\n                ...config,\n                schemas\n            }, {\n                actors,\n                actions,\n                guards,\n                delays\n            })\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass SimulatedClock {\n    now() {\n        return this._now;\n    }\n    getId() {\n        return this._id++;\n    }\n    setTimeout(fn, timeout) {\n        this._flushingInvalidated = this._flushing;\n        const id = this.getId();\n        this.timeouts.set(id, {\n            start: this.now(),\n            timeout,\n            fn\n        });\n        return id;\n    }\n    clearTimeout(id) {\n        this._flushingInvalidated = this._flushing;\n        this.timeouts.delete(id);\n    }\n    set(time) {\n        if (this._now > time) {\n            throw new Error(\"Unable to travel back in time\");\n        }\n        this._now = time;\n        this.flushTimeouts();\n    }\n    flushTimeouts() {\n        if (this._flushing) {\n            this._flushingInvalidated = true;\n            return;\n        }\n        this._flushing = true;\n        const sorted = [\n            ...this.timeouts\n        ].sort((param, param1)=>{\n            let [_idA, timeoutA] = param, [_idB, timeoutB] = param1;\n            const endA = timeoutA.start + timeoutA.timeout;\n            const endB = timeoutB.start + timeoutB.timeout;\n            return endB > endA ? -1 : 1;\n        });\n        for (const [id, timeout] of sorted){\n            if (this._flushingInvalidated) {\n                this._flushingInvalidated = false;\n                this._flushing = false;\n                this.flushTimeouts();\n                return;\n            }\n            if (this.now() - timeout.start >= timeout.timeout) {\n                this.timeouts.delete(id);\n                timeout.fn.call(null);\n            }\n        }\n        this._flushing = false;\n    }\n    increment(ms) {\n        this._now += ms;\n        this.flushTimeouts();\n    }\n    constructor(){\n        this.timeouts = new Map();\n        this._now = 0;\n        this._id = 0;\n        this._flushing = false;\n        this._flushingInvalidated = false;\n    }\n}\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n *\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */ function toPromise(actor) {\n    return new Promise((resolve, reject)=>{\n        actor.subscribe({\n            complete: ()=>{\n                resolve(actor.getSnapshot().output);\n            },\n            error: reject\n        });\n    });\n}\n/**\n * Given actor `logic`, a `snapshot`, and an `event`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute.\n *\n * This is a pure function that does not execute `actions`.\n */ function transition(logic, snapshot, event) {\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.transition(snapshot, event, actorScope);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\n/**\n * Given actor `logic` and optional `input`, returns a tuple of the\n * `nextSnapshot` and `actions` to execute from the initial transition (no\n * previous state).\n *\n * This is a pure function that does not execute `actions`.\n */ function initialTransition(logic) {\n    for(var _len = arguments.length, _tmp = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        _tmp[_key - 1] = arguments[_key];\n    }\n    let [input] = _tmp;\n    const executableActions = [];\n    const actorScope = createInertActorScope(logic);\n    actorScope.actionExecutor = (action)=>{\n        executableActions.push(action);\n    };\n    const nextSnapshot = logic.getInitialSnapshot(actorScope, input);\n    return [\n        nextSnapshot,\n        executableActions\n    ];\n}\nconst defaultWaitForOptions = {\n    timeout: Infinity // much more than 10 seconds\n};\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy a\n * predicate, and then resolves with that value. Will throw if the desired state\n * is not reached after an optional timeout. (defaults to Infinity).\n *\n * @example\n *\n * ```js\n * const state = await waitFor(someService, (state) => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value that matches\n *   the condition\n */ function waitFor(actorRef, predicate, options) {\n    const resolvedOptions = {\n        ...defaultWaitForOptions,\n        ...options\n    };\n    return new Promise((res, rej)=>{\n        const { signal } = resolvedOptions;\n        if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            rej(signal.reason);\n            return;\n        }\n        let done = false;\n        if (resolvedOptions.timeout < 0) {\n            console.error(\"`timeout` passed to `waitFor` is negative and it will reject its internal promise immediately.\");\n        }\n        const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(()=>{\n            dispose();\n            rej(new Error(\"Timeout of \".concat(resolvedOptions.timeout, \" ms exceeded\")));\n        }, resolvedOptions.timeout);\n        const dispose = ()=>{\n            clearTimeout(handle);\n            done = true;\n            sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n            if (abortListener) {\n                signal.removeEventListener(\"abort\", abortListener);\n            }\n        };\n        function checkEmitted(emitted) {\n            if (predicate(emitted)) {\n                dispose();\n                res(emitted);\n            }\n        }\n        /**\n     * If the `signal` option is provided, this will be the listener for its\n     * `abort` event\n     */ let abortListener;\n        // eslint-disable-next-line prefer-const\n        let sub; // avoid TDZ when disposing synchronously\n        // See if the current snapshot already matches the predicate\n        checkEmitted(actorRef.getSnapshot());\n        if (done) {\n            return;\n        }\n        // only define the `abortListener` if the `signal` option is provided\n        if (signal) {\n            abortListener = ()=>{\n                dispose();\n                // XState does not \"own\" the signal, so we should reject with its reason (if any)\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(signal.reason);\n            };\n            signal.addEventListener(\"abort\", abortListener);\n        }\n        sub = actorRef.subscribe({\n            next: checkEmitted,\n            error: (err)=>{\n                dispose();\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                rej(err);\n            },\n            complete: ()=>{\n                dispose();\n                rej(new Error(\"Actor terminated without satisfying predicate\"));\n            }\n        });\n        if (done) {\n            sub.unsubscribe();\n        }\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy94c3RhdGUvZGlzdC94c3RhdGUuZGV2ZWxvcG1lbnQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSztBQUM0aUI7QUFDNVc7QUFDblM7QUFDNkc7QUFDMUg7QUFFbkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkMsR0FDRCxTQUFTMEcsWUFBWUMsS0FBSyxFQUFFQyxJQUFJO0lBQzlCLE1BQU1DLFFBQVF0RyxxRUFBT0EsQ0FBQ3FHO0lBQ3RCLElBQUksQ0FBQ0MsTUFBTUMsUUFBUSxDQUFDSCxNQUFNQyxJQUFJLEdBQUc7UUFDL0IsTUFBTUcsWUFBWUYsTUFBTUcsTUFBTSxLQUFLLElBQUksU0FBa0IsT0FBVEgsS0FBSyxDQUFDLEVBQUUsRUFBQyxPQUFLLGlCQUFvQyxPQUFuQkEsTUFBTUksSUFBSSxDQUFDLFNBQVE7UUFDbEcsTUFBTSxJQUFJQyxNQUFNLGtCQUFtREgsT0FBakNJLEtBQUtDLFNBQVMsQ0FBQ1QsUUFBTyxhQUFxQixPQUFWSTtJQUNyRTtBQUNGO0FBRUEsTUFBTU0sUUFBUSxJQUFJQztBQUNsQixTQUFTQyxLQUFLQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsRUFBRTtJQUMzQixJQUFJQyxlQUFlTixNQUFNTyxHQUFHLENBQUNKO0lBQzdCLElBQUksQ0FBQ0csY0FBYztRQUNqQkEsZUFBZTtZQUNiLENBQUNGLElBQUksRUFBRUM7UUFDVDtRQUNBTCxNQUFNUSxHQUFHLENBQUNMLFFBQVFHO0lBQ3BCLE9BQU8sSUFBSSxDQUFFRixDQUFBQSxPQUFPRSxZQUFXLEdBQUk7UUFDakNBLFlBQVksQ0FBQ0YsSUFBSSxHQUFHQztJQUN0QjtJQUNBLE9BQU9DLFlBQVksQ0FBQ0YsSUFBSTtBQUMxQjtBQUVBLE1BQU1LLGVBQWUsQ0FBQztBQUN0QixNQUFNQyx1QkFBdUJDLENBQUFBO0lBQzNCLElBQUks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SUFBSWYsVUFBVWUsVUFBVTtnQkFDdEJOO2dCQUNBUCxJQUFJYTtZQUNOO1FBQ0Y7UUFFQTs7O0tBR0MsR0FDRCxJQUFJSDtRQUNKLHdDQUF3QztRQUN4QyxJQUFJRixLQUFLLHlDQUF5QztRQUVsRCw0REFBNEQ7UUFDNURJLGFBQWE5RSxTQUFTWixXQUFXO1FBQ2pDLElBQUltRixNQUFNO1lBQ1I7UUFDRjtRQUVBLHFFQUFxRTtRQUNyRSxJQUFJSCxRQUFRO1lBQ1ZRLGdCQUFnQjtnQkFDZEg7Z0JBQ0EsaUZBQWlGO2dCQUNqRiwyRUFBMkU7Z0JBQzNFTixJQUFJQyxPQUFPRSxNQUFNO1lBQ25CO1lBQ0FGLE9BQU9ZLGdCQUFnQixDQUFDLFNBQVNKO1FBQ25DO1FBQ0FGLE1BQU0xRSxTQUFTd0QsU0FBUyxDQUFDO1lBQ3ZCeEksTUFBTThKO1lBQ043RyxPQUFPeEMsQ0FBQUE7Z0JBQ0xnSjtnQkFDQSwyRUFBMkU7Z0JBQzNFTixJQUFJMUk7WUFDTjtZQUNBZ0ksVUFBVTtnQkFDUmdCO2dCQUNBTixJQUFJLElBQUlwTixNQUFPO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJd04sTUFBTTtZQUNSRyxJQUFJQyxXQUFXO1FBQ2pCO0lBQ0Y7QUFDRjtBQUU4SyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMveHN0YXRlL2Rpc3QveHN0YXRlLmRldmVsb3BtZW50LmVzbS5qcz80Y2Q0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGNyZWF0ZUVtcHR5QWN0b3IsIGZyb21DYWxsYmFjaywgZnJvbUV2ZW50T2JzZXJ2YWJsZSwgZnJvbU9ic2VydmFibGUsIGZyb21Qcm9taXNlLCBmcm9tVHJhbnNpdGlvbiB9IGZyb20gJy4uL2FjdG9ycy9kaXN0L3hzdGF0ZS1hY3RvcnMuZGV2ZWxvcG1lbnQuZXNtLmpzJztcbmltcG9ydCB7IHQgYXMgdG9BcnJheSwgUyBhcyBTVEFURV9ERUxJTUlURVIsIG0gYXMgbWFwVmFsdWVzLCBmIGFzIGZvcm1hdFRyYW5zaXRpb25zLCBhIGFzIHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5LCBiIGFzIGZvcm1hdFRyYW5zaXRpb24sIE4gYXMgTlVMTF9FVkVOVCwgZSBhcyBldmFsdWF0ZUd1YXJkLCBjIGFzIGNyZWF0ZUludm9rZUlkLCBnIGFzIGdldERlbGF5ZWRUcmFuc2l0aW9ucywgZCBhcyBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbiwgaCBhcyBnZXRDYW5kaWRhdGVzLCByIGFzIHJlc29sdmVTdGF0ZVZhbHVlLCBpIGFzIGdldEFsbFN0YXRlTm9kZXMsIGogYXMgZ2V0U3RhdGVOb2RlcywgayBhcyBjcmVhdGVNYWNoaW5lU25hcHNob3QsIGwgYXMgaXNJbkZpbmFsU3RhdGUsIG4gYXMgbWFjcm9zdGVwLCBvIGFzIHRyYW5zaXRpb25Ob2RlLCBwIGFzIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dCwgcSBhcyBjcmVhdGVJbml0RXZlbnQsIHMgYXMgbWljcm9zdGVwLCB1IGFzIGdldEluaXRpYWxTdGF0ZU5vZGVzLCB2IGFzIHRvU3RhdGVQYXRoLCB3IGFzIGlzU3RhdGVJZCwgeCBhcyBnZXRTdGF0ZU5vZGVCeVBhdGgsIHkgYXMgZ2V0UGVyc2lzdGVkU25hcHNob3QsIHogYXMgcmVzb2x2ZVJlZmVyZW5jZWRBY3RvciwgQSBhcyBjcmVhdGVBY3RvciwgJCBhcyAkJEFDVE9SX1RZUEUgfSBmcm9tICcuL3JhaXNlLTFkYjI3YTgyLmRldmVsb3BtZW50LmVzbS5qcyc7XG5leHBvcnQgeyBCIGFzIEFjdG9yLCBJIGFzIF9fdW5zYWZlX2dldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMsIEQgYXMgYW5kLCBNIGFzIGNhbmNlbCwgQSBhcyBjcmVhdGVBY3RvciwgaiBhcyBnZXRTdGF0ZU5vZGVzLCBDIGFzIGludGVycHJldCwgSCBhcyBpc01hY2hpbmVTbmFwc2hvdCwgSiBhcyBtYXRjaGVzU3RhdGUsIEUgYXMgbm90LCBGIGFzIG9yLCBLIGFzIHBhdGhUb1N0YXRlVmFsdWUsIE8gYXMgcmFpc2UsIFAgYXMgc3Bhd25DaGlsZCwgRyBhcyBzdGF0ZUluLCBRIGFzIHN0b3AsIFIgYXMgc3RvcENoaWxkLCBMIGFzIHRvT2JzZXJ2ZXIgfSBmcm9tICcuL3JhaXNlLTFkYjI3YTgyLmRldmVsb3BtZW50LmVzbS5qcyc7XG5pbXBvcnQgeyBhIGFzIGFzc2lnbiB9IGZyb20gJy4vbG9nLTBhY2Q5MDY5LmRldmVsb3BtZW50LmVzbS5qcyc7XG5leHBvcnQgeyBTIGFzIFNwZWNpYWxUYXJnZXRzLCBhIGFzIGFzc2lnbiwgZSBhcyBlbWl0LCBiIGFzIGVucXVldWVBY3Rpb25zLCBmIGFzIGZvcndhcmRUbywgbCBhcyBsb2csIHMgYXMgc2VuZFBhcmVudCwgYyBhcyBzZW5kVG8gfSBmcm9tICcuL2xvZy0wYWNkOTA2OS5kZXZlbG9wbWVudC5lc20uanMnO1xuaW1wb3J0ICcuLi9kZXYvZGlzdC94c3RhdGUtZGV2LmRldmVsb3BtZW50LmVzbS5qcyc7XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBldmVudCBvYmplY3QgaXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9yIHR5cGVzLiBUaHJvd3NcbiAqIGFuIGVycm9yIGlmIHRoZSBldmVudCBvYmplY3QgaXMgbm90IG9mIHRoZSBzcGVjaWZpZWQgdHlwZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogLy8gLi4uXG4gKiBlbnRyeTogKHsgZXZlbnQgfSkgPT4ge1xuICogICBhc3NlcnRFdmVudChldmVudCwgJ2RvTm90aGluZycpO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdkb05vdGhpbmcnIH1cbiAqIH0sXG4gKiAvLyAuLi5cbiAqIGV4aXQ6ICh7IGV2ZW50IH0pID0+IHtcbiAqICAgYXNzZXJ0RXZlbnQoZXZlbnQsICdncmVldCcpO1xuICogICAvLyBldmVudCBpcyB7IHR5cGU6ICdncmVldCc7IG1lc3NhZ2U6IHN0cmluZyB9XG4gKlxuICogICBhc3NlcnRFdmVudChldmVudCwgWydncmVldCcsICdub3RpZnknXSk7XG4gKiAgIC8vIGV2ZW50IGlzIHsgdHlwZTogJ2dyZWV0JzsgbWVzc2FnZTogc3RyaW5nIH1cbiAqICAgLy8gb3IgeyB0eXBlOiAnbm90aWZ5JzsgbWVzc2FnZTogc3RyaW5nOyBsZXZlbDogJ2luZm8nIHwgJ2Vycm9yJyB9XG4gKiB9LFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEV2ZW50KGV2ZW50LCB0eXBlKSB7XG4gIGNvbnN0IHR5cGVzID0gdG9BcnJheSh0eXBlKTtcbiAgaWYgKCF0eXBlcy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xuICAgIGNvbnN0IHR5cGVzVGV4dCA9IHR5cGVzLmxlbmd0aCA9PT0gMSA/IGB0eXBlIFwiJHt0eXBlc1swXX1cImAgOiBgb25lIG9mIHR5cGVzIFwiJHt0eXBlcy5qb2luKCdcIiwgXCInKX1cImA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBldmVudCAke0pTT04uc3RyaW5naWZ5KGV2ZW50KX0gdG8gaGF2ZSAke3R5cGVzVGV4dH1gKTtcbiAgfVxufVxuXG5jb25zdCBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtZW1vKG9iamVjdCwga2V5LCBmbikge1xuICBsZXQgbWVtb2l6ZWREYXRhID0gY2FjaGUuZ2V0KG9iamVjdCk7XG4gIGlmICghbWVtb2l6ZWREYXRhKSB7XG4gICAgbWVtb2l6ZWREYXRhID0ge1xuICAgICAgW2tleV06IGZuKClcbiAgICB9O1xuICAgIGNhY2hlLnNldChvYmplY3QsIG1lbW9pemVkRGF0YSk7XG4gIH0gZWxzZSBpZiAoIShrZXkgaW4gbWVtb2l6ZWREYXRhKSkge1xuICAgIG1lbW9pemVkRGF0YVtrZXldID0gZm4oKTtcbiAgfVxuICByZXR1cm4gbWVtb2l6ZWREYXRhW2tleV07XG59XG5cbmNvbnN0IEVNUFRZX09CSkVDVCA9IHt9O1xuY29uc3QgdG9TZXJpYWxpemFibGVBY3Rpb24gPSBhY3Rpb24gPT4ge1xuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogYWN0aW9uXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICgncmVzb2x2ZScgaW4gYWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBhY3Rpb24udHlwZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGFjdGlvbi5uYW1lXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWN0aW9uO1xufTtcbmNsYXNzIFN0YXRlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKC8qKiBUaGUgcmF3IGNvbmZpZyB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFjaGluZS4gKi9cbiAgY29uZmlnLCBvcHRpb25zKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIGtleSBvZiB0aGUgc3RhdGUgbm9kZSwgd2hpY2ggcmVwcmVzZW50cyBpdHMgbG9jYXRpb24gaW4gdGhlXG4gICAgICogb3ZlcmFsbCBzdGF0ZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgc3RhdGUgbm9kZS4gKi9cbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoaXMgc3RhdGUgbm9kZTpcbiAgICAgKlxuICAgICAqIC0gYCdhdG9taWMnYCAtIG5vIGNoaWxkIHN0YXRlIG5vZGVzXG4gICAgICogLSBgJ2NvbXBvdW5kJ2AgLSBuZXN0ZWQgY2hpbGQgc3RhdGUgbm9kZXMgKFhPUilcbiAgICAgKiAtIGAncGFyYWxsZWwnYCAtIG9ydGhvZ29uYWwgbmVzdGVkIGNoaWxkIHN0YXRlIG5vZGVzIChBTkQpXG4gICAgICogLSBgJ2hpc3RvcnknYCAtIGhpc3Rvcnkgc3RhdGUgbm9kZVxuICAgICAqIC0gYCdmaW5hbCdgIC0gZmluYWwgc3RhdGUgbm9kZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHN0cmluZyBwYXRoIGZyb20gdGhlIHJvb3QgbWFjaGluZSBub2RlIHRvIHRoaXMgbm9kZS4gKi9cbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBjaGlsZCBzdGF0ZSBub2Rlcy4gKi9cbiAgICB0aGlzLnN0YXRlcyA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBoaXN0b3J5IG9uIHRoaXMgc3RhdGUgbm9kZS4gQ2FuIGJlOlxuICAgICAqXG4gICAgICogLSBgJ3NoYWxsb3cnYCAtIHJlY2FsbHMgb25seSB0b3AtbGV2ZWwgaGlzdG9yaWNhbCBzdGF0ZSB2YWx1ZVxuICAgICAqIC0gYCdkZWVwJ2AgLSByZWNhbGxzIGhpc3RvcmljYWwgc3RhdGUgdmFsdWUgYXQgYWxsIGxldmVsc1xuICAgICAqL1xuICAgIHRoaXMuaGlzdG9yeSA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGFjdGlvbihzKSB0byBiZSBleGVjdXRlZCB1cG9uIGVudGVyaW5nIHRoZSBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMuZW50cnkgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBhY3Rpb24ocykgdG8gYmUgZXhlY3V0ZWQgdXBvbiBleGl0aW5nIHRoZSBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMuZXhpdCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIHBhcmVudCBzdGF0ZSBub2RlLiAqL1xuICAgIHRoaXMucGFyZW50ID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgcm9vdCBtYWNoaW5lIG5vZGUuICovXG4gICAgdGhpcy5tYWNoaW5lID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhdGUgbm9kZSwgd2hpY2ggd2lsbCBiZSByZXR1cm5lZCBpblxuICAgICAqIFN0YXRlIGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIG91dHB1dCBkYXRhIHNlbnQgd2l0aCB0aGUgXCJ4c3RhdGUuZG9uZS5zdGF0ZS5faWRfXCIgZXZlbnQgaWYgdGhpcyBpcyBhXG4gICAgICogZmluYWwgc3RhdGUgbm9kZS5cbiAgICAgKi9cbiAgICB0aGlzLm91dHB1dCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhpcyBzdGF0ZSBub2RlIGFwcGVhcnMuIENvcnJlc3BvbmRzIHRvIHRoZSBpbXBsaWNpdCBkb2N1bWVudFxuICAgICAqIG9yZGVyLlxuICAgICAqL1xuICAgIHRoaXMub3JkZXIgPSAtMTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHdheXMgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XG4gICAgdGhpcy5rZXkgPSBvcHRpb25zLl9rZXk7XG4gICAgdGhpcy5tYWNoaW5lID0gb3B0aW9ucy5fbWFjaGluZTtcbiAgICB0aGlzLnBhdGggPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBhdGguY29uY2F0KHRoaXMua2V5KSA6IFtdO1xuICAgIHRoaXMuaWQgPSB0aGlzLmNvbmZpZy5pZCB8fCBbdGhpcy5tYWNoaW5lLmlkLCAuLi50aGlzLnBhdGhdLmpvaW4oU1RBVEVfREVMSU1JVEVSKTtcbiAgICB0aGlzLnR5cGUgPSB0aGlzLmNvbmZpZy50eXBlIHx8ICh0aGlzLmNvbmZpZy5zdGF0ZXMgJiYgT2JqZWN0LmtleXModGhpcy5jb25maWcuc3RhdGVzKS5sZW5ndGggPyAnY29tcG91bmQnIDogdGhpcy5jb25maWcuaGlzdG9yeSA/ICdoaXN0b3J5JyA6ICdhdG9taWMnKTtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gdGhpcy5jb25maWcuZGVzY3JpcHRpb247XG4gICAgdGhpcy5vcmRlciA9IHRoaXMubWFjaGluZS5pZE1hcC5zaXplO1xuICAgIHRoaXMubWFjaGluZS5pZE1hcC5zZXQodGhpcy5pZCwgdGhpcyk7XG4gICAgdGhpcy5zdGF0ZXMgPSB0aGlzLmNvbmZpZy5zdGF0ZXMgPyBtYXBWYWx1ZXModGhpcy5jb25maWcuc3RhdGVzLCAoc3RhdGVDb25maWcsIGtleSkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGVOb2RlID0gbmV3IFN0YXRlTm9kZShzdGF0ZUNvbmZpZywge1xuICAgICAgICBfcGFyZW50OiB0aGlzLFxuICAgICAgICBfa2V5OiBrZXksXG4gICAgICAgIF9tYWNoaW5lOiB0aGlzLm1hY2hpbmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlTm9kZTtcbiAgICB9KSA6IEVNUFRZX09CSkVDVDtcbiAgICBpZiAodGhpcy50eXBlID09PSAnY29tcG91bmQnICYmICF0aGlzLmNvbmZpZy5pbml0aWFsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGluaXRpYWwgc3RhdGUgc3BlY2lmaWVkIGZvciBjb21wb3VuZCBzdGF0ZSBub2RlIFwiIyR7dGhpcy5pZH1cIi4gVHJ5IGFkZGluZyB7IGluaXRpYWw6IFwiJHtPYmplY3Qua2V5cyh0aGlzLnN0YXRlcylbMF19XCIgfSB0byB0aGUgc3RhdGUgY29uZmlnLmApO1xuICAgIH1cblxuICAgIC8vIEhpc3RvcnkgY29uZmlnXG4gICAgdGhpcy5oaXN0b3J5ID0gdGhpcy5jb25maWcuaGlzdG9yeSA9PT0gdHJ1ZSA/ICdzaGFsbG93JyA6IHRoaXMuY29uZmlnLmhpc3RvcnkgfHwgZmFsc2U7XG4gICAgdGhpcy5lbnRyeSA9IHRvQXJyYXkodGhpcy5jb25maWcuZW50cnkpLnNsaWNlKCk7XG4gICAgdGhpcy5leGl0ID0gdG9BcnJheSh0aGlzLmNvbmZpZy5leGl0KS5zbGljZSgpO1xuICAgIHRoaXMubWV0YSA9IHRoaXMuY29uZmlnLm1ldGE7XG4gICAgdGhpcy5vdXRwdXQgPSB0aGlzLnR5cGUgPT09ICdmaW5hbCcgfHwgIXRoaXMucGFyZW50ID8gdGhpcy5jb25maWcub3V0cHV0IDogdW5kZWZpbmVkO1xuICAgIHRoaXMudGFncyA9IHRvQXJyYXkoY29uZmlnLnRhZ3MpLnNsaWNlKCk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbnMgPSBmb3JtYXRUcmFuc2l0aW9ucyh0aGlzKTtcbiAgICBpZiAodGhpcy5jb25maWcuYWx3YXlzKSB7XG4gICAgICB0aGlzLmFsd2F5cyA9IHRvVHJhbnNpdGlvbkNvbmZpZ0FycmF5KHRoaXMuY29uZmlnLmFsd2F5cykubWFwKHQgPT4gZm9ybWF0VHJhbnNpdGlvbih0aGlzLCBOVUxMX0VWRU5ULCB0KSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKHRoaXMuc3RhdGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICB0aGlzLnN0YXRlc1trZXldLl9pbml0aWFsaXplKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGhlIHdlbGwtc3RydWN0dXJlZCBzdGF0ZSBub2RlIGRlZmluaXRpb24uICovXG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICB2ZXJzaW9uOiB0aGlzLm1hY2hpbmUudmVyc2lvbixcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGluaXRpYWw6IHRoaXMuaW5pdGlhbCA/IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmluaXRpYWwudGFyZ2V0LFxuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIGFjdGlvbnM6IHRoaXMuaW5pdGlhbC5hY3Rpb25zLm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgICAgcmVlbnRlcjogZmFsc2UsXG4gICAgICAgIHRvSlNPTjogKCkgPT4gKHtcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMuaW5pdGlhbC50YXJnZXQubWFwKHQgPT4gYCMke3QuaWR9YCksXG4gICAgICAgICAgc291cmNlOiBgIyR7dGhpcy5pZH1gLFxuICAgICAgICAgIGFjdGlvbnM6IHRoaXMuaW5pdGlhbC5hY3Rpb25zLm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICAgICAgZXZlbnRUeXBlOiBudWxsXG4gICAgICAgIH0pXG4gICAgICB9IDogdW5kZWZpbmVkLFxuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgc3RhdGVzOiBtYXBWYWx1ZXModGhpcy5zdGF0ZXMsIHN0YXRlID0+IHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRlZmluaXRpb247XG4gICAgICB9KSxcbiAgICAgIG9uOiB0aGlzLm9uLFxuICAgICAgdHJhbnNpdGlvbnM6IFsuLi50aGlzLnRyYW5zaXRpb25zLnZhbHVlcygpXS5mbGF0KCkubWFwKHQgPT4gKHtcbiAgICAgICAgLi4udCxcbiAgICAgICAgYWN0aW9uczogdC5hY3Rpb25zLm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbilcbiAgICAgIH0pKSxcbiAgICAgIGVudHJ5OiB0aGlzLmVudHJ5Lm1hcCh0b1NlcmlhbGl6YWJsZUFjdGlvbiksXG4gICAgICBleGl0OiB0aGlzLmV4aXQubWFwKHRvU2VyaWFsaXphYmxlQWN0aW9uKSxcbiAgICAgIG1ldGE6IHRoaXMubWV0YSxcbiAgICAgIG9yZGVyOiB0aGlzLm9yZGVyIHx8IC0xLFxuICAgICAgb3V0cHV0OiB0aGlzLm91dHB1dCxcbiAgICAgIGludm9rZTogdGhpcy5pbnZva2UsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIHRhZ3M6IHRoaXMudGFnc1xuICAgIH07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9uO1xuICB9XG5cbiAgLyoqIFRoZSBsb2dpYyBpbnZva2VkIGFzIGFjdG9ycyBieSB0aGlzIHN0YXRlIG5vZGUuICovXG4gIGdldCBpbnZva2UoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2ludm9rZScsICgpID0+IHRvQXJyYXkodGhpcy5jb25maWcuaW52b2tlKS5tYXAoKGludm9rZUNvbmZpZywgaSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcmMsXG4gICAgICAgIHN5c3RlbUlkXG4gICAgICB9ID0gaW52b2tlQ29uZmlnO1xuICAgICAgY29uc3QgcmVzb2x2ZWRJZCA9IGludm9rZUNvbmZpZy5pZCA/PyBjcmVhdGVJbnZva2VJZCh0aGlzLmlkLCBpKTtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IGB4c3RhdGUuaW52b2tlLiR7Y3JlYXRlSW52b2tlSWQodGhpcy5pZCwgaSl9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmludm9rZUNvbmZpZyxcbiAgICAgICAgc3JjOiBzb3VyY2VOYW1lLFxuICAgICAgICBpZDogcmVzb2x2ZWRJZCxcbiAgICAgICAgc3lzdGVtSWQ6IHN5c3RlbUlkLFxuICAgICAgICB0b0pTT04oKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb25Eb25lLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIC4uLmludm9rZURlZlZhbHVlc1xuICAgICAgICAgIH0gPSBpbnZva2VDb25maWc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmludm9rZURlZlZhbHVlcyxcbiAgICAgICAgICAgIHR5cGU6ICd4c3RhdGUuaW52b2tlJyxcbiAgICAgICAgICAgIHNyYzogc291cmNlTmFtZSxcbiAgICAgICAgICAgIGlkOiByZXNvbHZlZElkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSk7XG4gIH1cblxuICAvKiogVGhlIG1hcHBpbmcgb2YgZXZlbnRzIHRvIHRyYW5zaXRpb25zLiAqL1xuICBnZXQgb24oKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ29uJywgKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb25zO1xuICAgICAgcmV0dXJuIFsuLi50cmFuc2l0aW9uc10uZmxhdE1hcCgoW2Rlc2NyaXB0b3IsIHRdKSA9PiB0Lm1hcCh0ID0+IFtkZXNjcmlwdG9yLCB0XSkpLnJlZHVjZSgobWFwLCBbZGVzY3JpcHRvciwgdHJhbnNpdGlvbl0pID0+IHtcbiAgICAgICAgbWFwW2Rlc2NyaXB0b3JdID0gbWFwW2Rlc2NyaXB0b3JdIHx8IFtdO1xuICAgICAgICBtYXBbZGVzY3JpcHRvcl0ucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0sIHt9KTtcbiAgICB9KTtcbiAgfVxuICBnZXQgYWZ0ZXIoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2RlbGF5ZWRUcmFuc2l0aW9ucycsICgpID0+IGdldERlbGF5ZWRUcmFuc2l0aW9ucyh0aGlzKSk7XG4gIH1cbiAgZ2V0IGluaXRpYWwoKSB7XG4gICAgcmV0dXJuIG1lbW8odGhpcywgJ2luaXRpYWwnLCAoKSA9PiBmb3JtYXRJbml0aWFsVHJhbnNpdGlvbih0aGlzLCB0aGlzLmNvbmZpZy5pbml0aWFsKSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIG5leHQoc25hcHNob3QsIGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRUeXBlID0gZXZlbnQudHlwZTtcbiAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgbGV0IHNlbGVjdGVkVHJhbnNpdGlvbjtcbiAgICBjb25zdCBjYW5kaWRhdGVzID0gbWVtbyh0aGlzLCBgY2FuZGlkYXRlcy0ke2V2ZW50VHlwZX1gLCAoKSA9PiBnZXRDYW5kaWRhdGVzKHRoaXMsIGV2ZW50VHlwZSkpO1xuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ3VhcmRcbiAgICAgIH0gPSBjYW5kaWRhdGU7XG4gICAgICBjb25zdCByZXNvbHZlZENvbnRleHQgPSBzbmFwc2hvdC5jb250ZXh0O1xuICAgICAgbGV0IGd1YXJkUGFzc2VkID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBndWFyZFBhc3NlZCA9ICFndWFyZCB8fCBldmFsdWF0ZUd1YXJkKGd1YXJkLCByZXNvbHZlZENvbnRleHQsIGV2ZW50LCBzbmFwc2hvdCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZ3VhcmRUeXBlID0gdHlwZW9mIGd1YXJkID09PSAnc3RyaW5nJyA/IGd1YXJkIDogdHlwZW9mIGd1YXJkID09PSAnb2JqZWN0JyA/IGd1YXJkLnR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGV2YWx1YXRlIGd1YXJkICR7Z3VhcmRUeXBlID8gYCcke2d1YXJkVHlwZX0nIGAgOiAnJ31pbiB0cmFuc2l0aW9uIGZvciBldmVudCAnJHtldmVudFR5cGV9JyBpbiBzdGF0ZSBub2RlICcke3RoaXMuaWR9JzpcXG4ke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgaWYgKGd1YXJkUGFzc2VkKSB7XG4gICAgICAgIGFjdGlvbnMucHVzaCguLi5jYW5kaWRhdGUuYWN0aW9ucyk7XG4gICAgICAgIHNlbGVjdGVkVHJhbnNpdGlvbiA9IGNhbmRpZGF0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFRyYW5zaXRpb24gPyBbc2VsZWN0ZWRUcmFuc2l0aW9uXSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKiBBbGwgdGhlIGV2ZW50IHR5cGVzIGFjY2VwdGVkIGJ5IHRoaXMgc3RhdGUgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzLiAqL1xuICBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBtZW1vKHRoaXMsICdldmVudHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXRlc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KHRoaXMub3duRXZlbnRzKTtcbiAgICAgIGlmIChzdGF0ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdGF0ZUlkIG9mIE9iamVjdC5rZXlzKHN0YXRlcykpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0YXRlc1tzdGF0ZUlkXTtcbiAgICAgICAgICBpZiAoc3RhdGUuc3RhdGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHN0YXRlLmV2ZW50cykge1xuICAgICAgICAgICAgICBldmVudHMuYWRkKGAke2V2ZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGwgdGhlIGV2ZW50cyB0aGF0IGhhdmUgdHJhbnNpdGlvbnMgZGlyZWN0bHkgZnJvbSB0aGlzIHN0YXRlIG5vZGUuXG4gICAqXG4gICAqIEV4Y2x1ZGVzIGFueSBpbmVydCBldmVudHMuXG4gICAqL1xuICBnZXQgb3duRXZlbnRzKCkge1xuICAgIGNvbnN0IGV2ZW50cyA9IG5ldyBTZXQoWy4uLnRoaXMudHJhbnNpdGlvbnMua2V5cygpXS5maWx0ZXIoZGVzY3JpcHRvciA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5nZXQoZGVzY3JpcHRvcikuc29tZSh0cmFuc2l0aW9uID0+ICEoIXRyYW5zaXRpb24udGFyZ2V0ICYmICF0cmFuc2l0aW9uLmFjdGlvbnMubGVuZ3RoICYmICF0cmFuc2l0aW9uLnJlZW50ZXIpKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZXZlbnRzKTtcbiAgfVxufVxuXG5jb25zdCBTVEFURV9JREVOVElGSUVSID0gJyMnO1xuY2xhc3MgU3RhdGVNYWNoaW5lIHtcbiAgY29uc3RydWN0b3IoLyoqIFRoZSByYXcgY29uZmlnIHVzZWQgdG8gY3JlYXRlIHRoZSBtYWNoaW5lLiAqL1xuICBjb25maWcsIGltcGxlbWVudGF0aW9ucykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIC8qKiBUaGUgbWFjaGluZSdzIG93biB2ZXJzaW9uLiAqL1xuICAgIHRoaXMudmVyc2lvbiA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVtYXMgPSB2b2lkIDA7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbnMgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX194c3RhdGVub2RlID0gdHJ1ZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5pZE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJvb3QgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmV2ZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gY29uZmlnLmlkIHx8ICcobWFjaGluZSknO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb25zID0ge1xuICAgICAgYWN0b3JzOiBpbXBsZW1lbnRhdGlvbnM/LmFjdG9ycyA/PyB7fSxcbiAgICAgIGFjdGlvbnM6IGltcGxlbWVudGF0aW9ucz8uYWN0aW9ucyA/PyB7fSxcbiAgICAgIGRlbGF5czogaW1wbGVtZW50YXRpb25zPy5kZWxheXMgPz8ge30sXG4gICAgICBndWFyZHM6IGltcGxlbWVudGF0aW9ucz8uZ3VhcmRzID8/IHt9XG4gICAgfTtcbiAgICB0aGlzLnZlcnNpb24gPSB0aGlzLmNvbmZpZy52ZXJzaW9uO1xuICAgIHRoaXMuc2NoZW1hcyA9IHRoaXMuY29uZmlnLnNjaGVtYXM7XG4gICAgdGhpcy50cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRJbml0aWFsU25hcHNob3QgPSB0aGlzLmdldEluaXRpYWxTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0UGVyc2lzdGVkU25hcHNob3QgPSB0aGlzLmdldFBlcnNpc3RlZFNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXN0b3JlU25hcHNob3QgPSB0aGlzLnJlc3RvcmVTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yb290ID0gbmV3IFN0YXRlTm9kZShjb25maWcsIHtcbiAgICAgIF9rZXk6IHRoaXMuaWQsXG4gICAgICBfbWFjaGluZTogdGhpc1xuICAgIH0pO1xuICAgIHRoaXMucm9vdC5faW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMuc3RhdGVzID0gdGhpcy5yb290LnN0YXRlczsgLy8gVE9ETzogcmVtb3ZlIVxuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5yb290LmV2ZW50cztcbiAgICBpZiAoISgnb3V0cHV0JyBpbiB0aGlzLnJvb3QpICYmIE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZXMpLnNvbWUoc3RhdGUgPT4gc3RhdGUudHlwZSA9PT0gJ2ZpbmFsJyAmJiAnb3V0cHV0JyBpbiBzdGF0ZSkpIHtcbiAgICAgIGNvbnNvbGUud2FybignTWlzc2luZyBgbWFjaGluZS5vdXRwdXRgIGRlY2xhcmF0aW9uICh0b3AtbGV2ZWwgZmluYWwgc3RhdGUgd2l0aCBvdXRwdXQgZGV0ZWN0ZWQpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGlzIHN0YXRlIG1hY2hpbmUgd2l0aCB0aGUgcHJvdmlkZWQgaW1wbGVtZW50YXRpb25zIGFuZCBtZXJnZXMgdGhlXG4gICAqIGBjb250ZXh0YCAoaWYgcHJvdmlkZWQpLlxuICAgKlxuICAgKiBAcGFyYW0gaW1wbGVtZW50YXRpb25zIE9wdGlvbnMgKGBhY3Rpb25zYCwgYGd1YXJkc2AsIGBhY3RvcnNgLCBgZGVsYXlzYCxcbiAgICogICBgY29udGV4dGApIHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIEEgbmV3IGBTdGF0ZU1hY2hpbmVgIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGltcGxlbWVudGF0aW9ucy5cbiAgICovXG4gIHByb3ZpZGUoaW1wbGVtZW50YXRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9ucyxcbiAgICAgIGd1YXJkcyxcbiAgICAgIGFjdG9ycyxcbiAgICAgIGRlbGF5c1xuICAgIH0gPSB0aGlzLmltcGxlbWVudGF0aW9ucztcbiAgICByZXR1cm4gbmV3IFN0YXRlTWFjaGluZSh0aGlzLmNvbmZpZywge1xuICAgICAgYWN0aW9uczoge1xuICAgICAgICAuLi5hY3Rpb25zLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0aW9uc1xuICAgICAgfSxcbiAgICAgIGd1YXJkczoge1xuICAgICAgICAuLi5ndWFyZHMsXG4gICAgICAgIC4uLmltcGxlbWVudGF0aW9ucy5ndWFyZHNcbiAgICAgIH0sXG4gICAgICBhY3RvcnM6IHtcbiAgICAgICAgLi4uYWN0b3JzLFxuICAgICAgICAuLi5pbXBsZW1lbnRhdGlvbnMuYWN0b3JzXG4gICAgICB9LFxuICAgICAgZGVsYXlzOiB7XG4gICAgICAgIC4uLmRlbGF5cyxcbiAgICAgICAgLi4uaW1wbGVtZW50YXRpb25zLmRlbGF5c1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlc29sdmVTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCByZXNvbHZlZFN0YXRlVmFsdWUgPSByZXNvbHZlU3RhdGVWYWx1ZSh0aGlzLnJvb3QsIGNvbmZpZy52YWx1ZSk7XG4gICAgY29uc3Qgbm9kZVNldCA9IGdldEFsbFN0YXRlTm9kZXMoZ2V0U3RhdGVOb2Rlcyh0aGlzLnJvb3QsIHJlc29sdmVkU3RhdGVWYWx1ZSkpO1xuICAgIHJldHVybiBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgX25vZGVzOiBbLi4ubm9kZVNldF0sXG4gICAgICBjb250ZXh0OiBjb25maWcuY29udGV4dCB8fCB7fSxcbiAgICAgIGNoaWxkcmVuOiB7fSxcbiAgICAgIHN0YXR1czogaXNJbkZpbmFsU3RhdGUobm9kZVNldCwgdGhpcy5yb290KSA/ICdkb25lJyA6IGNvbmZpZy5zdGF0dXMgfHwgJ2FjdGl2ZScsXG4gICAgICBvdXRwdXQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgICBlcnJvcjogY29uZmlnLmVycm9yLFxuICAgICAgaGlzdG9yeVZhbHVlOiBjb25maWcuaGlzdG9yeVZhbHVlXG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBnaXZlbiB0aGUgY3VycmVudCBgc25hcHNob3RgIGFuZCByZWNlaXZlZFxuICAgKiBgZXZlbnRgLiBDYWxjdWxhdGVzIGEgZnVsbCBtYWNyb3N0ZXAgZnJvbSBhbGwgbWljcm9zdGVwcy5cbiAgICpcbiAgICogQHBhcmFtIHNuYXBzaG90IFRoZSBjdXJyZW50IHNuYXBzaG90XG4gICAqIEBwYXJhbSBldmVudCBUaGUgcmVjZWl2ZWQgZXZlbnRcbiAgICovXG4gIHRyYW5zaXRpb24oc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5zbmFwc2hvdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBuZXh0IHN0YXRlIGdpdmVuIHRoZSBjdXJyZW50IGBzdGF0ZWAgYW5kIGBldmVudGAuIENhbGN1bGF0ZXNcbiAgICogYSBtaWNyb3N0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBzdGF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIHJlY2VpdmVkIGV2ZW50XG4gICAqL1xuICBtaWNyb3N0ZXAoc25hcHNob3QsIGV2ZW50LCBhY3RvclNjb3BlKSB7XG4gICAgcmV0dXJuIG1hY3Jvc3RlcChzbmFwc2hvdCwgZXZlbnQsIGFjdG9yU2NvcGUsIFtdKS5taWNyb3N0YXRlcztcbiAgfVxuICBnZXRUcmFuc2l0aW9uRGF0YShzbmFwc2hvdCwgZXZlbnQpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk5vZGUodGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSwgc25hcHNob3QsIGV2ZW50KSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSBfYmVmb3JlXyBldmFsdWF0aW5nIGFueSBtaWNyb3N0ZXBzLiBUaGlzIFwicHJlLWluaXRpYWxcIlxuICAgKiBzdGF0ZSBpcyBwcm92aWRlZCB0byBpbml0aWFsIGFjdGlvbnMgZXhlY3V0ZWQgaW4gdGhlIGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBnZXRQcmVJbml0aWFsU3RhdGUoYWN0b3JTY29wZSwgaW5pdEV2ZW50LCBpbnRlcm5hbFF1ZXVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBwcmVJbml0aWFsID0gY3JlYXRlTWFjaGluZVNuYXBzaG90KHtcbiAgICAgIGNvbnRleHQ6IHR5cGVvZiBjb250ZXh0ICE9PSAnZnVuY3Rpb24nICYmIGNvbnRleHQgPyBjb250ZXh0IDoge30sXG4gICAgICBfbm9kZXM6IFt0aGlzLnJvb3RdLFxuICAgICAgY2hpbGRyZW46IHt9LFxuICAgICAgc3RhdHVzOiAnYWN0aXZlJ1xuICAgIH0sIHRoaXMpO1xuICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgYXNzaWdubWVudCA9ICh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBldmVudCxcbiAgICAgICAgc2VsZlxuICAgICAgfSkgPT4gY29udGV4dCh7XG4gICAgICAgIHNwYXduLFxuICAgICAgICBpbnB1dDogZXZlbnQuaW5wdXQsXG4gICAgICAgIHNlbGZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc29sdmVBY3Rpb25zQW5kQ29udGV4dChwcmVJbml0aWFsLCBpbml0RXZlbnQsIGFjdG9yU2NvcGUsIFthc3NpZ24oYXNzaWdubWVudCldLCBpbnRlcm5hbFF1ZXVlLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlSW5pdGlhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGBTdGF0ZWAgaW5zdGFuY2UsIHdpdGggcmVmZXJlbmNlIHRvIGBzZWxmYCBhcyBhblxuICAgKiBgQWN0b3JSZWZgLlxuICAgKi9cbiAgZ2V0SW5pdGlhbFNuYXBzaG90KGFjdG9yU2NvcGUsIGlucHV0KSB7XG4gICAgY29uc3QgaW5pdEV2ZW50ID0gY3JlYXRlSW5pdEV2ZW50KGlucHV0KTsgLy8gVE9ETzogZml4O1xuICAgIGNvbnN0IGludGVybmFsUXVldWUgPSBbXTtcbiAgICBjb25zdCBwcmVJbml0aWFsU3RhdGUgPSB0aGlzLmdldFByZUluaXRpYWxTdGF0ZShhY3RvclNjb3BlLCBpbml0RXZlbnQsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IG1pY3Jvc3RlcChbe1xuICAgICAgdGFyZ2V0OiBbLi4uZ2V0SW5pdGlhbFN0YXRlTm9kZXModGhpcy5yb290KV0sXG4gICAgICBzb3VyY2U6IHRoaXMucm9vdCxcbiAgICAgIHJlZW50ZXI6IHRydWUsXG4gICAgICBhY3Rpb25zOiBbXSxcbiAgICAgIGV2ZW50VHlwZTogbnVsbCxcbiAgICAgIHRvSlNPTjogbnVsbCAvLyBUT0RPOiBmaXhcbiAgICB9XSwgcHJlSW5pdGlhbFN0YXRlLCBhY3RvclNjb3BlLCBpbml0RXZlbnQsIHRydWUsIGludGVybmFsUXVldWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNuYXBzaG90OiBtYWNyb1N0YXRlXG4gICAgfSA9IG1hY3Jvc3RlcChuZXh0U3RhdGUsIGluaXRFdmVudCwgYWN0b3JTY29wZSwgaW50ZXJuYWxRdWV1ZSk7XG4gICAgcmV0dXJuIG1hY3JvU3RhdGU7XG4gIH1cbiAgc3RhcnQoc25hcHNob3QpIHtcbiAgICBPYmplY3QudmFsdWVzKHNuYXBzaG90LmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5nZXRTbmFwc2hvdCgpLnN0YXR1cyA9PT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgY2hpbGQuc3RhcnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRTdGF0ZU5vZGVCeUlkKHN0YXRlSWQpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHRvU3RhdGVQYXRoKHN0YXRlSWQpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGZ1bGxQYXRoLnNsaWNlKDEpO1xuICAgIGNvbnN0IHJlc29sdmVkU3RhdGVJZCA9IGlzU3RhdGVJZChmdWxsUGF0aFswXSkgPyBmdWxsUGF0aFswXS5zbGljZShTVEFURV9JREVOVElGSUVSLmxlbmd0aCkgOiBmdWxsUGF0aFswXTtcbiAgICBjb25zdCBzdGF0ZU5vZGUgPSB0aGlzLmlkTWFwLmdldChyZXNvbHZlZFN0YXRlSWQpO1xuICAgIGlmICghc3RhdGVOb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENoaWxkIHN0YXRlIG5vZGUgJyMke3Jlc29sdmVkU3RhdGVJZH0nIGRvZXMgbm90IGV4aXN0IG9uIG1hY2hpbmUgJyR7dGhpcy5pZH0nYCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRTdGF0ZU5vZGVCeVBhdGgoc3RhdGVOb2RlLCByZWxhdGl2ZVBhdGgpO1xuICB9XG4gIGdldCBkZWZpbml0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvb3QuZGVmaW5pdGlvbjtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbjtcbiAgfVxuICBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRQZXJzaXN0ZWRTbmFwc2hvdChzbmFwc2hvdCwgb3B0aW9ucyk7XG4gIH1cbiAgcmVzdG9yZVNuYXBzaG90KHNuYXBzaG90LCBfYWN0b3JTY29wZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0ge307XG4gICAgY29uc3Qgc25hcHNob3RDaGlsZHJlbiA9IHNuYXBzaG90LmNoaWxkcmVuO1xuICAgIE9iamVjdC5rZXlzKHNuYXBzaG90Q2hpbGRyZW4pLmZvckVhY2goYWN0b3JJZCA9PiB7XG4gICAgICBjb25zdCBhY3RvckRhdGEgPSBzbmFwc2hvdENoaWxkcmVuW2FjdG9ySWRdO1xuICAgICAgY29uc3QgY2hpbGRTdGF0ZSA9IGFjdG9yRGF0YS5zbmFwc2hvdDtcbiAgICAgIGNvbnN0IHNyYyA9IGFjdG9yRGF0YS5zcmM7XG4gICAgICBjb25zdCBsb2dpYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcmVzb2x2ZVJlZmVyZW5jZWRBY3Rvcih0aGlzLCBzcmMpIDogc3JjO1xuICAgICAgaWYgKCFsb2dpYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RvclJlZiA9IGNyZWF0ZUFjdG9yKGxvZ2ljLCB7XG4gICAgICAgIGlkOiBhY3RvcklkLFxuICAgICAgICBwYXJlbnQ6IF9hY3RvclNjb3BlLnNlbGYsXG4gICAgICAgIHN5bmNTbmFwc2hvdDogYWN0b3JEYXRhLnN5bmNTbmFwc2hvdCxcbiAgICAgICAgc25hcHNob3Q6IGNoaWxkU3RhdGUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3lzdGVtSWQ6IGFjdG9yRGF0YS5zeXN0ZW1JZFxuICAgICAgfSk7XG4gICAgICBjaGlsZHJlblthY3RvcklkXSA9IGFjdG9yUmVmO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3RvcmVkU25hcHNob3QgPSBjcmVhdGVNYWNoaW5lU25hcHNob3Qoe1xuICAgICAgLi4uc25hcHNob3QsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIF9ub2RlczogQXJyYXkuZnJvbShnZXRBbGxTdGF0ZU5vZGVzKGdldFN0YXRlTm9kZXModGhpcy5yb290LCBzbmFwc2hvdC52YWx1ZSkpKVxuICAgIH0sIHRoaXMpO1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gcmV2aXZlQ29udGV4dChjb250ZXh0UGFydCwgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChzZWVuLmhhcyhjb250ZXh0UGFydCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vlbi5hZGQoY29udGV4dFBhcnQpO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29udGV4dFBhcnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0UGFydFtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICgneHN0YXRlJCR0eXBlJyBpbiB2YWx1ZSAmJiB2YWx1ZS54c3RhdGUkJHR5cGUgPT09ICQkQUNUT1JfVFlQRSkge1xuICAgICAgICAgICAgY29udGV4dFBhcnRba2V5XSA9IGNoaWxkcmVuW3ZhbHVlLmlkXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXZpdmVDb250ZXh0KHZhbHVlLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV2aXZlQ29udGV4dChyZXN0b3JlZFNuYXBzaG90LmNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICByZXR1cm4gcmVzdG9yZWRTbmFwc2hvdDtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGF0ZSBtYWNoaW5lIChzdGF0ZWNoYXJ0KSB3aXRoIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBzdGF0ZSBtYWNoaW5lIHJlcHJlc2VudHMgdGhlIHB1cmUgbG9naWMgb2YgYSBzdGF0ZSBtYWNoaW5lIGFjdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGNyZWF0ZU1hY2hpbmUgfSBmcm9tICd4c3RhdGUnO1xuICpcbiAqIGNvbnN0IGxpZ2h0TWFjaGluZSA9IGNyZWF0ZU1hY2hpbmUoe1xuICogICBpZDogJ2xpZ2h0JyxcbiAqICAgaW5pdGlhbDogJ2dyZWVuJyxcbiAqICAgc3RhdGVzOiB7XG4gKiAgICAgZ3JlZW46IHtcbiAqICAgICAgIG9uOiB7XG4gKiAgICAgICAgIFRJTUVSOiB7IHRhcmdldDogJ3llbGxvdycgfVxuICogICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgeWVsbG93OiB7XG4gKiAgICAgICBvbjoge1xuICogICAgICAgICBUSU1FUjogeyB0YXJnZXQ6ICdyZWQnIH1cbiAqICAgICAgIH1cbiAqICAgICB9LFxuICogICAgIHJlZDoge1xuICogICAgICAgb246IHtcbiAqICAgICAgICAgVElNRVI6IHsgdGFyZ2V0OiAnZ3JlZW4nIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIGNvbnN0IGxpZ2h0QWN0b3IgPSBjcmVhdGVBY3RvcihsaWdodE1hY2hpbmUpO1xuICogbGlnaHRBY3Rvci5zdGFydCgpO1xuICpcbiAqIGxpZ2h0QWN0b3Iuc2VuZCh7IHR5cGU6ICdUSU1FUicgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBzdGF0ZSBtYWNoaW5lIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0gb3B0aW9ucyBERVBSRUNBVEVEOiB1c2UgYHNldHVwKHsgLi4uIH0pYCBvciBgbWFjaGluZS5wcm92aWRlKHsgLi4uIH0pYFxuICogICB0byBwcm92aWRlIG1hY2hpbmUgaW1wbGVtZW50YXRpb25zIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBTdGF0ZU1hY2hpbmUoY29uZmlnLCBpbXBsZW1lbnRhdGlvbnMpO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYykge1xuICBjb25zdCBzZWxmID0gY3JlYXRlQWN0b3IoYWN0b3JMb2dpYyk7XG4gIGNvbnN0IGluZXJ0QWN0b3JTY29wZSA9IHtcbiAgICBzZWxmLFxuICAgIGRlZmVyOiAoKSA9PiB7fSxcbiAgICBpZDogJycsXG4gICAgbG9nZ2VyOiAoKSA9PiB7fSxcbiAgICBzZXNzaW9uSWQ6ICcnLFxuICAgIHN0b3BDaGlsZDogKCkgPT4ge30sXG4gICAgc3lzdGVtOiBzZWxmLnN5c3RlbSxcbiAgICBlbWl0OiAoKSA9PiB7fSxcbiAgICBhY3Rpb25FeGVjdXRvcjogKCkgPT4ge31cbiAgfTtcbiAgcmV0dXJuIGluZXJ0QWN0b3JTY29wZTtcbn1cblxuLyoqIEBkZXByZWNhdGVkIFVzZSBgaW5pdGlhbFRyYW5zaXRpb24o4oCmKWAgaW5zdGVhZC4gKi9cbmZ1bmN0aW9uIGdldEluaXRpYWxTbmFwc2hvdChhY3RvckxvZ2ljLCAuLi5baW5wdXRdKSB7XG4gIGNvbnN0IGFjdG9yU2NvcGUgPSBjcmVhdGVJbmVydEFjdG9yU2NvcGUoYWN0b3JMb2dpYyk7XG4gIHJldHVybiBhY3RvckxvZ2ljLmdldEluaXRpYWxTbmFwc2hvdChhY3RvclNjb3BlLCBpbnB1dCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbmV4dCBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIGBhY3RvckxvZ2ljYCBiYXNlZCBvbiB0aGUgZ2l2ZW5cbiAqIGBzbmFwc2hvdGAgYW5kIGBldmVudGAuXG4gKlxuICogSWYgdGhlIGBzbmFwc2hvdGAgaXMgYHVuZGVmaW5lZGAsIHRoZSBpbml0aWFsIHNuYXBzaG90IG9mIHRoZSBgYWN0b3JMb2dpY2AgaXNcbiAqIHVzZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB0cmFuc2l0aW9uKOKApilgIGluc3RlYWQuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBnZXROZXh0U25hcHNob3QgfSBmcm9tICd4c3RhdGUnO1xuICogaW1wb3J0IHsgdHJhZmZpY0xpZ2h0TWFjaGluZSB9IGZyb20gJy4vdHJhZmZpY0xpZ2h0TWFjaGluZS50cyc7XG4gKlxuICogY29uc3QgbmV4dFNuYXBzaG90ID0gZ2V0TmV4dFNuYXBzaG90KFxuICogICB0cmFmZmljTGlnaHRNYWNoaW5lLCAvLyBhY3RvciBsb2dpY1xuICogICB1bmRlZmluZWQsIC8vIHNuYXBzaG90IChvciBpbml0aWFsIHN0YXRlIGlmIHVuZGVmaW5lZClcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdC52YWx1ZSk7XG4gKiAvLyA9PiAneWVsbG93J1xuICpcbiAqIGNvbnN0IG5leHRTbmFwc2hvdDIgPSBnZXROZXh0U25hcHNob3QoXG4gKiAgIHRyYWZmaWNMaWdodE1hY2hpbmUsIC8vIGFjdG9yIGxvZ2ljXG4gKiAgIG5leHRTbmFwc2hvdCwgLy8gc25hcHNob3RcbiAqICAgeyB0eXBlOiAnVElNRVInIH1cbiAqICk7IC8vIGV2ZW50IG9iamVjdFxuICpcbiAqIGNvbnNvbGUubG9nKG5leHRTbmFwc2hvdDIudmFsdWUpO1xuICogLy8gPT4ncmVkJ1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE5leHRTbmFwc2hvdChhY3RvckxvZ2ljLCBzbmFwc2hvdCwgZXZlbnQpIHtcbiAgY29uc3QgaW5lcnRBY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGFjdG9yTG9naWMpO1xuICBpbmVydEFjdG9yU2NvcGUuc2VsZi5fc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgcmV0dXJuIGFjdG9yTG9naWMudHJhbnNpdGlvbihzbmFwc2hvdCwgZXZlbnQsIGluZXJ0QWN0b3JTY29wZSk7XG59XG5cbi8vIGF0IHRoZSBtb21lbnQgd2UgYWxsb3cgZXh0cmEgYWN0b3JzIC0gb25lcyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIGJ5IGBjaGlsZHJlbmBcbi8vIHRoaXMgY291bGQgYmUgcmVjb25zaWRlcmVkIGluIHRoZSBmdXR1cmVcblxuZnVuY3Rpb24gc2V0dXAoe1xuICBzY2hlbWFzLFxuICBhY3RvcnMsXG4gIGFjdGlvbnMsXG4gIGd1YXJkcyxcbiAgZGVsYXlzXG59KSB7XG4gIHJldHVybiB7XG4gICAgY3JlYXRlTWFjaGluZTogY29uZmlnID0+IGNyZWF0ZU1hY2hpbmUoe1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgc2NoZW1hc1xuICAgIH0sIHtcbiAgICAgIGFjdG9ycyxcbiAgICAgIGFjdGlvbnMsXG4gICAgICBndWFyZHMsXG4gICAgICBkZWxheXNcbiAgICB9KVxuICB9O1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIFNpbXVsYXRlZENsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50aW1lb3V0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3cgPSAwO1xuICAgIHRoaXMuX2lkID0gMDtcbiAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vdztcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQrKztcbiAgfVxuICBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0KSB7XG4gICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRoaXMuX2ZsdXNoaW5nO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXRJZCgpO1xuICAgIHRoaXMudGltZW91dHMuc2V0KGlkLCB7XG4gICAgICBzdGFydDogdGhpcy5ub3coKSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBmblxuICAgIH0pO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBjbGVhclRpbWVvdXQoaWQpIHtcbiAgICB0aGlzLl9mbHVzaGluZ0ludmFsaWRhdGVkID0gdGhpcy5fZmx1c2hpbmc7XG4gICAgdGhpcy50aW1lb3V0cy5kZWxldGUoaWQpO1xuICB9XG4gIHNldCh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX25vdyA+IHRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHRyYXZlbCBiYWNrIGluIHRpbWUnKTtcbiAgICB9XG4gICAgdGhpcy5fbm93ID0gdGltZTtcbiAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgfVxuICBmbHVzaFRpbWVvdXRzKCkge1xuICAgIGlmICh0aGlzLl9mbHVzaGluZykge1xuICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZsdXNoaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBzb3J0ZWQgPSBbLi4udGhpcy50aW1lb3V0c10uc29ydCgoW19pZEEsIHRpbWVvdXRBXSwgW19pZEIsIHRpbWVvdXRCXSkgPT4ge1xuICAgICAgY29uc3QgZW5kQSA9IHRpbWVvdXRBLnN0YXJ0ICsgdGltZW91dEEudGltZW91dDtcbiAgICAgIGNvbnN0IGVuZEIgPSB0aW1lb3V0Qi5zdGFydCArIHRpbWVvdXRCLnRpbWVvdXQ7XG4gICAgICByZXR1cm4gZW5kQiA+IGVuZEEgPyAtMSA6IDE7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBbaWQsIHRpbWVvdXRdIG9mIHNvcnRlZCkge1xuICAgICAgaWYgKHRoaXMuX2ZsdXNoaW5nSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fZmx1c2hpbmdJbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsdXNoVGltZW91dHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm93KCkgLSB0aW1lb3V0LnN0YXJ0ID49IHRpbWVvdXQudGltZW91dCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIHRpbWVvdXQuZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZmx1c2hpbmcgPSBmYWxzZTtcbiAgfVxuICBpbmNyZW1lbnQobXMpIHtcbiAgICB0aGlzLl9ub3cgKz0gbXM7XG4gICAgdGhpcy5mbHVzaFRpbWVvdXRzKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBgb3V0cHV0YCBvZiB0aGUgYWN0b3Igd2hlbiBpdCBpcyBkb25lLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IG1hY2hpbmUgPSBjcmVhdGVNYWNoaW5lKHtcbiAqICAgLy8gLi4uXG4gKiAgIG91dHB1dDoge1xuICogICAgIGNvdW50OiA0MlxuICogICB9XG4gKiB9KTtcbiAqXG4gKiBjb25zdCBhY3RvciA9IGNyZWF0ZUFjdG9yKG1hY2hpbmUpO1xuICpcbiAqIGFjdG9yLnN0YXJ0KCk7XG4gKlxuICogY29uc3Qgb3V0cHV0ID0gYXdhaXQgdG9Qcm9taXNlKGFjdG9yKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvdXRwdXQpO1xuICogLy8gbG9ncyB7IGNvdW50OiA0MiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdG9Qcm9taXNlKGFjdG9yKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYWN0b3Iuc3Vic2NyaWJlKHtcbiAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoYWN0b3IuZ2V0U25hcHNob3QoKS5vdXRwdXQpO1xuICAgICAgfSxcbiAgICAgIGVycm9yOiByZWplY3RcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCwgYSBgc25hcHNob3RgLCBhbmQgYW4gYGV2ZW50YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlLlxuICpcbiAqIFRoaXMgaXMgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgZG9lcyBub3QgZXhlY3V0ZSBgYWN0aW9uc2AuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zaXRpb24obG9naWMsIHNuYXBzaG90LCBldmVudCkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy50cmFuc2l0aW9uKHNuYXBzaG90LCBldmVudCwgYWN0b3JTY29wZSk7XG4gIHJldHVybiBbbmV4dFNuYXBzaG90LCBleGVjdXRhYmxlQWN0aW9uc107XG59XG5cbi8qKlxuICogR2l2ZW4gYWN0b3IgYGxvZ2ljYCBhbmQgb3B0aW9uYWwgYGlucHV0YCwgcmV0dXJucyBhIHR1cGxlIG9mIHRoZVxuICogYG5leHRTbmFwc2hvdGAgYW5kIGBhY3Rpb25zYCB0byBleGVjdXRlIGZyb20gdGhlIGluaXRpYWwgdHJhbnNpdGlvbiAobm9cbiAqIHByZXZpb3VzIHN0YXRlKS5cbiAqXG4gKiBUaGlzIGlzIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IGV4ZWN1dGUgYGFjdGlvbnNgLlxuICovXG5mdW5jdGlvbiBpbml0aWFsVHJhbnNpdGlvbihsb2dpYywgLi4uW2lucHV0XSkge1xuICBjb25zdCBleGVjdXRhYmxlQWN0aW9ucyA9IFtdO1xuICBjb25zdCBhY3RvclNjb3BlID0gY3JlYXRlSW5lcnRBY3RvclNjb3BlKGxvZ2ljKTtcbiAgYWN0b3JTY29wZS5hY3Rpb25FeGVjdXRvciA9IGFjdGlvbiA9PiB7XG4gICAgZXhlY3V0YWJsZUFjdGlvbnMucHVzaChhY3Rpb24pO1xuICB9O1xuICBjb25zdCBuZXh0U25hcHNob3QgPSBsb2dpYy5nZXRJbml0aWFsU25hcHNob3QoYWN0b3JTY29wZSwgaW5wdXQpO1xuICByZXR1cm4gW25leHRTbmFwc2hvdCwgZXhlY3V0YWJsZUFjdGlvbnNdO1xufVxuXG5jb25zdCBkZWZhdWx0V2FpdEZvck9wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IEluZmluaXR5IC8vIG11Y2ggbW9yZSB0aGFuIDEwIHNlY29uZHNcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyB0byBhbiBhY3RvciByZWYgYW5kIHdhaXRzIGZvciBpdHMgZW1pdHRlZCB2YWx1ZSB0byBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIHRoZW4gcmVzb2x2ZXMgd2l0aCB0aGF0IHZhbHVlLiBXaWxsIHRocm93IGlmIHRoZSBkZXNpcmVkIHN0YXRlXG4gKiBpcyBub3QgcmVhY2hlZCBhZnRlciBhbiBvcHRpb25hbCB0aW1lb3V0LiAoZGVmYXVsdHMgdG8gSW5maW5pdHkpLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHN0YXRlID0gYXdhaXQgd2FpdEZvcihzb21lU2VydmljZSwgKHN0YXRlKSA9PiB7XG4gKiAgIHJldHVybiBzdGF0ZS5oYXNUYWcoJ2xvYWRlZCcpO1xuICogfSk7XG4gKlxuICogc3RhdGUuaGFzVGFnKCdsb2FkZWQnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjdG9yUmVmIFRoZSBhY3RvciByZWYgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0gcHJlZGljYXRlIERldGVybWluZXMgaWYgYSB2YWx1ZSBtYXRjaGVzIHRoZSBjb25kaXRpb24gdG8gd2FpdCBmb3JcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCBldmVudHVhbGx5IHJlc29sdmVzIHRvIHRoZSBlbWl0dGVkIHZhbHVlIHRoYXQgbWF0Y2hlc1xuICogICB0aGUgY29uZGl0aW9uXG4gKi9cbmZ1bmN0aW9uIHdhaXRGb3IoYWN0b3JSZWYsIHByZWRpY2F0ZSwgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdFdhaXRGb3JPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSByZXNvbHZlZE9wdGlvbnM7XG4gICAgaWYgKHNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgaWYgKHJlc29sdmVkT3B0aW9ucy50aW1lb3V0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignYHRpbWVvdXRgIHBhc3NlZCB0byBgd2FpdEZvcmAgaXMgbmVnYXRpdmUgYW5kIGl0IHdpbGwgcmVqZWN0IGl0cyBpbnRlcm5hbCBwcm9taXNlIGltbWVkaWF0ZWx5LicpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGUgPSByZXNvbHZlZE9wdGlvbnMudGltZW91dCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICAgIHJlaihuZXcgRXJyb3IoYFRpbWVvdXQgb2YgJHtyZXNvbHZlZE9wdGlvbnMudGltZW91dH0gbXMgZXhjZWVkZWRgKSk7XG4gICAgfSwgcmVzb2x2ZWRPcHRpb25zLnRpbWVvdXQpO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgc3ViPy51bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKGFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjaGVja0VtaXR0ZWQoZW1pdHRlZCkge1xuICAgICAgaWYgKHByZWRpY2F0ZShlbWl0dGVkKSkge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIHJlcyhlbWl0dGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgYHNpZ25hbGAgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmUgdGhlIGxpc3RlbmVyIGZvciBpdHNcbiAgICAgKiBgYWJvcnRgIGV2ZW50XG4gICAgICovXG4gICAgbGV0IGFib3J0TGlzdGVuZXI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBzdWI7IC8vIGF2b2lkIFREWiB3aGVuIGRpc3Bvc2luZyBzeW5jaHJvbm91c2x5XG5cbiAgICAvLyBTZWUgaWYgdGhlIGN1cnJlbnQgc25hcHNob3QgYWxyZWFkeSBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAgICBjaGVja0VtaXR0ZWQoYWN0b3JSZWYuZ2V0U25hcHNob3QoKSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRlZmluZSB0aGUgYGFib3J0TGlzdGVuZXJgIGlmIHRoZSBgc2lnbmFsYCBvcHRpb24gaXMgcHJvdmlkZWRcbiAgICBpZiAoc2lnbmFsKSB7XG4gICAgICBhYm9ydExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBkaXNwb3NlKCk7XG4gICAgICAgIC8vIFhTdGF0ZSBkb2VzIG5vdCBcIm93blwiIHRoZSBzaWduYWwsIHNvIHdlIHNob3VsZCByZWplY3Qgd2l0aCBpdHMgcmVhc29uIChpZiBhbnkpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXByb21pc2UtcmVqZWN0LWVycm9yc1xuICAgICAgICByZWooc2lnbmFsLnJlYXNvbik7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgfVxuICAgIHN1YiA9IGFjdG9yUmVmLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiBjaGVja0VtaXR0ZWQsXG4gICAgICBlcnJvcjogZXJyID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1wcm9taXNlLXJlamVjdC1lcnJvcnNcbiAgICAgICAgcmVqKGVycik7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgICAgICByZWoobmV3IEVycm9yKGBBY3RvciB0ZXJtaW5hdGVkIHdpdGhvdXQgc2F0aXNmeWluZyBwcmVkaWNhdGVgKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFNpbXVsYXRlZENsb2NrLCBTdGF0ZU1hY2hpbmUsIFN0YXRlTm9kZSwgYXNzZXJ0RXZlbnQsIGNyZWF0ZU1hY2hpbmUsIGdldEluaXRpYWxTbmFwc2hvdCwgZ2V0TmV4dFNuYXBzaG90LCBpbml0aWFsVHJhbnNpdGlvbiwgc2V0dXAsIHRvUHJvbWlzZSwgdHJhbnNpdGlvbiwgd2FpdEZvciB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUVtcHR5QWN0b3IiLCJmcm9tQ2FsbGJhY2siLCJmcm9tRXZlbnRPYnNlcnZhYmxlIiwiZnJvbU9ic2VydmFibGUiLCJmcm9tUHJvbWlzZSIsImZyb21UcmFuc2l0aW9uIiwidCIsInRvQXJyYXkiLCJTIiwiU1RBVEVfREVMSU1JVEVSIiwibSIsIm1hcFZhbHVlcyIsImYiLCJmb3JtYXRUcmFuc2l0aW9ucyIsImEiLCJ0b1RyYW5zaXRpb25Db25maWdBcnJheSIsImIiLCJmb3JtYXRUcmFuc2l0aW9uIiwiTiIsIk5VTExfRVZFTlQiLCJlIiwiZXZhbHVhdGVHdWFyZCIsImMiLCJjcmVhdGVJbnZva2VJZCIsImciLCJnZXREZWxheWVkVHJhbnNpdGlvbnMiLCJkIiwiZm9ybWF0SW5pdGlhbFRyYW5zaXRpb24iLCJoIiwiZ2V0Q2FuZGlkYXRlcyIsInIiLCJyZXNvbHZlU3RhdGVWYWx1ZSIsImkiLCJnZXRBbGxTdGF0ZU5vZGVzIiwiaiIsImdldFN0YXRlTm9kZXMiLCJrIiwiY3JlYXRlTWFjaGluZVNuYXBzaG90IiwibCIsImlzSW5GaW5hbFN0YXRlIiwibiIsIm1hY3Jvc3RlcCIsIm8iLCJ0cmFuc2l0aW9uTm9kZSIsInAiLCJyZXNvbHZlQWN0aW9uc0FuZENvbnRleHQiLCJxIiwiY3JlYXRlSW5pdEV2ZW50IiwicyIsIm1pY3Jvc3RlcCIsInUiLCJnZXRJbml0aWFsU3RhdGVOb2RlcyIsInYiLCJ0b1N0YXRlUGF0aCIsInciLCJpc1N0YXRlSWQiLCJ4IiwiZ2V0U3RhdGVOb2RlQnlQYXRoIiwieSIsImdldFBlcnNpc3RlZFNuYXBzaG90IiwieiIsInJlc29sdmVSZWZlcmVuY2VkQWN0b3IiLCJBIiwiY3JlYXRlQWN0b3IiLCIkIiwiJCRBQ1RPUl9UWVBFIiwiQiIsIkFjdG9yIiwiSSIsIl9fdW5zYWZlX2dldEFsbE93bkV2ZW50RGVzY3JpcHRvcnMiLCJEIiwiYW5kIiwiTSIsImNhbmNlbCIsIkMiLCJpbnRlcnByZXQiLCJIIiwiaXNNYWNoaW5lU25hcHNob3QiLCJKIiwibWF0Y2hlc1N0YXRlIiwiRSIsIm5vdCIsIkYiLCJvciIsIksiLCJwYXRoVG9TdGF0ZVZhbHVlIiwiTyIsInJhaXNlIiwiUCIsInNwYXduQ2hpbGQiLCJHIiwic3RhdGVJbiIsIlEiLCJzdG9wIiwiUiIsInN0b3BDaGlsZCIsIkwiLCJ0b09ic2VydmVyIiwiYXNzaWduIiwiU3BlY2lhbFRhcmdldHMiLCJlbWl0IiwiZW5xdWV1ZUFjdGlvbnMiLCJmb3J3YXJkVG8iLCJsb2ciLCJzZW5kUGFyZW50Iiwic2VuZFRvIiwiYXNzZXJ0RXZlbnQiLCJldmVudCIsInR5cGUiLCJ0eXBlcyIsImluY2x1ZGVzIiwidHlwZXNUZXh0IiwibGVuZ3RoIiwiam9pbiIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImNhY2hlIiwiV2Vha01hcCIsIm1lbW8iLCJvYmplY3QiLCJrZXkiLCJmbiIsIm1lbW9pemVkRGF0YSIsImdldCIsInNldCIsIkVNUFRZX09CSkVDVCIsInRvU2VyaWFsaXphYmxlQWN0aW9uIiwiYWN0aW9uIiwibmFtZSIsIlN0YXRlTm9kZSIsIl9pbml0aWFsaXplIiwidHJhbnNpdGlvbnMiLCJjb25maWciLCJhbHdheXMiLCJtYXAiLCJPYmplY3QiLCJrZXlzIiwic3RhdGVzIiwiZm9yRWFjaCIsImRlZmluaXRpb24iLCJpZCIsInZlcnNpb24iLCJtYWNoaW5lIiwiaW5pdGlhbCIsInRhcmdldCIsInNvdXJjZSIsImFjdGlvbnMiLCJldmVudFR5cGUiLCJyZWVudGVyIiwidG9KU09OIiwidW5kZWZpbmVkIiwiaGlzdG9yeSIsInN0YXRlIiwib24iLCJ2YWx1ZXMiLCJmbGF0IiwiZW50cnkiLCJleGl0IiwibWV0YSIsIm9yZGVyIiwib3V0cHV0IiwiaW52b2tlIiwiZGVzY3JpcHRpb24iLCJ0YWdzIiwiaW52b2tlQ29uZmlnIiwic3JjIiwic3lzdGVtSWQiLCJyZXNvbHZlZElkIiwic291cmNlTmFtZSIsIm9uRG9uZSIsIm9uRXJyb3IiLCJpbnZva2VEZWZWYWx1ZXMiLCJmbGF0TWFwIiwiZGVzY3JpcHRvciIsInJlZHVjZSIsInRyYW5zaXRpb24iLCJwdXNoIiwiYWZ0ZXIiLCJuZXh0Iiwic25hcHNob3QiLCJzZWxlY3RlZFRyYW5zaXRpb24iLCJjYW5kaWRhdGVzIiwiY2FuZGlkYXRlIiwiZ3VhcmQiLCJyZXNvbHZlZENvbnRleHQiLCJjb250ZXh0IiwiZ3VhcmRQYXNzZWQiLCJlcnIiLCJndWFyZFR5cGUiLCJtZXNzYWdlIiwiZXZlbnRzIiwiU2V0Iiwib3duRXZlbnRzIiwic3RhdGVJZCIsImFkZCIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsInNvbWUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJwYXRoIiwicGFyZW50IiwiX3BhcmVudCIsIl9rZXkiLCJfbWFjaGluZSIsImNvbmNhdCIsImlkTWFwIiwic2l6ZSIsInN0YXRlQ29uZmlnIiwic3RhdGVOb2RlIiwic2xpY2UiLCJTVEFURV9JREVOVElGSUVSIiwiU3RhdGVNYWNoaW5lIiwicHJvdmlkZSIsImltcGxlbWVudGF0aW9ucyIsImd1YXJkcyIsImFjdG9ycyIsImRlbGF5cyIsInJlc29sdmVTdGF0ZSIsInJlc29sdmVkU3RhdGVWYWx1ZSIsInJvb3QiLCJ2YWx1ZSIsIm5vZGVTZXQiLCJfbm9kZXMiLCJjaGlsZHJlbiIsInN0YXR1cyIsImVycm9yIiwiaGlzdG9yeVZhbHVlIiwiYWN0b3JTY29wZSIsIm1pY3Jvc3RhdGVzIiwiZ2V0VHJhbnNpdGlvbkRhdGEiLCJnZXRQcmVJbml0aWFsU3RhdGUiLCJpbml0RXZlbnQiLCJpbnRlcm5hbFF1ZXVlIiwicHJlSW5pdGlhbCIsImFzc2lnbm1lbnQiLCJzcGF3biIsInNlbGYiLCJpbnB1dCIsImdldEluaXRpYWxTbmFwc2hvdCIsInByZUluaXRpYWxTdGF0ZSIsIm5leHRTdGF0ZSIsIm1hY3JvU3RhdGUiLCJzdGFydCIsImNoaWxkIiwiZ2V0U25hcHNob3QiLCJnZXRTdGF0ZU5vZGVCeUlkIiwiZnVsbFBhdGgiLCJyZWxhdGl2ZVBhdGgiLCJyZXNvbHZlZFN0YXRlSWQiLCJyZXN0b3JlU25hcHNob3QiLCJfYWN0b3JTY29wZSIsInNuYXBzaG90Q2hpbGRyZW4iLCJhY3RvcklkIiwiYWN0b3JEYXRhIiwiY2hpbGRTdGF0ZSIsImxvZ2ljIiwiYWN0b3JSZWYiLCJzeW5jU25hcHNob3QiLCJyZXN0b3JlZFNuYXBzaG90Iiwic2VlbiIsInJldml2ZUNvbnRleHQiLCJjb250ZXh0UGFydCIsImhhcyIsInhzdGF0ZSQkdHlwZSIsInNjaGVtYXMiLCJfX3hzdGF0ZW5vZGUiLCJNYXAiLCJiaW5kIiwiY29uc29sZSIsIndhcm4iLCJjcmVhdGVNYWNoaW5lIiwiY3JlYXRlSW5lcnRBY3RvclNjb3BlIiwiYWN0b3JMb2dpYyIsImluZXJ0QWN0b3JTY29wZSIsImRlZmVyIiwibG9nZ2VyIiwic2Vzc2lvbklkIiwic3lzdGVtIiwiYWN0aW9uRXhlY3V0b3IiLCJnZXROZXh0U25hcHNob3QiLCJfc25hcHNob3QiLCJzZXR1cCIsIlNpbXVsYXRlZENsb2NrIiwibm93IiwiX25vdyIsImdldElkIiwiX2lkIiwic2V0VGltZW91dCIsInRpbWVvdXQiLCJfZmx1c2hpbmdJbnZhbGlkYXRlZCIsIl9mbHVzaGluZyIsInRpbWVvdXRzIiwiY2xlYXJUaW1lb3V0IiwiZGVsZXRlIiwidGltZSIsImZsdXNoVGltZW91dHMiLCJzb3J0ZWQiLCJzb3J0IiwiX2lkQSIsInRpbWVvdXRBIiwiX2lkQiIsInRpbWVvdXRCIiwiZW5kQSIsImVuZEIiLCJjYWxsIiwiaW5jcmVtZW50IiwibXMiLCJ0b1Byb21pc2UiLCJhY3RvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic3Vic2NyaWJlIiwiY29tcGxldGUiLCJleGVjdXRhYmxlQWN0aW9ucyIsIm5leHRTbmFwc2hvdCIsImluaXRpYWxUcmFuc2l0aW9uIiwiZGVmYXVsdFdhaXRGb3JPcHRpb25zIiwiSW5maW5pdHkiLCJ3YWl0Rm9yIiwicHJlZGljYXRlIiwicmVzb2x2ZWRPcHRpb25zIiwicmVzIiwicmVqIiwic2lnbmFsIiwiYWJvcnRlZCIsInJlYXNvbiIsImRvbmUiLCJoYW5kbGUiLCJkaXNwb3NlIiwic3ViIiwidW5zdWJzY3JpYmUiLCJhYm9ydExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNoZWNrRW1pdHRlZCIsImVtaXR0ZWQiLCJhZGRFdmVudExpc3RlbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/xstate/dist/xstate.development.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ PresentationComlink; }\n/* harmony export */ });\n/* harmony import */ var _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/comlink */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/@sanity/comlink/dist/index.js\");\n/* harmony import */ var _sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sanity/next-loader/server-actions */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/dist/server-actions.js\");\n/* harmony import */ var next_navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/navigation.js */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var use_effect_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-effect-event */ \"(app-pages-browser)/./node_modules/use-effect-event/dist/index.js\");\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/context.js\");\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst channelsToComlinkMap = {\n    \"handshake/syn\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN,\n    \"handshake/syn-ack\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN_ACK,\n    \"handshake/ack\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_ACK,\n    \"channel/response\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_RESPONSE,\n    \"channel/heartbeat\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HEARTBEAT,\n    \"channel/disconnect\": _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_DISCONNECT,\n    \"overlay/focus\": \"visual-editing/focus\",\n    \"overlay/navigate\": \"visual-editing/navigate\",\n    \"overlay/toggle\": \"visual-editing/toggle\",\n    \"presentation/toggleOverlay\": \"presentation/toggle-overlay\"\n}, comlinkToChannelsMap = {\n    [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN]: \"handshake/syn\",\n    [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_SYN_ACK]: \"handshake/syn-ack\",\n    [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HANDSHAKE_ACK]: \"handshake/ack\",\n    [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_RESPONSE]: \"channel/response\",\n    [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_HEARTBEAT]: \"channel/heartbeat\",\n    [_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.MSG_DISCONNECT]: \"channel/disconnect\",\n    \"visual-editing/focus\": \"overlay/focus\",\n    \"visual-editing/navigate\": \"overlay/navigate\",\n    \"visual-editing/toggle\": \"overlay/toggle\",\n    \"presentation/toggle-overlay\": \"presentation/toggleOverlay\"\n}, convertToComlinkEvent = (event)=>{\n    const { data } = event;\n    var _channelsToComlinkMap_data_type;\n    return data && typeof data == \"object\" && \"domain\" in data && \"type\" in data && \"from\" in data && \"to\" in data && (data.domain === \"sanity/channels\" && (data.domain = _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.DOMAIN), data.to === \"overlays\" && (data.to = \"visual-editing\"), data.from === \"overlays\" && (data.from = \"visual-editing\"), data.channelId = data.connectionId, delete data.connectionId, data.type = (_channelsToComlinkMap_data_type = channelsToComlinkMap[data.type]) !== null && _channelsToComlinkMap_data_type !== void 0 ? _channelsToComlinkMap_data_type : data.type), event;\n}, convertToChannelsMessage = (comlinkMessage)=>{\n    const { channelId, ...rest } = comlinkMessage, message = {\n        ...rest,\n        connectionId: channelId\n    };\n    var _comlinkToChannelsMap_message_type;\n    return message.domain === _sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.DOMAIN && (message.domain = \"sanity/channels\"), message.to === \"visual-editing\" && (message.to = \"overlays\"), message.from === \"visual-editing\" && (message.from = \"overlays\"), message.type = (_comlinkToChannelsMap_message_type = comlinkToChannelsMap[message.type]) !== null && _comlinkToChannelsMap_message_type !== void 0 ? _comlinkToChannelsMap_message_type : message.type, message.type === \"channel/response\" && message.responseTo && !message.data && (message.data = {\n        responseTo: message.responseTo\n    }), (message.type === \"handshake/syn\" || message.type === \"handshake/syn-ack\" || message.type === \"handshake/ack\") && (message.data = {\n        id: message.connectionId\n    }), message;\n}, sendAsChannelsMessage = (param, params)=>{\n    let { context } = param;\n    const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);\n    sources.forEach((source)=>{\n        source.postMessage(message, {\n            targetOrigin\n        });\n    });\n}, createCompatibilityActors = ()=>({\n        listen: (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createListenLogic)(convertToComlinkEvent),\n        requestMachine: (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createRequestMachine)().provide({\n            actions: {\n                \"send message\": sendAsChannelsMessage\n            }\n        })\n    });\nfunction PresentationComlink(props) {\n    _s();\n    const { draftModeEnabled, draftModePerspective } = props, router = (0,next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter)(), handlePerspectiveChange = (0,use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent)((perspective, signal)=>{\n        draftModeEnabled && perspective !== draftModePerspective && (0,_sanity_next_loader_server_actions__WEBPACK_IMPORTED_MODULE_4__.setPerspectiveCookie)(perspective).then(()=>{\n            signal.aborted || router.refresh();\n        }).catch((reason)=>console.error(\"Failed to set the preview perspective cookie\", reason));\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const comlink = (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createNode)({\n            name: \"loaders\",\n            connectTo: \"presentation\"\n        }, (0,_sanity_comlink__WEBPACK_IMPORTED_MODULE_2__.createNodeMachine)().provide({\n            actors: createCompatibilityActors()\n        }));\n        let controller;\n        comlink.on(\"loader/perspective\", (data)=>{\n            controller === null || controller === void 0 ? void 0 : controller.abort(), controller = new AbortController(), handlePerspectiveChange(data.perspective, controller.signal);\n        });\n        const stop = comlink.start();\n        return (0,_context_js__WEBPACK_IMPORTED_MODULE_5__.setComlink)(comlink), ()=>{\n            stop();\n        };\n    }, [\n        handlePerspectiveChange\n    ]), null;\n}\n_s(PresentationComlink, \"qqHdflQf5sWnk36yDuYay755tlU=\", false, function() {\n    return [\n        next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter,\n        use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent,\n        next_navigation_js__WEBPACK_IMPORTED_MODULE_0__.useRouter,\n        use_effect_event__WEBPACK_IMPORTED_MODULE_3__.useEffectEvent\n    ];\n});\n_c = PresentationComlink;\nPresentationComlink.displayName = \"PresentationComlink\";\n //# sourceMappingURL=PresentationComlink.js.map\nvar _c;\n$RefreshReg$(_c, \"PresentationComlink\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL2Rpc3QvX2NodW5rcy1lcy9QcmVzZW50YXRpb25Db21saW5rLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTJOO0FBQ2pKO0FBQzNCO0FBQ2I7QUFDZ0I7QUFDUjtBQUMxQyxNQUFNZ0IsdUJBQXVCO0lBQzNCLGlCQUFpQmIsOERBQWlCQTtJQUNsQyxxQkFBcUJDLGtFQUFxQkE7SUFDMUMsaUJBQWlCQyw4REFBaUJBO0lBQ2xDLG9CQUFvQkMseURBQVlBO0lBQ2hDLHFCQUFxQkMsMERBQWFBO0lBQ2xDLHNCQUFzQkMsMkRBQWNBO0lBQ3BDLGlCQUFpQjtJQUNqQixvQkFBb0I7SUFDcEIsa0JBQWtCO0lBQ2xCLDhCQUE4QjtBQUNoQyxHQUFHUyx1QkFBdUI7SUFDeEIsQ0FBQ2QsOERBQWlCQSxDQUFDLEVBQUU7SUFDckIsQ0FBQ0Msa0VBQXFCQSxDQUFDLEVBQUU7SUFDekIsQ0FBQ0MsOERBQWlCQSxDQUFDLEVBQUU7SUFDckIsQ0FBQ0MseURBQVlBLENBQUMsRUFBRTtJQUNoQixDQUFDQywwREFBYUEsQ0FBQyxFQUFFO0lBQ2pCLENBQUNDLDJEQUFjQSxDQUFDLEVBQUU7SUFDbEIsd0JBQXdCO0lBQ3hCLDJCQUEyQjtJQUMzQix5QkFBeUI7SUFDekIsK0JBQStCO0FBQ2pDLEdBQUdVLHdCQUF3QixDQUFDQztJQUMxQixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHRDtRQUM2Vkg7SUFBOVcsT0FBT0ksUUFBUSxPQUFPQSxRQUFRLFlBQVksWUFBWUEsUUFBUSxVQUFVQSxRQUFRLFVBQVVBLFFBQVEsUUFBUUEsUUFBU0EsQ0FBQUEsS0FBS0MsTUFBTSxLQUFLLHFCQUFzQkQsQ0FBQUEsS0FBS0MsTUFBTSxHQUFHbkIsbURBQUssR0FBSWtCLEtBQUtFLEVBQUUsS0FBSyxjQUFlRixDQUFBQSxLQUFLRSxFQUFFLEdBQUcsZ0JBQWUsR0FBSUYsS0FBS0csSUFBSSxL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QUFRUyxLQUFLO1FBQzFCLE9BQU92RCx1REFBVUEsQ0FBQzhDLFVBQVU7WUFDMUJRO1FBQ0Y7SUFDRixHQUFHO1FBQUNsQjtLQUF3QixHQUFHO0FBQ2pDO0dBM0JTTDs7UUFDNERsQyx5REFBU0E7UUFBOEJFLDREQUFjQTtRQUFyREYseURBQVNBO1FBQThCRSw0REFBY0E7OztLQURqSGdDO0FBNEJUQSxvQkFBb0J5QixXQUFXLEdBQUc7QUFHaEMsQ0FDRiwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvZGlzdC9fY2h1bmtzLWVzL1ByZXNlbnRhdGlvbkNvbWxpbmsuanM/ZTVjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVMaXN0ZW5Mb2dpYywgY3JlYXRlUmVxdWVzdE1hY2hpbmUsIERPTUFJTiwgTVNHX0hBTkRTSEFLRV9TWU4sIE1TR19IQU5EU0hBS0VfU1lOX0FDSywgTVNHX0hBTkRTSEFLRV9BQ0ssIE1TR19SRVNQT05TRSwgTVNHX0hFQVJUQkVBVCwgTVNHX0RJU0NPTk5FQ1QsIGNyZWF0ZU5vZGUsIGNyZWF0ZU5vZGVNYWNoaW5lIH0gZnJvbSBcIkBzYW5pdHkvY29tbGlua1wiO1xuaW1wb3J0IHsgc2V0UGVyc3BlY3RpdmVDb29raWUgfSBmcm9tIFwiQHNhbml0eS9uZXh0LWxvYWRlci9zZXJ2ZXItYWN0aW9uc1wiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3RFdmVudCB9IGZyb20gXCJ1c2UtZWZmZWN0LWV2ZW50XCI7XG5pbXBvcnQgeyBzZXRDb21saW5rIH0gZnJvbSBcIi4vY29udGV4dC5qc1wiO1xuY29uc3QgY2hhbm5lbHNUb0NvbWxpbmtNYXAgPSB7XG4gIFwiaGFuZHNoYWtlL3N5blwiOiBNU0dfSEFORFNIQUtFX1NZTixcbiAgXCJoYW5kc2hha2Uvc3luLWFja1wiOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0ssXG4gIFwiaGFuZHNoYWtlL2Fja1wiOiBNU0dfSEFORFNIQUtFX0FDSyxcbiAgXCJjaGFubmVsL3Jlc3BvbnNlXCI6IE1TR19SRVNQT05TRSxcbiAgXCJjaGFubmVsL2hlYXJ0YmVhdFwiOiBNU0dfSEVBUlRCRUFULFxuICBcImNoYW5uZWwvZGlzY29ubmVjdFwiOiBNU0dfRElTQ09OTkVDVCxcbiAgXCJvdmVybGF5L2ZvY3VzXCI6IFwidmlzdWFsLWVkaXRpbmcvZm9jdXNcIixcbiAgXCJvdmVybGF5L25hdmlnYXRlXCI6IFwidmlzdWFsLWVkaXRpbmcvbmF2aWdhdGVcIixcbiAgXCJvdmVybGF5L3RvZ2dsZVwiOiBcInZpc3VhbC1lZGl0aW5nL3RvZ2dsZVwiLFxuICBcInByZXNlbnRhdGlvbi90b2dnbGVPdmVybGF5XCI6IFwicHJlc2VudGF0aW9uL3RvZ2dsZS1vdmVybGF5XCJcbn0sIGNvbWxpbmtUb0NoYW5uZWxzTWFwID0ge1xuICBbTVNHX0hBTkRTSEFLRV9TWU5dOiBcImhhbmRzaGFrZS9zeW5cIixcbiAgW01TR19IQU5EU0hBS0VfU1lOX0FDS106IFwiaGFuZHNoYWtlL3N5bi1hY2tcIixcbiAgW01TR19IQU5EU0hBS0VfQUNLXTogXCJoYW5kc2hha2UvYWNrXCIsXG4gIFtNU0dfUkVTUE9OU0VdOiBcImNoYW5uZWwvcmVzcG9uc2VcIixcbiAgW01TR19IRUFSVEJFQVRdOiBcImNoYW5uZWwvaGVhcnRiZWF0XCIsXG4gIFtNU0dfRElTQ09OTkVDVF06IFwiY2hhbm5lbC9kaXNjb25uZWN0XCIsXG4gIFwidmlzdWFsLWVkaXRpbmcvZm9jdXNcIjogXCJvdmVybGF5L2ZvY3VzXCIsXG4gIFwidmlzdWFsLWVkaXRpbmcvbmF2aWdhdGVcIjogXCJvdmVybGF5L25hdmlnYXRlXCIsXG4gIFwidmlzdWFsLWVkaXRpbmcvdG9nZ2xlXCI6IFwib3ZlcmxheS90b2dnbGVcIixcbiAgXCJwcmVzZW50YXRpb24vdG9nZ2xlLW92ZXJsYXlcIjogXCJwcmVzZW50YXRpb24vdG9nZ2xlT3ZlcmxheVwiXG59LCBjb252ZXJ0VG9Db21saW5rRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBldmVudDtcbiAgcmV0dXJuIGRhdGEgJiYgdHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIiAmJiBcImRvbWFpblwiIGluIGRhdGEgJiYgXCJ0eXBlXCIgaW4gZGF0YSAmJiBcImZyb21cIiBpbiBkYXRhICYmIFwidG9cIiBpbiBkYXRhICYmIChkYXRhLmRvbWFpbiA9PT0gXCJzYW5pdHkvY2hhbm5lbHNcIiAmJiAoZGF0YS5kb21haW4gPSBET01BSU4pLCBkYXRhLnRvID09PSBcIm92ZXJsYXlzXCIgJiYgKGRhdGEudG8gPSBcInZpc3VhbC1lZGl0aW5nXCIpLCBkYXRhLmZyb20gPT09IFwib3ZlcmxheXNcIiAmJiAoZGF0YS5mcm9tID0gXCJ2aXN1YWwtZWRpdGluZ1wiKSwgZGF0YS5jaGFubmVsSWQgPSBkYXRhLmNvbm5lY3Rpb25JZCwgZGVsZXRlIGRhdGEuY29ubmVjdGlvbklkLCBkYXRhLnR5cGUgPSBjaGFubmVsc1RvQ29tbGlua01hcFtkYXRhLnR5cGVdID8/IGRhdGEudHlwZSksIGV2ZW50O1xufSwgY29udmVydFRvQ2hhbm5lbHNNZXNzYWdlID0gKGNvbWxpbmtNZXNzYWdlKSA9PiB7XG4gIGNvbnN0IHsgY2hhbm5lbElkLCAuLi5yZXN0IH0gPSBjb21saW5rTWVzc2FnZSwgbWVzc2FnZSA9IHsgLi4ucmVzdCwgY29ubmVjdGlvbklkOiBjaGFubmVsSWQgfTtcbiAgcmV0dXJuIG1lc3NhZ2UuZG9tYWluID09PSBET01BSU4gJiYgKG1lc3NhZ2UuZG9tYWluID0gXCJzYW5pdHkvY2hhbm5lbHNcIiksIG1lc3NhZ2UudG8gPT09IFwidmlzdWFsLWVkaXRpbmdcIiAmJiAobWVzc2FnZS50byA9IFwib3ZlcmxheXNcIiksIG1lc3NhZ2UuZnJvbSA9PT0gXCJ2aXN1YWwtZWRpdGluZ1wiICYmIChtZXNzYWdlLmZyb20gPSBcIm92ZXJsYXlzXCIpLCBtZXNzYWdlLnR5cGUgPSBjb21saW5rVG9DaGFubmVsc01hcFttZXNzYWdlLnR5cGVdID8/IG1lc3NhZ2UudHlwZSwgbWVzc2FnZS50eXBlID09PSBcImNoYW5uZWwvcmVzcG9uc2VcIiAmJiBtZXNzYWdlLnJlc3BvbnNlVG8gJiYgIW1lc3NhZ2UuZGF0YSAmJiAobWVzc2FnZS5kYXRhID0geyByZXNwb25zZVRvOiBtZXNzYWdlLnJlc3BvbnNlVG8gfSksIChtZXNzYWdlLnR5cGUgPT09IFwiaGFuZHNoYWtlL3N5blwiIHx8IG1lc3NhZ2UudHlwZSA9PT0gXCJoYW5kc2hha2Uvc3luLWFja1wiIHx8IG1lc3NhZ2UudHlwZSA9PT0gXCJoYW5kc2hha2UvYWNrXCIpICYmIChtZXNzYWdlLmRhdGEgPSB7IGlkOiBtZXNzYWdlLmNvbm5lY3Rpb25JZCB9KSwgbWVzc2FnZTtcbn0sIHNlbmRBc0NoYW5uZWxzTWVzc2FnZSA9ICh7IGNvbnRleHQgfSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHsgc291cmNlcywgdGFyZ2V0T3JpZ2luIH0gPSBjb250ZXh0LCBtZXNzYWdlID0gY29udmVydFRvQ2hhbm5lbHNNZXNzYWdlKHBhcmFtcy5tZXNzYWdlKTtcbiAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICBzb3VyY2UucG9zdE1lc3NhZ2UobWVzc2FnZSwgeyB0YXJnZXRPcmlnaW4gfSk7XG4gIH0pO1xufSwgY3JlYXRlQ29tcGF0aWJpbGl0eUFjdG9ycyA9ICgpID0+ICh7XG4gIGxpc3RlbjogY3JlYXRlTGlzdGVuTG9naWMoY29udmVydFRvQ29tbGlua0V2ZW50KSxcbiAgcmVxdWVzdE1hY2hpbmU6IGNyZWF0ZVJlcXVlc3RNYWNoaW5lKCkucHJvdmlkZSh7XG4gICAgYWN0aW9uczoge1xuICAgICAgXCJzZW5kIG1lc3NhZ2VcIjogc2VuZEFzQ2hhbm5lbHNNZXNzYWdlXG4gICAgfVxuICB9KVxufSk7XG5mdW5jdGlvbiBQcmVzZW50YXRpb25Db21saW5rKHByb3BzKSB7XG4gIGNvbnN0IHsgZHJhZnRNb2RlRW5hYmxlZCwgZHJhZnRNb2RlUGVyc3BlY3RpdmUgfSA9IHByb3BzLCByb3V0ZXIgPSB1c2VSb3V0ZXIoKSwgaGFuZGxlUGVyc3BlY3RpdmVDaGFuZ2UgPSB1c2VFZmZlY3RFdmVudChcbiAgICAocGVyc3BlY3RpdmUsIHNpZ25hbCkgPT4ge1xuICAgICAgZHJhZnRNb2RlRW5hYmxlZCAmJiBwZXJzcGVjdGl2ZSAhPT0gZHJhZnRNb2RlUGVyc3BlY3RpdmUgJiYgc2V0UGVyc3BlY3RpdmVDb29raWUocGVyc3BlY3RpdmUpLnRoZW4oKCkgPT4ge1xuICAgICAgICBzaWduYWwuYWJvcnRlZCB8fCByb3V0ZXIucmVmcmVzaCgpO1xuICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4gY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZXQgdGhlIHByZXZpZXcgcGVyc3BlY3RpdmUgY29va2llXCIsIHJlYXNvbikpO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY29tbGluayA9IGNyZWF0ZU5vZGUoXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwibG9hZGVyc1wiLFxuICAgICAgICBjb25uZWN0VG86IFwicHJlc2VudGF0aW9uXCJcbiAgICAgIH0sXG4gICAgICBjcmVhdGVOb2RlTWFjaGluZSgpLnByb3ZpZGUoe1xuICAgICAgICBhY3RvcnM6IGNyZWF0ZUNvbXBhdGliaWxpdHlBY3RvcnMoKVxuICAgICAgfSlcbiAgICApO1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGNvbWxpbmsub24oXCJsb2FkZXIvcGVyc3BlY3RpdmVcIiwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnRyb2xsZXI/LmFib3J0KCksIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCksIGhhbmRsZVBlcnNwZWN0aXZlQ2hhbmdlKGRhdGEucGVyc3BlY3RpdmUsIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICB9KTtcbiAgICBjb25zdCBzdG9wID0gY29tbGluay5zdGFydCgpO1xuICAgIHJldHVybiBzZXRDb21saW5rKGNvbWxpbmspLCAoKSA9PiB7XG4gICAgICBzdG9wKCk7XG4gICAgfTtcbiAgfSwgW2hhbmRsZVBlcnNwZWN0aXZlQ2hhbmdlXSksIG51bGw7XG59XG5QcmVzZW50YXRpb25Db21saW5rLmRpc3BsYXlOYW1lID0gXCJQcmVzZW50YXRpb25Db21saW5rXCI7XG5leHBvcnQge1xuICBQcmVzZW50YXRpb25Db21saW5rIGFzIGRlZmF1bHRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QcmVzZW50YXRpb25Db21saW5rLmpzLm1hcFxuIl0sIm5hbWVzIjpbImNyZWF0ZUxpc3RlbkxvZ2ljIiwiY3JlYXRlUmVxdWVzdE1hY2hpbmUiLCJET01BSU4iLCJNU0dfSEFORFNIQUtFX1NZTiIsIk1TR19IQU5EU0hBS0VfU1lOX0FDSyIsIk1TR19IQU5EU0hBS0VfQUNLIiwiTVNHX1JFU1BPTlNFIiwiTVNHX0hFQVJUQkVBVCIsIk1TR19ESVNDT05ORUNUIiwiY3JlYXRlTm9kZSIsImNyZWF0ZU5vZGVNYWNoaW5lIiwic2V0UGVyc3BlY3RpdmVDb29raWUiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VFZmZlY3RFdmVudCIsInNldENvbWxpbmsiLCJjaGFubmVsc1RvQ29tbGlua01hcCIsImNvbWxpbmtUb0NoYW5uZWxzTWFwIiwiY29udmVydFRvQ29tbGlua0V2ZW50IiwiZXZlbnQiLCJkYXRhIiwiZG9tYWluIiwidG8iLCJmcm9tIiwiY2hhbm5lbElkIiwiY29ubmVjdGlvbklkIiwidHlwZSIsImNvbnZlcnRUb0NoYW5uZWxzTWVzc2FnZSIsImNvbWxpbmtNZXNzYWdlIiwicmVzdCIsIm1lc3NhZ2UiLCJyZXNwb25zZVRvIiwiaWQiLCJzZW5kQXNDaGFubmVsc01lc3NhZ2UiLCJwYXJhbXMiLCJjb250ZXh0Iiwic291cmNlcyIsInRhcmdldE9yaWdpbiIsImZvckVhY2giLCJzb3VyY2UiLCJwb3N0TWVzc2FnZSIsImNyZWF0ZUNvbXBhdGliaWxpdHlBY3RvcnMiLCJsaXN0ZW4iLCJyZXF1ZXN0TWFjaGluZSIsInByb3ZpZGUiLCJhY3Rpb25zIiwiUHJlc2VudGF0aW9uQ29tbGluayIsInByb3BzIiwiZHJhZnRNb2RlRW5hYmxlZCIsImRyYWZ0TW9kZVBlcnNwZWN0aXZlIiwicm91dGVyIiwiaGFuZGxlUGVyc3BlY3RpdmVDaGFuZ2UiLCJwZXJzcGVjdGl2ZSIsInNpZ25hbCIsInRoZW4iLCJhYm9ydGVkIiwicmVmcmVzaCIsImNhdGNoIiwicmVhc29uIiwiY29uc29sZSIsImVycm9yIiwiY29tbGluayIsIm5hbWUiLCJjb25uZWN0VG8iLCJhY3RvcnMiLCJjb250cm9sbGVyIiwib24iLCJhYm9ydCIsIkFib3J0Q29udHJvbGxlciIsInN0b3AiLCJzdGFydCIsImRpc3BsYXlOYW1lIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/dist/_chunks-es/PresentationComlink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/@sanity/comlink/dist/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/@sanity/comlink/dist/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DOMAIN: function() { return /* binding */ DOMAIN; },\n/* harmony export */   FETCH_TIMEOUT_DEFAULT: function() { return /* binding */ FETCH_TIMEOUT_DEFAULT; },\n/* harmony export */   HANDSHAKE_INTERVAL: function() { return /* binding */ HANDSHAKE_INTERVAL; },\n/* harmony export */   HANDSHAKE_MSG_TYPES: function() { return /* binding */ HANDSHAKE_MSG_TYPES; },\n/* harmony export */   HEARTBEAT_INTERVAL: function() { return /* binding */ HEARTBEAT_INTERVAL; },\n/* harmony export */   INTERNAL_MSG_TYPES: function() { return /* binding */ INTERNAL_MSG_TYPES; },\n/* harmony export */   MSG_DISCONNECT: function() { return /* binding */ MSG_DISCONNECT; },\n/* harmony export */   MSG_HANDSHAKE_ACK: function() { return /* binding */ MSG_HANDSHAKE_ACK; },\n/* harmony export */   MSG_HANDSHAKE_SYN: function() { return /* binding */ MSG_HANDSHAKE_SYN; },\n/* harmony export */   MSG_HANDSHAKE_SYN_ACK: function() { return /* binding */ MSG_HANDSHAKE_SYN_ACK; },\n/* harmony export */   MSG_HEARTBEAT: function() { return /* binding */ MSG_HEARTBEAT; },\n/* harmony export */   MSG_RESPONSE: function() { return /* binding */ MSG_RESPONSE; },\n/* harmony export */   RESPONSE_TIMEOUT_DEFAULT: function() { return /* binding */ RESPONSE_TIMEOUT_DEFAULT; },\n/* harmony export */   createConnection: function() { return /* binding */ createConnection; },\n/* harmony export */   createConnectionMachine: function() { return /* binding */ createConnectionMachine; },\n/* harmony export */   createController: function() { return /* binding */ createController; },\n/* harmony export */   createListenLogic: function() { return /* binding */ createListenLogic; },\n/* harmony export */   createNode: function() { return /* binding */ createNode; },\n/* harmony export */   createNodeMachine: function() { return /* binding */ createNodeMachine; },\n/* harmony export */   createRequestMachine: function() { return /* binding */ createRequestMachine; }\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/actors/dist/xstate-actors.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/dist/xstate.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/dist/log-0acd9069.development.esm.js\");\n/* harmony import */ var xstate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! xstate */ \"(app-pages-browser)/./node_modules/xstate/dist/raise-1db27a82.development.esm.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/map.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/util/pipe.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/filter.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/bufferCount.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/take.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=EMPTY,bufferCount,concatMap,defer,filter,fromEvent,map,pipe,take,takeUntil!=!rxjs */ \"(app-pages-browser)/./node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js\");\n\n\n\nconst listenInputFromContext = (config)=>(param)=>{\n        let { context } = param;\n        const { count, include, exclude, responseType = \"message.received\" } = config;\n        return {\n            count,\n            domain: context.domain,\n            from: context.connectTo,\n            include: include ? Array.isArray(include) ? include : [\n                include\n            ] : [],\n            exclude: exclude ? Array.isArray(exclude) ? exclude : [\n                exclude\n            ] : [],\n            responseType,\n            target: context.target,\n            to: context.name\n        };\n    }, listenFilter = (input)=>(event)=>{\n        const { data } = event;\n        return (input.include.length ? input.include.includes(data.type) : !0) && (input.exclude.length ? !input.exclude.includes(data.type) : !0) && data.domain === input.domain && data.from === input.from && data.to === input.to && (!input.target || event.source === input.target);\n    }, eventToMessage = (type)=>(event)=>({\n            type,\n            message: event\n        }), messageEvents$ = (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_0__.defer)(()=>(0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, \"message\")), createListenLogic = (compatMap)=>(0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromEventObservable)((param)=>{\n        let { input } = param;\n        return messageEvents$.pipe(compatMap ? (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(compatMap) : (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)(), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(listenFilter(input)), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(eventToMessage(input.responseType)), input.count ? (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)((0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_6__.bufferCount)(input.count), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_7__.concatMap)((arr)=>arr), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(input.count)) : (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_4__.pipe)());\n    }), DOMAIN = \"sanity/comlink\", RESPONSE_TIMEOUT_DEFAULT = 3e3, FETCH_TIMEOUT_DEFAULT = 1e4, HEARTBEAT_INTERVAL = 1e3, HANDSHAKE_INTERVAL = 500, MSG_RESPONSE = \"comlink/response\", MSG_HEARTBEAT = \"comlink/heartbeat\", MSG_DISCONNECT = \"comlink/disconnect\", MSG_HANDSHAKE_SYN = \"comlink/handshake/syn\", MSG_HANDSHAKE_SYN_ACK = \"comlink/handshake/syn-ack\", MSG_HANDSHAKE_ACK = \"comlink/handshake/ack\", HANDSHAKE_MSG_TYPES = [\n    MSG_HANDSHAKE_SYN,\n    MSG_HANDSHAKE_SYN_ACK,\n    MSG_HANDSHAKE_ACK\n], INTERNAL_MSG_TYPES = [\n    MSG_RESPONSE,\n    MSG_DISCONNECT,\n    MSG_HEARTBEAT,\n    ...HANDSHAKE_MSG_TYPES\n], throwOnEvent = (message)=>(source)=>source.pipe((0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(1), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_3__.map)(()=>{\n            throw new Error(message);\n        })), createRequestMachine = ()=>(0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n        types: {},\n        actors: {\n            listen: (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromEventObservable)((param)=>{\n                let { input } = param;\n                const abortSignal$ = input.signal ? (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(input.signal, \"abort\").pipe(throwOnEvent(\"Request \".concat(input.requestId, \" aborted\"))) : _barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_10__.EMPTY, messageFilter = (event)=>{\n                    var _event_data, _event_data1;\n                    return ((_event_data = event.data) === null || _event_data === void 0 ? void 0 : _event_data.type) === MSG_RESPONSE && ((_event_data1 = event.data) === null || _event_data1 === void 0 ? void 0 : _event_data1.responseTo) === input.requestId && !!event.source && input.sources.has(event.source);\n                };\n                return (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, \"message\").pipe((0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_5__.filter)(messageFilter), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_8__.take)(input.sources.size), (0,_barrel_optimize_names_EMPTY_bufferCount_concatMap_defer_filter_fromEvent_map_pipe_take_takeUntil_rxjs__WEBPACK_IMPORTED_MODULE_11__.takeUntil)(abortSignal$));\n            })\n        },\n        actions: {\n            \"send message\": (param, params)=>{\n                let { context } = param;\n                const { sources, targetOrigin } = context, { message } = params;\n                sources.forEach((source)=>{\n                    source.postMessage(message, {\n                        targetOrigin\n                    });\n                });\n            },\n            \"on success\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)((param)=>{\n                let { context } = param;\n                return context.parentRef;\n            }, (param)=>{\n                let { context, self } = param;\n                var _context_resolvable;\n                return context.response && ((_context_resolvable = context.resolvable) === null || _context_resolvable === void 0 ? void 0 : _context_resolvable.resolve(context.response)), {\n                    type: \"request.success\",\n                    requestId: self.id,\n                    response: context.response,\n                    responseTo: context.responseTo\n                };\n            }),\n            \"on fail\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)((param)=>{\n                let { context } = param;\n                return context.parentRef;\n            }, (param)=>{\n                let { context, self } = param;\n                var _context_resolvable;\n                return context.suppressWarnings || console.warn(\"[@sanity/comlink] Received no response to message '\".concat(context.type, \"' on client '\").concat(context.from, \"' (ID: '\").concat(context.id, \"').\")), (_context_resolvable = context.resolvable) === null || _context_resolvable === void 0 ? void 0 : _context_resolvable.reject(new Error(\"No response received\")), {\n                    type: \"request.failed\",\n                    requestId: self.id\n                };\n            }),\n            \"on abort\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.c)((param)=>{\n                let { context } = param;\n                return context.parentRef;\n            }, (param)=>{\n                let { context, self } = param;\n                var _context_resolvable;\n                return (_context_resolvable = context.resolvable) === null || _context_resolvable === void 0 ? void 0 : _context_resolvable.reject(new Error(\"Request aborted\")), {\n                    type: \"request.aborted\",\n                    requestId: self.id\n                };\n            })\n        },\n        guards: {\n            expectsResponse: (param)=>{\n                let { context } = param;\n                return context.expectResponse;\n            }\n        },\n        delays: {\n            initialTimeout: 0,\n            responseTimeout: (param)=>{\n                let { context } = param;\n                var _context_responseTimeout;\n                return (_context_responseTimeout = context.responseTimeout) !== null && _context_responseTimeout !== void 0 ? _context_responseTimeout : RESPONSE_TIMEOUT_DEFAULT;\n            }\n        }\n    }).createMachine({\n        /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAOlwgBswBiAD1gBd0GwT0AzFgJ2QNwdzoKAFVyowAewCuDItTRY8hUuSoBtAAwBdRKAAOE2P1wT8ukLUQBGAEwBWEgBYAnK+eOAzB7sB2DzY8rABoQAE9rDQc3V0cNTw8fAA4NHwBfVJCFHAJiElgwfAgCKGpNHSQQAyMBU3NLBDsrDxI7DTaAjQA2OOcNDxDwhHsNJx9Ou0TOq2cJxP9HdMyMbOU8gqL8ErUrcv1DY1qK+sbm1vaPLp6+gcRnGydo9wDGycWQLKVc9AB3dGNN6jiWCwdAwMrmKoHMxHRCJRKOEiJHwuZKBZwXKzBMKIGyYkhtAkXOweTqOHw2RJvD45Ug-P4CAH0JgsNicMA8LhwAz4fKicTSWTyZafWm-f5QcEVSE1aGgepwhFIlF9aYYrGDC4+JzEppjGzOUkeGbpDIgfASCBwczU5QQ-YyuqIAC0nRuCBd+IJXu9KSpwppZEoYDt1RMsosiEcNjdVjiJEeGisiSTHkcVgWpptuXyhWKIahjqGzi1BqRJINnVcdkcbuTLS9VYC8ISfsUAbp4vzDphCHJIyjBvJNlxNmRNexQ3sJGH43GPj8jWJrZWuXYfyoEC7YcLsbrgRsjkcvkmdgNbopVhIPhVfnsh8ClMz-tWsCkmEwcHgUvt257u8v+6Hse4xnhOdZnImVidPqCRNB4JqpEAA */ context: (param)=>{\n            let { input } = param;\n            var _input_expectResponse;\n            return {\n                channelId: input.channelId,\n                data: input.data,\n                domain: input.domain,\n                expectResponse: (_input_expectResponse = input.expectResponse) !== null && _input_expectResponse !== void 0 ? _input_expectResponse : !1,\n                from: input.from,\n                id: \"msg-\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()),\n                parentRef: input.parentRef,\n                resolvable: input.resolvable,\n                response: null,\n                responseTimeout: input.responseTimeout,\n                responseTo: input.responseTo,\n                signal: input.signal,\n                sources: input.sources instanceof Set ? input.sources : /* @__PURE__ */ new Set([\n                    input.sources\n                ]),\n                suppressWarnings: input.suppressWarnings,\n                targetOrigin: input.targetOrigin,\n                to: input.to,\n                type: input.type\n            };\n        },\n        initial: \"idle\",\n        on: {\n            abort: \".aborted\"\n        },\n        states: {\n            idle: {\n                after: {\n                    initialTimeout: [\n                        {\n                            target: \"sending\"\n                        }\n                    ]\n                }\n            },\n            sending: {\n                entry: {\n                    type: \"send message\",\n                    params: (param)=>{\n                        let { context } = param;\n                        const { channelId, data, domain, from, id, responseTo, to, type } = context;\n                        return {\n                            message: {\n                                channelId,\n                                data,\n                                domain,\n                                from,\n                                id,\n                                to,\n                                type,\n                                responseTo\n                            }\n                        };\n                    }\n                },\n                always: [\n                    {\n                        guard: \"expectsResponse\",\n                        target: \"awaiting\"\n                    },\n                    \"success\"\n                ]\n            },\n            awaiting: {\n                invoke: {\n                    id: \"listen for response\",\n                    src: \"listen\",\n                    input: (param)=>{\n                        let { context } = param;\n                        return {\n                            requestId: context.id,\n                            sources: context.sources,\n                            signal: context.signal\n                        };\n                    },\n                    onError: \"aborted\"\n                },\n                after: {\n                    responseTimeout: \"failed\"\n                },\n                on: {\n                    message: {\n                        actions: (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n                            response: (param)=>{\n                                let { event } = param;\n                                return event.data.data;\n                            },\n                            responseTo: (param)=>{\n                                let { event } = param;\n                                return event.data.responseTo;\n                            }\n                        }),\n                        target: \"success\"\n                    }\n                }\n            },\n            failed: {\n                type: \"final\",\n                entry: \"on fail\"\n            },\n            success: {\n                type: \"final\",\n                entry: \"on success\"\n            },\n            aborted: {\n                type: \"final\",\n                entry: \"on abort\"\n            }\n        },\n        output: (param)=>{\n            let { context, self } = param;\n            return {\n                requestId: self.id,\n                response: context.response,\n                responseTo: context.responseTo\n            };\n        }\n    }), sendBackAtInterval = (0,xstate__WEBPACK_IMPORTED_MODULE_2__.fromCallback)((param)=>{\n    let { sendBack, input } = param;\n    const send = ()=>{\n        sendBack(input.event);\n    };\n    input.immediate && send();\n    const interval = setInterval(send, input.interval);\n    return ()=>{\n        clearInterval(interval);\n    };\n}), createConnectionMachine = ()=>(0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n        types: {},\n        actors: {\n            requestMachine: createRequestMachine(),\n            listen: createListenLogic(),\n            sendBackAtInterval\n        },\n        actions: {\n            \"buffer message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { enqueue } = param;\n                enqueue.assign({\n                    buffer: (param)=>{\n                        let { event, context } = param;\n                        return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), [\n                            ...context.buffer,\n                            event.data\n                        ];\n                    }\n                }), enqueue.emit((param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n                        type: \"_buffer.added\",\n                        message: event.data\n                    };\n                });\n            }),\n            \"create request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n                requests: (param)=>{\n                    let { context, event, self, spawn } = param;\n                    (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"request\");\n                    const requests = (Array.isArray(event.data) ? event.data : [\n                        event.data\n                    ]).map((request)=>{\n                        const id = \"req-\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])());\n                        return spawn(\"requestMachine\", {\n                            id,\n                            input: {\n                                channelId: context.channelId,\n                                data: request.data,\n                                domain: context.domain,\n                                expectResponse: request.expectResponse,\n                                from: context.name,\n                                parentRef: self,\n                                responseTo: request.responseTo,\n                                sources: context.target,\n                                targetOrigin: context.targetOrigin,\n                                to: context.connectTo,\n                                type: request.type\n                            }\n                        });\n                    });\n                    return [\n                        ...context.requests,\n                        ...requests\n                    ];\n                }\n            }),\n            \"emit received message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { enqueue } = param;\n                enqueue.emit((param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n                        type: \"_message\",\n                        message: event.message.data\n                    };\n                }), enqueue.emit((param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n                        type: event.message.data.type,\n                        message: event.message.data\n                    };\n                });\n            }),\n            \"emit status\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)((_, params)=>({\n                    type: \"_status\",\n                    status: params.status\n                })),\n            \"flush buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { enqueue } = param;\n                enqueue.raise((param)=>{\n                    let { context } = param;\n                    return {\n                        type: \"request\",\n                        data: context.buffer.map((param)=>{\n                            let { data, type } = param;\n                            return {\n                                data,\n                                type\n                            };\n                        })\n                    };\n                }), enqueue.emit((param)=>{\n                    let { context } = param;\n                    return {\n                        type: \"_buffer.flushed\",\n                        messages: context.buffer\n                    };\n                }), enqueue.assign({\n                    buffer: []\n                });\n            }),\n            post: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)((param)=>{\n                let { event } = param;\n                return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n                    type: \"request\",\n                    data: {\n                        data: event.data.data,\n                        expectResponse: !0,\n                        type: event.data.type\n                    }\n                };\n            }),\n            \"remove request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { context, enqueue, event } = param;\n                (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\n                    \"request.success\",\n                    \"request.failed\",\n                    \"request.aborted\"\n                ]), (0,xstate__WEBPACK_IMPORTED_MODULE_14__.R)(event.requestId), enqueue.assign({\n                    requests: context.requests.filter((param)=>{\n                        let { id } = param;\n                        return id !== event.requestId;\n                    })\n                });\n            }),\n            respond: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)((param)=>{\n                let { event } = param;\n                return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"response\"), {\n                    type: \"request\",\n                    data: {\n                        data: event.data,\n                        type: MSG_RESPONSE,\n                        responseTo: event.respondTo\n                    }\n                };\n            }),\n            \"send handshake ack\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n                type: \"request\",\n                data: {\n                    type: MSG_HANDSHAKE_ACK\n                }\n            }),\n            \"send disconnect\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)(()=>({\n                    type: \"request\",\n                    data: {\n                        type: MSG_DISCONNECT\n                    }\n                })),\n            \"send handshake syn\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n                type: \"request\",\n                data: {\n                    type: MSG_HANDSHAKE_SYN\n                }\n            }),\n            \"set target\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n                target: (param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"target.set\"), event.target;\n                }\n            })\n        },\n        guards: {\n            \"has target\": (param)=>{\n                let { context } = param;\n                return !!context.target;\n            },\n            \"should send heartbeats\": (param)=>{\n                let { context } = param;\n                return context.heartbeat;\n            }\n        }\n    }).createMachine({\n        /** @xstate-layout N4IgpgJg5mDOIC5QGMAWBDAdpsAbAxAC7oBOMhAdLGIQNoAMAuoqAA4D2sAloV+5ixAAPRAHZRAJgoAWABz0ArHICMy2QGZZCgJwAaEAE9EE+tIrb6ANgkLl46fTuj1AXxf60WHARJgAjgCucJSwAcjIcLAMzEggHNy8-IIiCKLS2hQS6qb2yurisrL6RgjK9LIyCuqq0g7WstZuHhjYePi+gcEUAGboXLiQ0YLxPHwCsSmiCgoykpayDtqS6trqxYjKEk0gnq24FFwQA-jI-DjIdEzDnKNJExuOZpZ12eq29OrSCuupypYUojUaTKCnm5Wk2123gORzA+HilxibBuiXGoBSGnUAIU4gU9FWamUtR+lmUM1EllBEkslMUEnpkJa0JaEFgGAA1lxMFB8LADJghrERqjkhtshk3mTtNo5OpqpYfqCKhTptoqpY1WUtu4dky8BQWWz0Jzue1-EFYIjrgkxqLSupqRRPpoPqJtLI0hIioZENJJE7NnJ8ZYHVk1YyvPrDRyuTyEYLkTa7uixVlMh81KGFhS1j6EPkZlpVjTphr8mkI3sDVhWTHTQBbSLoGAUXwRLgAN0GVyFKNt91KimUFEKXvKC2s9R+6X+jipnzJeSqEJ1UKjNaNJp5EC4sFOrQuCbifeTwg2cgoym0RPxDtqkj0eaB9Ao8zSolMEivZVcq71+33c5CEgeFOCtXskzRM8EDxKRpmkSw3QJbQsmpH5tHmV8JHSbJpDsakV2aSMALOMALhAjoLXAxNbiglI-SxWw1Vw0QNDw0Qfg9KQ7EJSxHHxApK2hQCyOAiAzVgDhMGoI9hX7FMEHSF8cWkelpHURCbBsb481xAEgT9BQJCmWQsiE-URPI8TG1gWBmzAVsyLATtuyRY9ILtWoKmlL82Kqd0tAVJ91LMHFZDKIkVlkNVZHMkiDzE-Adz3UjDx7GiRQHCKnheD53k+HSSkDDIwpBVTqQwuKKEssSDTAUhCAAI3qyg0DIrd8Fkk86MQUMnVM+RynoegTDJH48hGp0vR-FDRqqKqasgOqGua9AQjATAd1NSiul6fpXOtWi7Wy19cslD4vnG7IX3oVjVDUVYEJQqrksW8SdstLqPKy0wKgG1RhtMWogqKhoMjkWp6XxUyFBe3c3tAz70vco6fq+V8PTkGUFzdQqNnELEM2yClrwwzQ4ZShKQJqr7UYU98AS0W9pT4z5pHG0yXwMkNNTyGk3B1TB2AgOBBDXXBDsyhSFG9EovQqN5i1JeRcKqw4Bkl+ToMx8x0j+EaqQ9XMSkBURMgMkEwQWKro2NWNNdPFJAzN0lJGM4slDxhBEJfXyplBd03wW1KxIdnrBxBh4JAyW75C8rJpmDqmIGWkgmpasPjqUcaHooMLHA0uU1UkJOgKW1B6rT1bWor5At0zgcTAkK7hrz1irB0D8cW0UvRPLyv07WqgNq2qAG+l9SnXUz0UOXD5xuMs3Y4+DVJBX7UiKrV6Q8gcfoJO54rFefLLqfJYX1WKYNLxL4NO1NwgA */ id: \"connection\",\n        context: (param)=>{\n            let { input } = param;\n            var _input_domain, _input_heartbeat;\n            return {\n                id: input.id || \"\".concat(input.name, \"-\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()),\n                buffer: [],\n                channelId: \"chn-\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()),\n                connectTo: input.connectTo,\n                domain: (_input_domain = input.domain) !== null && _input_domain !== void 0 ? _input_domain : DOMAIN,\n                heartbeat: (_input_heartbeat = input.heartbeat) !== null && _input_heartbeat !== void 0 ? _input_heartbeat : !1,\n                name: input.name,\n                requests: [],\n                target: input.target,\n                targetOrigin: input.targetOrigin\n            };\n        },\n        on: {\n            \"target.set\": {\n                actions: \"set target\"\n            },\n            \"request.success\": {\n                actions: \"remove request\"\n            },\n            \"request.failed\": {\n                actions: \"remove request\"\n            }\n        },\n        initial: \"idle\",\n        states: {\n            idle: {\n                entry: [\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"idle\"\n                        }\n                    }\n                ],\n                on: {\n                    connect: {\n                        target: \"handshaking\",\n                        guard: \"has target\"\n                    },\n                    post: {\n                        actions: \"buffer message\"\n                    }\n                }\n            },\n            handshaking: {\n                id: \"handshaking\",\n                entry: [\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"handshaking\"\n                        }\n                    }\n                ],\n                invoke: [\n                    {\n                        id: \"send syn\",\n                        src: \"sendBackAtInterval\",\n                        input: ()=>({\n                                event: {\n                                    type: \"syn\"\n                                },\n                                interval: HANDSHAKE_INTERVAL,\n                                immediate: !0\n                            })\n                    },\n                    {\n                        id: \"listen for handshake\",\n                        src: \"listen\",\n                        input: (input)=>listenInputFromContext({\n                                include: MSG_HANDSHAKE_SYN_ACK,\n                                count: 1\n                            })(input)\n                    }\n                ],\n                on: {\n                    syn: {\n                        actions: \"send handshake syn\"\n                    },\n                    request: {\n                        actions: \"create request\"\n                    },\n                    post: {\n                        actions: \"buffer message\"\n                    },\n                    \"message.received\": {\n                        target: \"connected\"\n                    },\n                    disconnect: {\n                        target: \"disconnected\"\n                    }\n                },\n                exit: \"send handshake ack\"\n            },\n            connected: {\n                entry: [\n                    \"flush buffer\",\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"connected\"\n                        }\n                    }\n                ],\n                invoke: {\n                    id: \"listen for messages\",\n                    src: \"listen\",\n                    input: listenInputFromContext({\n                        exclude: [\n                            MSG_RESPONSE,\n                            MSG_HEARTBEAT\n                        ]\n                    })\n                },\n                on: {\n                    post: {\n                        actions: \"post\"\n                    },\n                    request: {\n                        actions: \"create request\"\n                    },\n                    response: {\n                        actions: \"respond\"\n                    },\n                    \"message.received\": {\n                        actions: \"emit received message\"\n                    },\n                    disconnect: {\n                        target: \"disconnected\"\n                    }\n                },\n                initial: \"heartbeat\",\n                states: {\n                    heartbeat: {\n                        initial: \"checking\",\n                        states: {\n                            checking: {\n                                always: {\n                                    guard: \"should send heartbeats\",\n                                    target: \"sending\"\n                                }\n                            },\n                            sending: {\n                                on: {\n                                    \"request.failed\": {\n                                        target: \"#handshaking\"\n                                    }\n                                },\n                                invoke: {\n                                    id: \"send heartbeat\",\n                                    src: \"sendBackAtInterval\",\n                                    input: ()=>({\n                                            event: {\n                                                type: \"post\",\n                                                data: {\n                                                    type: MSG_HEARTBEAT,\n                                                    data: void 0\n                                                }\n                                            },\n                                            interval: 2e3,\n                                            immediate: !1\n                                        })\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            disconnected: {\n                id: \"disconnected\",\n                entry: [\n                    \"send disconnect\",\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"disconnected\"\n                        }\n                    }\n                ],\n                on: {\n                    request: {\n                        actions: \"create request\"\n                    },\n                    post: {\n                        actions: \"buffer message\"\n                    },\n                    connect: {\n                        target: \"handshaking\",\n                        guard: \"has target\"\n                    }\n                }\n            }\n        }\n    }), createConnection = function(input) {\n    let machine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createConnectionMachine();\n    const id = input.id || \"\".concat(input.name, \"-\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])()), actor = (0,xstate__WEBPACK_IMPORTED_MODULE_14__.A)(machine, {\n        input: {\n            ...input,\n            id\n        }\n    }), on = (type, handler)=>{\n        const { unsubscribe } = actor.on(// @ts-expect-error @todo `type` typing\n        type, async (event)=>{\n            const response = await handler(event.message.data);\n            response && actor.send({\n                type: \"response\",\n                respondTo: event.message.id,\n                data: response\n            });\n        });\n        return unsubscribe;\n    }, connect = ()=>{\n        actor.send({\n            type: \"connect\"\n        });\n    }, disconnect = ()=>{\n        actor.send({\n            type: \"disconnect\"\n        });\n    }, onStatus = (handler, filter2)=>{\n        const { unsubscribe } = actor.on(// @ts-expect-error @todo ReceivedEmitEvent causes this\n        \"_status\", (event)=>{\n            filter2 && event.status !== filter2 || handler(event.status);\n        });\n        return unsubscribe;\n    }, setTarget = (target)=>{\n        actor.send({\n            type: \"target.set\",\n            target\n        });\n    }, post = (type, data)=>{\n        const _data = {\n            type,\n            data\n        };\n        actor.send({\n            type: \"post\",\n            data: _data\n        });\n    }, stop = ()=>{\n        actor.stop();\n    }, start = ()=>(actor.start(), stop);\n    return {\n        actor,\n        connect,\n        disconnect,\n        id,\n        name: input.name,\n        machine,\n        on,\n        onStatus,\n        post,\n        setTarget,\n        start,\n        stop,\n        get target () {\n            return actor.getSnapshot().context.target;\n        }\n    };\n}, cleanupConnection = (connection)=>{\n    connection.disconnect(), setTimeout(()=>{\n        connection.stop();\n    }, 0);\n}, noop = ()=>{}, createController = (input)=>{\n    const { targetOrigin } = input, targets = /* @__PURE__ */ new Set(), channels = /* @__PURE__ */ new Set();\n    return {\n        addTarget: (target)=>{\n            if (targets.has(target)) return noop;\n            if (!targets.size || !channels.size) return targets.add(target), channels.forEach((channel)=>{\n                channel.connections.forEach((connection)=>{\n                    connection.setTarget(target), connection.connect();\n                });\n            }), ()=>{\n                targets.delete(target), channels.forEach((channel)=>{\n                    channel.connections.forEach((connection)=>{\n                        connection.target === target && connection.disconnect();\n                    });\n                });\n            };\n            targets.add(target);\n            const targetConnections = /* @__PURE__ */ new Set();\n            return channels.forEach((channel)=>{\n                const connection = createConnection({\n                    ...channel.input,\n                    target,\n                    targetOrigin\n                }, channel.machine);\n                targetConnections.add(connection), channel.connections.add(connection), channel.subscribers.forEach((param)=>{\n                    let { type, handler, unsubscribers } = param;\n                    unsubscribers.push(connection.on(type, handler));\n                }), channel.internalEventSubscribers.forEach((param)=>{\n                    let { type, handler, unsubscribers } = param;\n                    unsubscribers.push(connection.actor.on(type, handler).unsubscribe);\n                }), channel.statusSubscribers.forEach((param)=>{\n                    let { handler, unsubscribers } = param;\n                    unsubscribers.push(connection.onStatus((status)=>handler({\n                            connection: connection.id,\n                            status\n                        })));\n                }), connection.start(), connection.connect();\n            }), ()=>{\n                targets.delete(target), targetConnections.forEach((connection)=>{\n                    cleanupConnection(connection), channels.forEach((channel)=>{\n                        channel.connections.delete(connection);\n                    });\n                });\n            };\n        },\n        createChannel: function(input2) {\n            let machine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createConnectionMachine();\n            const channel = {\n                connections: /* @__PURE__ */ new Set(),\n                input: input2,\n                internalEventSubscribers: /* @__PURE__ */ new Set(),\n                machine,\n                statusSubscribers: /* @__PURE__ */ new Set(),\n                subscribers: /* @__PURE__ */ new Set()\n            };\n            channels.add(channel);\n            const { connections, internalEventSubscribers, statusSubscribers, subscribers } = channel;\n            if (targets.size) targets.forEach((target)=>{\n                const connection = createConnection({\n                    ...input2,\n                    target,\n                    targetOrigin\n                }, machine);\n                connections.add(connection);\n            });\n            else {\n                const connection = createConnection({\n                    ...input2,\n                    targetOrigin\n                }, machine);\n                connections.add(connection);\n            }\n            const post = function() {\n                for(var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++){\n                    params[_key] = arguments[_key];\n                }\n                const [type, data] = params;\n                connections.forEach((connection)=>{\n                    connection.post(type, data);\n                });\n            }, on = (type, handler)=>{\n                const unsubscribers = [];\n                connections.forEach((connection)=>{\n                    unsubscribers.push(connection.on(type, handler));\n                });\n                const subscriber = {\n                    type,\n                    handler,\n                    unsubscribers\n                };\n                return subscribers.add(subscriber), ()=>{\n                    unsubscribers.forEach((unsub)=>unsub()), subscribers.delete(subscriber);\n                };\n            }, onInternalEvent = (type, handler)=>{\n                const unsubscribers = [];\n                connections.forEach((connection)=>{\n                    unsubscribers.push(connection.actor.on(type, handler).unsubscribe);\n                });\n                const subscriber = {\n                    type,\n                    handler,\n                    unsubscribers\n                };\n                return internalEventSubscribers.add(subscriber), ()=>{\n                    unsubscribers.forEach((unsub)=>unsub()), internalEventSubscribers.delete(subscriber);\n                };\n            }, onStatus = (handler)=>{\n                const unsubscribers = [];\n                connections.forEach((connection)=>{\n                    unsubscribers.push(connection.onStatus((status)=>handler({\n                            connection: connection.id,\n                            status\n                        })));\n                });\n                const subscriber = {\n                    handler,\n                    unsubscribers\n                };\n                return statusSubscribers.add(subscriber), ()=>{\n                    unsubscribers.forEach((unsub)=>unsub()), statusSubscribers.delete(subscriber);\n                };\n            }, stop = ()=>{\n                const connections2 = channel.connections;\n                connections2.forEach(cleanupConnection), connections2.clear(), channels.delete(channel);\n            };\n            return {\n                on,\n                onInternalEvent,\n                onStatus,\n                post,\n                start: ()=>(connections.forEach((connection)=>{\n                        connection.start(), connection.connect();\n                    }), stop),\n                stop\n            };\n        },\n        destroy: ()=>{\n            channels.forEach((param)=>{\n                let { connections } = param;\n                connections.forEach(cleanupConnection), connections.clear();\n            }), channels.clear(), targets.clear();\n        }\n    };\n}, createNodeMachine = ()=>(0,xstate__WEBPACK_IMPORTED_MODULE_9__.setup)({\n        types: {},\n        actors: {\n            requestMachine: createRequestMachine(),\n            listen: createListenLogic()\n        },\n        actions: {\n            \"buffer incoming message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n                handshakeBuffer: (param)=>{\n                    let { event, context } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), [\n                        ...context.handshakeBuffer,\n                        event\n                    ];\n                }\n            }),\n            \"buffer message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { enqueue } = param;\n                enqueue.assign({\n                    buffer: (param)=>{\n                        let { event, context } = param;\n                        return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), [\n                            ...context.buffer,\n                            {\n                                data: event.data,\n                                resolvable: event.resolvable,\n                                options: event.options\n                            }\n                        ];\n                    }\n                }), enqueue.emit((param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n                        type: \"_buffer.added\",\n                        message: event.data\n                    };\n                });\n            }),\n            \"create request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n                requests: (param)=>{\n                    let { context, event, self, spawn } = param;\n                    (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"request\");\n                    const requests = (Array.isArray(event.data) ? event.data : [\n                        event.data\n                    ]).map((request)=>{\n                        var _request_options, _request_options1, _request_options2;\n                        const id = \"req-\".concat((0,uuid__WEBPACK_IMPORTED_MODULE_13__[\"default\"])());\n                        return spawn(\"requestMachine\", {\n                            id,\n                            input: {\n                                channelId: context.channelId,\n                                data: request.data,\n                                domain: context.domain,\n                                expectResponse: request.expectResponse,\n                                from: context.name,\n                                parentRef: self,\n                                resolvable: request.resolvable,\n                                responseTimeout: (_request_options = request.options) === null || _request_options === void 0 ? void 0 : _request_options.responseTimeout,\n                                responseTo: request.responseTo,\n                                signal: (_request_options1 = request.options) === null || _request_options1 === void 0 ? void 0 : _request_options1.signal,\n                                sources: context.target,\n                                suppressWarnings: (_request_options2 = request.options) === null || _request_options2 === void 0 ? void 0 : _request_options2.suppressWarnings,\n                                targetOrigin: context.targetOrigin,\n                                to: context.connectTo,\n                                type: request.type\n                            }\n                        });\n                    });\n                    return [\n                        ...context.requests,\n                        ...requests\n                    ];\n                }\n            }),\n            \"emit heartbeat\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)(()=>({\n                    type: \"_heartbeat\"\n                })),\n            \"emit received message\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { enqueue } = param;\n                enqueue.emit((param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n                        type: \"_message\",\n                        message: event.message.data\n                    };\n                }), enqueue.emit((param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"message.received\"), {\n                        type: event.message.data.type,\n                        message: event.message.data\n                    };\n                });\n            }),\n            \"emit status\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.e)((_, params)=>({\n                    type: \"_status\",\n                    status: params.status\n                })),\n            \"flush buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { enqueue } = param;\n                enqueue.raise((param)=>{\n                    let { context } = param;\n                    return {\n                        type: \"request\",\n                        data: context.buffer.map((param)=>{\n                            let { data, resolvable, options } = param;\n                            return {\n                                data: data.data,\n                                type: data.type,\n                                expectResponse: !!resolvable,\n                                resolvable,\n                                options\n                            };\n                        })\n                    };\n                }), enqueue.emit((param)=>{\n                    let { context } = param;\n                    return {\n                        type: \"_buffer.flushed\",\n                        messages: context.buffer.map((param)=>{\n                            let { data } = param;\n                            return data;\n                        })\n                    };\n                }), enqueue.assign({\n                    buffer: []\n                });\n            }),\n            \"flush handshake buffer\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { context, enqueue } = param;\n                context.handshakeBuffer.forEach((event)=>enqueue.raise(event)), enqueue.assign({\n                    handshakeBuffer: []\n                });\n            }),\n            post: (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)((param)=>{\n                let { event } = param;\n                return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"post\"), {\n                    type: \"request\",\n                    data: {\n                        data: event.data.data,\n                        expectResponse: !!event.resolvable,\n                        type: event.data.type,\n                        resolvable: event.resolvable,\n                        options: event.options\n                    }\n                };\n            }),\n            \"remove request\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.b)((param)=>{\n                let { context, enqueue, event } = param;\n                (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\n                    \"request.success\",\n                    \"request.failed\",\n                    \"request.aborted\"\n                ]), (0,xstate__WEBPACK_IMPORTED_MODULE_14__.R)(event.requestId), enqueue.assign({\n                    requests: context.requests.filter((param)=>{\n                        let { id } = param;\n                        return id !== event.requestId;\n                    })\n                });\n            }),\n            \"send response\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)((param)=>{\n                let { event } = param;\n                return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, [\n                    \"message.received\",\n                    \"heartbeat.received\"\n                ]), {\n                    type: \"request\",\n                    data: {\n                        type: MSG_RESPONSE,\n                        responseTo: event.message.data.id,\n                        data: void 0\n                    }\n                };\n            }),\n            \"send handshake syn ack\": (0,xstate__WEBPACK_IMPORTED_MODULE_14__.O)({\n                type: \"request\",\n                data: {\n                    type: MSG_HANDSHAKE_SYN_ACK\n                }\n            }),\n            \"set connection config\": (0,xstate__WEBPACK_IMPORTED_MODULE_12__.a)({\n                channelId: (param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"handshake.syn\"), event.message.data.channelId;\n                },\n                target: (param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"handshake.syn\"), event.message.source || void 0;\n                },\n                targetOrigin: (param)=>{\n                    let { event } = param;\n                    return (0,xstate__WEBPACK_IMPORTED_MODULE_9__.assertEvent)(event, \"handshake.syn\"), event.message.origin;\n                }\n            })\n        },\n        guards: {\n            hasSource: (param)=>{\n                let { context } = param;\n                return context.target !== null;\n            }\n        }\n    }).createMachine({\n        /** @xstate-layout N4IgpgJg5mDOIC5QDsD2EwGIBOYCOArnAC4B0sBAxpXLANoAMAuoqAA6qwCWxXqyrEAA9EAVgYAWUgEYJDUQA4JAZmUSJC0coDsAGhABPRNIYLSErdOkBOAGzbx227YUBfV-rQYc+IrDIAZgCGXAA2kIwsSCAc3Lz8giIIoiakqgBMDKbp2tYS0srp+kYI0ununuhgpFwQ4ZgQ-NVcyABuqADW1V7NdWAILe2UQfHIkZGCsTx8AtFJ6aKipAzWOtrpC7Z5BUWGiNoK6aS26RLW2tLaqkqqFSA9NX2YALa0QTCkuDRcrRHMk5xpgk5ogJLZSNZIVDoVCFLZiohbIVSLkXLZRHZDgxbHcHrV6rFiBNolNRolEVJbCsdGUzsoyhiEcllOC1DowelVmVrOUPPcqqQABZBZAQWDCjotKANJo1NqdboC4Wi8VBSXIKADeXDUbjf4kwFkkEILbg8RZMHKOzWKzKJkHJa086Xa4qZS4pUisUSqU+QgkYnsQ0zcnJaRLDbpZwKNQSBYspm2MEyC5KTnaDSSd18h7K71q32EwMxYPA0BJFLKY5yZxIrKSURM0RnFHSBTrQqQ9babQejBCr2q9XSiBcWCUfjIMCUIn6oNxEPGtTWFFR0RUy7iGzt+3Ip0XURXVZKPvVCfIKczyB+vyzqLzoGzcuIG0MGTyCztjRtjaJjbHVMNAUTdu1PUhz0vYhryLOcSwXMthBfK0ZGsLQGBZekCi0Jso1IdI23WG04zOE4wIg6coIgBox3Imdi1JRdnxNOxSHNSQkWtW0mTjMxMQ7fDzgcbNKn7WjKJeN4Pi+MAfj+e84MfUMFHbZZwxOHZNDyO09gQOQjmAhZJCM9IMjIycKOvQUwCCbBiAAI2sshpNkiB6NLJ9EIQBQbWOdJlMhYCUjbJkchXGsFmsJQMVsWl3BzKp4GiHoAXgjykgAWmkZZ6xy3LZF2EobCy6xsQWJQ42kE4FjA-EwBSxTjSRUhDgqkzgO2BxdykU4AvXFQ-KjMC8yHKV6qNJi6WOdcypcZsXGxe0JG0XySKjM5lKsMyLwsiAxsYzylDfONznUEqrmi+1ThkHqXDONbULi1wgA */ id: \"node\",\n        context: (param)=>{\n            let { input } = param;\n            var _input_domain;\n            return {\n                buffer: [],\n                channelId: null,\n                connectTo: input.connectTo,\n                domain: (_input_domain = input.domain) !== null && _input_domain !== void 0 ? _input_domain : DOMAIN,\n                handshakeBuffer: [],\n                name: input.name,\n                requests: [],\n                target: void 0,\n                targetOrigin: null\n            };\n        },\n        // Always listen for handshake syn messages. The channel could have\n        // disconnected without being able to notify the node, and so need to\n        // re-establish the connection.\n        invoke: {\n            id: \"listen for handshake syn\",\n            src: \"listen\",\n            input: listenInputFromContext({\n                include: MSG_HANDSHAKE_SYN,\n                responseType: \"handshake.syn\"\n            })\n        },\n        on: {\n            \"request.success\": {\n                actions: \"remove request\"\n            },\n            \"request.failed\": {\n                actions: \"remove request\"\n            },\n            \"request.aborted\": {\n                actions: \"remove request\"\n            },\n            \"handshake.syn\": {\n                actions: \"set connection config\",\n                target: \".handshaking\"\n            }\n        },\n        initial: \"idle\",\n        states: {\n            idle: {\n                entry: [\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"idle\"\n                        }\n                    }\n                ],\n                on: {\n                    post: {\n                        actions: \"buffer message\"\n                    }\n                }\n            },\n            handshaking: {\n                guard: \"hasSource\",\n                entry: [\n                    \"send handshake syn ack\",\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"handshaking\"\n                        }\n                    }\n                ],\n                invoke: [\n                    {\n                        id: \"listen for handshake ack\",\n                        src: \"listen\",\n                        input: listenInputFromContext({\n                            include: MSG_HANDSHAKE_ACK,\n                            count: 1,\n                            // Override the default `message.received` responseType to prevent\n                            // buffering the ack message. We transition to the connected state\n                            // using onDone instead of listening to this event using `on`\n                            responseType: \"handshake.complete\"\n                        }),\n                        onDone: \"connected\"\n                    },\n                    {\n                        id: \"listen for disconnect\",\n                        src: \"listen\",\n                        input: listenInputFromContext({\n                            include: MSG_DISCONNECT,\n                            count: 1,\n                            responseType: \"disconnect\"\n                        })\n                    },\n                    {\n                        id: \"listen for messages\",\n                        src: \"listen\",\n                        input: listenInputFromContext({\n                            exclude: [\n                                MSG_DISCONNECT,\n                                MSG_HANDSHAKE_SYN,\n                                MSG_HANDSHAKE_ACK,\n                                MSG_HEARTBEAT,\n                                MSG_RESPONSE\n                            ]\n                        })\n                    }\n                ],\n                on: {\n                    request: {\n                        actions: \"create request\"\n                    },\n                    post: {\n                        actions: \"buffer message\"\n                    },\n                    \"message.received\": {\n                        actions: \"buffer incoming message\"\n                    },\n                    disconnect: {\n                        target: \"idle\"\n                    }\n                }\n            },\n            connected: {\n                entry: [\n                    \"flush handshake buffer\",\n                    \"flush buffer\",\n                    {\n                        type: \"emit status\",\n                        params: {\n                            status: \"connected\"\n                        }\n                    }\n                ],\n                invoke: [\n                    {\n                        id: \"listen for messages\",\n                        src: \"listen\",\n                        input: listenInputFromContext({\n                            exclude: [\n                                MSG_DISCONNECT,\n                                MSG_HANDSHAKE_SYN,\n                                MSG_HANDSHAKE_ACK,\n                                MSG_HEARTBEAT,\n                                MSG_RESPONSE\n                            ]\n                        })\n                    },\n                    {\n                        id: \"listen for heartbeat\",\n                        src: \"listen\",\n                        input: listenInputFromContext({\n                            include: MSG_HEARTBEAT,\n                            responseType: \"heartbeat.received\"\n                        })\n                    },\n                    {\n                        id: \"listen for disconnect\",\n                        src: \"listen\",\n                        input: listenInputFromContext({\n                            include: MSG_DISCONNECT,\n                            count: 1,\n                            responseType: \"disconnect\"\n                        })\n                    }\n                ],\n                on: {\n                    request: {\n                        actions: \"create request\"\n                    },\n                    post: {\n                        actions: \"post\"\n                    },\n                    disconnect: {\n                        target: \"idle\"\n                    },\n                    \"message.received\": {\n                        actions: [\n                            \"send response\",\n                            \"emit received message\"\n                        ]\n                    },\n                    \"heartbeat.received\": {\n                        actions: [\n                            \"send response\",\n                            \"emit heartbeat\"\n                        ]\n                    }\n                }\n            }\n        }\n    }), createNode = function(input) {\n    let machine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createNodeMachine();\n    const actor = (0,xstate__WEBPACK_IMPORTED_MODULE_14__.A)(machine, {\n        input\n    }), on = (type, handler)=>{\n        const { unsubscribe } = actor.on(// @ts-expect-error @todo ReceivedEmitEvent causes this\n        type, (event)=>{\n            handler(event.message.data);\n        });\n        return unsubscribe;\n    };\n    let cachedStatus;\n    const onStatus = (handler, filter2)=>{\n        const { unsubscribe } = actor.on(// @ts-expect-error @todo ReceivedEmitEvent causes this\n        \"_status\", (event)=>{\n            cachedStatus = event.status, !(filter2 && event.status !== filter2) && handler(event.status);\n        });\n        return cachedStatus && handler(cachedStatus), unsubscribe;\n    }, post = (type, data)=>{\n        const _data = {\n            type,\n            data\n        };\n        actor.send({\n            type: \"post\",\n            data: _data\n        });\n    }, fetch = (type, data, options)=>{\n        const { responseTimeout = FETCH_TIMEOUT_DEFAULT, signal, suppressWarnings } = options || {}, resolvable = Promise.withResolvers(), _data = {\n            type,\n            data\n        };\n        return actor.send({\n            type: \"post\",\n            data: _data,\n            resolvable,\n            options: {\n                responseTimeout,\n                signal,\n                suppressWarnings\n            }\n        }), resolvable.promise;\n    }, stop = ()=>{\n        actor.stop();\n    };\n    return {\n        actor,\n        fetch,\n        machine,\n        on,\n        onStatus,\n        post,\n        start: ()=>(actor.start(), stop),\n        stop\n    };\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NvbWxpbmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQjtBQUMwSDtBQUN6QztBQUMzRyxNQUFNc0IseUJBQXlCLENBQUNDLFNBQVc7WUFBQyxFQUMxQ0MsT0FBTyxFQUNSO1FBQ0MsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxlQUFlLGtCQUFrQixFQUFFLEdBQUdMO1FBQ3ZFLE9BQU87WUFDTEU7WUFDQUksUUFBUUwsUUFBUUssTUFBTTtZQUN0QkMsTUFBTU4sUUFBUU8sU0FBUztZQUN2QkwsU0FBU0EsVUFBVU0sTUFBTUMsT0FBTyxDQUFDUCxXQUFXQSxVQUFVO2dCQUFDQTthQUFRLEdBQUcsRUFBRTtZQUNwRUMsU0FBU0EsVUFBVUssTUFBTUMsT0FBTyxDQUFDTixXQUFXQSxVQUFVO2dCQUFDQTthQUFRLEdBQUcsRUFBRTtZQUNwRUM7WUFDQU0sUUFBUVYsUUFBUVUsTUFBTTtZQUN0QkMsSUFBSVgsUUFBUVksSUFBSTtRQUNsQjtJQUNGLEdBQUdDLGVBQWUsQ0FBQ0MsUUFBVSxDQUFDQztRQUM1QixNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHRDtRQUNqQixPQUFPLENBQUNELE1BQU1aLE9BQU8sQ0FBQ2UsTUFBTSxHQUFHSCxNQUFNWixPQUFPLENBQUNnQixRQUFRLENBQUNGLEtBQUtHLElBQUksSUFBSSxDQUFDLE1BQU9MLENBQUFBLE1BQU1YLE9BQU8sQ0FBQ2MsTUFBTSxHQUFHLENBQUNILE1BQU1YLE9BQU8sQ0FBQ2UsUUFBUSxDQUFDRixLQUFLRyxJQUFJLElBQUksQ0FBQyxNQUFNSCxLQUFLWCxNQUFNLEtBQUtTLE1BQU1ULE1BQU0sSUFBSVcsS0FBS1YsSUFBSSxLQUFLUSxNQUFNUixJQUFJLElB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a0IsZ0JBQWdCLEVBQUUsR0FBR29HLFdBQVcsQ0FBQyxHQUFHdkcsYUFBYThHLFFBQVFDLGFBQWEsSUFBSXhDLFFBQVE7WUFBRW5IO1lBQU1IO1FBQUs7UUFDeEosT0FBT2dILE1BQU03QixJQUFJLENBQUM7WUFDaEJoRixNQUFNO1lBQ05ILE1BQU1zSDtZQUNOdkU7WUFDQXVHLFNBQVM7Z0JBQUUzRjtnQkFBaUIzQjtnQkFBUWtCO1lBQWlCO1FBQ3ZELElBQUlILFdBQVdnSCxPQUFPO0lBQ3hCLEdBQUd4QyxPQUFPO1FBQ1JQLE1BQU1PLElBQUk7SUFDWjtJQUNBLE9BQU87UUFDTFA7UUFDQTRDO1FBQ0E3QztRQUNBL0M7UUFDQW1EO1FBQ0FqQjtRQUNBc0IsT0FBTyxJQUFPUixDQUFBQSxNQUFNUSxLQUFLLElBQUlELElBQUc7UUFDaENBO0lBQ0Y7QUFDRjtBQXNCRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9ub2RlX21vZHVsZXMvQHNhbml0eS9jb21saW5rL2Rpc3QvaW5kZXguanM/YjEyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBmcm9tRXZlbnRPYnNlcnZhYmxlLCBzZXR1cCwgc2VuZFRvLCBhc3NpZ24sIGZyb21DYWxsYmFjaywgZW5xdWV1ZUFjdGlvbnMsIGFzc2VydEV2ZW50LCBlbWl0LCByYWlzZSwgc3RvcENoaWxkLCBjcmVhdGVBY3RvciB9IGZyb20gXCJ4c3RhdGVcIjtcbmltcG9ydCB7IGRlZmVyLCBmcm9tRXZlbnQsIG1hcCwgcGlwZSwgZmlsdGVyLCBidWZmZXJDb3VudCwgY29uY2F0TWFwLCB0YWtlLCBFTVBUWSwgdGFrZVVudGlsIH0gZnJvbSBcInJ4anNcIjtcbmNvbnN0IGxpc3RlbklucHV0RnJvbUNvbnRleHQgPSAoY29uZmlnKSA9PiAoe1xuICBjb250ZXh0XG59KSA9PiB7XG4gIGNvbnN0IHsgY291bnQsIGluY2x1ZGUsIGV4Y2x1ZGUsIHJlc3BvbnNlVHlwZSA9IFwibWVzc2FnZS5yZWNlaXZlZFwiIH0gPSBjb25maWc7XG4gIHJldHVybiB7XG4gICAgY291bnQsXG4gICAgZG9tYWluOiBjb250ZXh0LmRvbWFpbixcbiAgICBmcm9tOiBjb250ZXh0LmNvbm5lY3RUbyxcbiAgICBpbmNsdWRlOiBpbmNsdWRlID8gQXJyYXkuaXNBcnJheShpbmNsdWRlKSA/IGluY2x1ZGUgOiBbaW5jbHVkZV0gOiBbXSxcbiAgICBleGNsdWRlOiBleGNsdWRlID8gQXJyYXkuaXNBcnJheShleGNsdWRlKSA/IGV4Y2x1ZGUgOiBbZXhjbHVkZV0gOiBbXSxcbiAgICByZXNwb25zZVR5cGUsXG4gICAgdGFyZ2V0OiBjb250ZXh0LnRhcmdldCxcbiAgICB0bzogY29udGV4dC5uYW1lXG4gIH07XG59LCBsaXN0ZW5GaWx0ZXIgPSAoaW5wdXQpID0+IChldmVudCkgPT4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGV2ZW50O1xuICByZXR1cm4gKGlucHV0LmluY2x1ZGUubGVuZ3RoID8gaW5wdXQuaW5jbHVkZS5pbmNsdWRlcyhkYXRhLnR5cGUpIDogITApICYmIChpbnB1dC5leGNsdWRlLmxlbmd0aCA/ICFpbnB1dC5leGNsdWRlLmluY2x1ZGVzKGRhdGEudHlwZSkgOiAhMCkgJiYgZGF0YS5kb21haW4gPT09IGlucHV0LmRvbWFpbiAmJiBkYXRhLmZyb20gPT09IGlucHV0LmZyb20gJiYgZGF0YS50byA9PT0gaW5wdXQudG8gJiYgKCFpbnB1dC50YXJnZXQgfHwgZXZlbnQuc291cmNlID09PSBpbnB1dC50YXJnZXQpO1xufSwgZXZlbnRUb01lc3NhZ2UgPSAodHlwZSkgPT4gKGV2ZW50KSA9PiAoe1xuICB0eXBlLFxuICBtZXNzYWdlOiBldmVudFxufSksIG1lc3NhZ2VFdmVudHMkID0gZGVmZXIoXG4gICgpID0+IGZyb21FdmVudCh3aW5kb3csIFwibWVzc2FnZVwiKVxuKSwgY3JlYXRlTGlzdGVuTG9naWMgPSAoY29tcGF0TWFwKSA9PiBmcm9tRXZlbnRPYnNlcnZhYmxlKCh7IGlucHV0IH0pID0+IG1lc3NhZ2VFdmVudHMkLnBpcGUoXG4gIGNvbXBhdE1hcCA/IG1hcChjb21wYXRNYXApIDogcGlwZSgpLFxuICBmaWx0ZXIobGlzdGVuRmlsdGVyKGlucHV0KSksXG4gIG1hcChldmVudFRvTWVzc2FnZShpbnB1dC5yZXNwb25zZVR5cGUpKSxcbiAgaW5wdXQuY291bnQgPyBwaXBlKFxuICAgIGJ1ZmZlckNvdW50KGlucHV0LmNvdW50KSxcbiAgICBjb25jYXRNYXAoKGFycikgPT4gYXJyKSxcbiAgICB0YWtlKGlucHV0LmNvdW50KVxuICApIDogcGlwZSgpXG4pKSwgRE9NQUlOID0gXCJzYW5pdHkvY29tbGlua1wiLCBSRVNQT05TRV9USU1FT1VUX0RFRkFVTFQgPSAzZTMsIEZFVENIX1RJTUVPVVRfREVGQVVMVCA9IDFlNCwgSEVBUlRCRUFUX0lOVEVSVkFMID0gMWUzLCBIQU5EU0hBS0VfSU5URVJWQUwgPSA1MDAsIE1TR19SRVNQT05TRSA9IFwiY29tbGluay9yZXNwb25zZVwiLCBNU0dfSEVBUlRCRUFUID0gXCJjb21saW5rL2hlYXJ0YmVhdFwiLCBNU0dfRElTQ09OTkVDVCA9IFwiY29tbGluay9kaXNjb25uZWN0XCIsIE1TR19IQU5EU0hBS0VfU1lOID0gXCJjb21saW5rL2hhbmRzaGFrZS9zeW5cIiwgTVNHX0hBTkRTSEFLRV9TWU5fQUNLID0gXCJjb21saW5rL2hhbmRzaGFrZS9zeW4tYWNrXCIsIE1TR19IQU5EU0hBS0VfQUNLID0gXCJjb21saW5rL2hhbmRzaGFrZS9hY2tcIiwgSEFORFNIQUtFX01TR19UWVBFUyA9IFtcbiAgTVNHX0hBTkRTSEFLRV9TWU4sXG4gIE1TR19IQU5EU0hBS0VfU1lOX0FDSyxcbiAgTVNHX0hBTkRTSEFLRV9BQ0tcbl0sIElOVEVSTkFMX01TR19UWVBFUyA9IFtcbiAgTVNHX1JFU1BPTlNFLFxuICBNU0dfRElTQ09OTkVDVCxcbiAgTVNHX0hFQVJUQkVBVCxcbiAgLi4uSEFORFNIQUtFX01TR19UWVBFU1xuXSwgdGhyb3dPbkV2ZW50ID0gKG1lc3NhZ2UpID0+IChzb3VyY2UpID0+IHNvdXJjZS5waXBlKFxuICB0YWtlKDEpLFxuICBtYXAoKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSlcbiksIGNyZWF0ZVJlcXVlc3RNYWNoaW5lID0gKCkgPT4gc2V0dXAoe1xuICB0eXBlczoge30sXG4gIGFjdG9yczoge1xuICAgIGxpc3RlbjogZnJvbUV2ZW50T2JzZXJ2YWJsZShcbiAgICAgICh7XG4gICAgICAgIGlucHV0XG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFib3J0U2lnbmFsJCA9IGlucHV0LnNpZ25hbCA/IGZyb21FdmVudChpbnB1dC5zaWduYWwsIFwiYWJvcnRcIikucGlwZShcbiAgICAgICAgICB0aHJvd09uRXZlbnQoYFJlcXVlc3QgJHtpbnB1dC5yZXF1ZXN0SWR9IGFib3J0ZWRgKVxuICAgICAgICApIDogRU1QVFksIG1lc3NhZ2VGaWx0ZXIgPSAoZXZlbnQpID0+IGV2ZW50LmRhdGE/LnR5cGUgPT09IE1TR19SRVNQT05TRSAmJiBldmVudC5kYXRhPy5yZXNwb25zZVRvID09PSBpbnB1dC5yZXF1ZXN0SWQgJiYgISFldmVudC5zb3VyY2UgJiYgaW5wdXQuc291cmNlcy5oYXMoZXZlbnQuc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGZyb21FdmVudCh3aW5kb3csIFwibWVzc2FnZVwiKS5waXBlKFxuICAgICAgICAgIGZpbHRlcihtZXNzYWdlRmlsdGVyKSxcbiAgICAgICAgICB0YWtlKGlucHV0LnNvdXJjZXMuc2l6ZSksXG4gICAgICAgICAgdGFrZVVudGlsKGFib3J0U2lnbmFsJClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApXG4gIH0sXG4gIGFjdGlvbnM6IHtcbiAgICBcInNlbmQgbWVzc2FnZVwiOiAoeyBjb250ZXh0IH0sIHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgeyBzb3VyY2VzLCB0YXJnZXRPcmlnaW4gfSA9IGNvbnRleHQsIHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICAgICAgc291cmNlLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHsgdGFyZ2V0T3JpZ2luIH0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBcIm9uIHN1Y2Nlc3NcIjogc2VuZFRvKFxuICAgICAgKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnBhcmVudFJlZixcbiAgICAgICh7IGNvbnRleHQsIHNlbGYgfSkgPT4gKGNvbnRleHQucmVzcG9uc2UgJiYgY29udGV4dC5yZXNvbHZhYmxlPy5yZXNvbHZlKGNvbnRleHQucmVzcG9uc2UpLCB7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdC5zdWNjZXNzXCIsXG4gICAgICAgIHJlcXVlc3RJZDogc2VsZi5pZCxcbiAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQucmVzcG9uc2UsXG4gICAgICAgIHJlc3BvbnNlVG86IGNvbnRleHQucmVzcG9uc2VUb1xuICAgICAgfSlcbiAgICApLFxuICAgIFwib24gZmFpbFwiOiBzZW5kVG8oXG4gICAgICAoeyBjb250ZXh0IH0pID0+IGNvbnRleHQucGFyZW50UmVmLFxuICAgICAgKHsgY29udGV4dCwgc2VsZiB9KSA9PiAoY29udGV4dC5zdXBwcmVzc1dhcm5pbmdzIHx8IGNvbnNvbGUud2FybihcbiAgICAgICAgYFtAc2FuaXR5L2NvbWxpbmtdIFJlY2VpdmVkIG5vIHJlc3BvbnNlIHRvIG1lc3NhZ2UgJyR7Y29udGV4dC50eXBlfScgb24gY2xpZW50ICcke2NvbnRleHQuZnJvbX0nIChJRDogJyR7Y29udGV4dC5pZH0nKS5gXG4gICAgICApLCBjb250ZXh0LnJlc29sdmFibGU/LnJlamVjdChuZXcgRXJyb3IoXCJObyByZXNwb25zZSByZWNlaXZlZFwiKSksIHsgdHlwZTogXCJyZXF1ZXN0LmZhaWxlZFwiLCByZXF1ZXN0SWQ6IHNlbGYuaWQgfSlcbiAgICApLFxuICAgIFwib24gYWJvcnRcIjogc2VuZFRvKFxuICAgICAgKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LnBhcmVudFJlZixcbiAgICAgICh7IGNvbnRleHQsIHNlbGYgfSkgPT4gKGNvbnRleHQucmVzb2x2YWJsZT8ucmVqZWN0KG5ldyBFcnJvcihcIlJlcXVlc3QgYWJvcnRlZFwiKSksIHsgdHlwZTogXCJyZXF1ZXN0LmFib3J0ZWRcIiwgcmVxdWVzdElkOiBzZWxmLmlkIH0pXG4gICAgKVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBleHBlY3RzUmVzcG9uc2U6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5leHBlY3RSZXNwb25zZVxuICB9LFxuICBkZWxheXM6IHtcbiAgICBpbml0aWFsVGltZW91dDogMCxcbiAgICByZXNwb25zZVRpbWVvdXQ6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC5yZXNwb25zZVRpbWVvdXQgPz8gUkVTUE9OU0VfVElNRU9VVF9ERUZBVUxUXG4gIH1cbn0pLmNyZWF0ZU1hY2hpbmUoe1xuICAvKiogQHhzdGF0ZS1sYXlvdXQgTjRJZ3BnSmc1bURPSUM1UUFvQzJCREF4Z0N3SllEc3dCS0FPbHdnQnN3QmlBRDFnQmQwR3dUMEF6RmdKMlFOd2R6b0tBRlZ5b3dBZXdDdURJdFRSWThoVXVTb0J0QUF3QmRSS0FBT0UyUDF3VDh1a0xVUUJHQUV3QldFZ0JZQW5LK2VPQXpCN3NCMkR6WThyQUJvUUFFOXJEUWMzVjBjTlR3OGZBQTROSHdCZlZKQ0ZIQUppRWxnd2ZBZ0NLR3BOSFNRUUF5TUJVM05MQkRzckR4STdEVGFBalFBMk9PY05EeER3aEhzTkp4OU91MFRPcTJjSnhQOUhkTXlNYk9VOGdxTDhFclVyY3YxRFkxcUsrc2JtMXZhUExwNitnY1JuR3lkbzl3REd5Y1dRTEtWYzlBQjNkR05ONmppV0N3ZEF3TXJtS29ITXhIUkNKUktPRWlKSHd1WktCWndYS3pCTUtJR3lZa2h0QWtYT3dlVHFPSHcyUkp2RDQ1VWctUDRDQUgwSmdzTmljTUE4TGh3QXo0ZktpY1RTV1R5WmFmV20tZjVRY0VWU0UxYUdnZXB3aEZJbEY5YVlZckdEQzQrSnpFcHBqR3pPVWtlR2JwRElnZkFTQ0J3Y3pVNVFRLVl5dXFJQUMwblJ1Q0JkK0lKWHU5S1Nwd3BwWkVvWUR0MVJNc29zaUVjTmpkVmppSkVlR2lzaVNUSGtjVmdXcHB0dVh5aFdLSWFoanFHemkxQnFSSklOblZjZGtjYnVUTFM5VllDOElTZnNVQWJwNHZ6RHBoQ0hKSXlqQnZKTmx4Tm1STmV4UTNzSkdINDNHUGo4aldKclpXdVhZZnlvRUM3WWNMc2JyZ1JzamtjdmttZGdOYm9wVmhJUGhWZm5zaDhDbE16LXRXc0NrbUV3Y0hnVXZ0MjU3dTh2KzZIc2U0eG5oT2RabkltVmlkUHFDUk5CNEpxcEVBQSAqL1xuICBjb250ZXh0OiAoeyBpbnB1dCB9KSA9PiAoe1xuICAgIGNoYW5uZWxJZDogaW5wdXQuY2hhbm5lbElkLFxuICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgZG9tYWluOiBpbnB1dC5kb21haW4sXG4gICAgZXhwZWN0UmVzcG9uc2U6IGlucHV0LmV4cGVjdFJlc3BvbnNlID8/ICExLFxuICAgIGZyb206IGlucHV0LmZyb20sXG4gICAgaWQ6IGBtc2ctJHt2NCgpfWAsXG4gICAgcGFyZW50UmVmOiBpbnB1dC5wYXJlbnRSZWYsXG4gICAgcmVzb2x2YWJsZTogaW5wdXQucmVzb2x2YWJsZSxcbiAgICByZXNwb25zZTogbnVsbCxcbiAgICByZXNwb25zZVRpbWVvdXQ6IGlucHV0LnJlc3BvbnNlVGltZW91dCxcbiAgICByZXNwb25zZVRvOiBpbnB1dC5yZXNwb25zZVRvLFxuICAgIHNpZ25hbDogaW5wdXQuc2lnbmFsLFxuICAgIHNvdXJjZXM6IGlucHV0LnNvdXJjZXMgaW5zdGFuY2VvZiBTZXQgPyBpbnB1dC5zb3VyY2VzIDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW2lucHV0LnNvdXJjZXNdKSxcbiAgICBzdXBwcmVzc1dhcm5pbmdzOiBpbnB1dC5zdXBwcmVzc1dhcm5pbmdzLFxuICAgIHRhcmdldE9yaWdpbjogaW5wdXQudGFyZ2V0T3JpZ2luLFxuICAgIHRvOiBpbnB1dC50byxcbiAgICB0eXBlOiBpbnB1dC50eXBlXG4gIH0pLFxuICBpbml0aWFsOiBcImlkbGVcIixcbiAgb246IHtcbiAgICBhYm9ydDogXCIuYWJvcnRlZFwiXG4gIH0sXG4gIHN0YXRlczoge1xuICAgIGlkbGU6IHtcbiAgICAgIGFmdGVyOiB7XG4gICAgICAgIGluaXRpYWxUaW1lb3V0OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInNlbmRpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VuZGluZzoge1xuICAgICAgZW50cnk6IHtcbiAgICAgICAgdHlwZTogXCJzZW5kIG1lc3NhZ2VcIixcbiAgICAgICAgcGFyYW1zOiAoeyBjb250ZXh0IH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGNoYW5uZWxJZCwgZGF0YSwgZG9tYWluLCBmcm9tLCBpZCwgcmVzcG9uc2VUbywgdG8sIHR5cGUgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZToge1xuICAgICAgICAgICAgY2hhbm5lbElkLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHJlc3BvbnNlVG9cbiAgICAgICAgICB9IH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbHdheXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGd1YXJkOiBcImV4cGVjdHNSZXNwb25zZVwiLFxuICAgICAgICAgIHRhcmdldDogXCJhd2FpdGluZ1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3VjY2Vzc1wiXG4gICAgICBdXG4gICAgfSxcbiAgICBhd2FpdGluZzoge1xuICAgICAgaW52b2tlOiB7XG4gICAgICAgIGlkOiBcImxpc3RlbiBmb3IgcmVzcG9uc2VcIixcbiAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICBpbnB1dDogKHsgY29udGV4dCB9KSA9PiAoe1xuICAgICAgICAgIHJlcXVlc3RJZDogY29udGV4dC5pZCxcbiAgICAgICAgICBzb3VyY2VzOiBjb250ZXh0LnNvdXJjZXMsXG4gICAgICAgICAgc2lnbmFsOiBjb250ZXh0LnNpZ25hbFxuICAgICAgICB9KSxcbiAgICAgICAgb25FcnJvcjogXCJhYm9ydGVkXCJcbiAgICAgIH0sXG4gICAgICBhZnRlcjoge1xuICAgICAgICByZXNwb25zZVRpbWVvdXQ6IFwiZmFpbGVkXCJcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgYWN0aW9uczogYXNzaWduKHtcbiAgICAgICAgICAgIHJlc3BvbnNlOiAoeyBldmVudCB9KSA9PiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgICAgICByZXNwb25zZVRvOiAoeyBldmVudCB9KSA9PiBldmVudC5kYXRhLnJlc3BvbnNlVG9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0YXJnZXQ6IFwic3VjY2Vzc1wiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZhaWxlZDoge1xuICAgICAgdHlwZTogXCJmaW5hbFwiLFxuICAgICAgZW50cnk6IFwib24gZmFpbFwiXG4gICAgfSxcbiAgICBzdWNjZXNzOiB7XG4gICAgICB0eXBlOiBcImZpbmFsXCIsXG4gICAgICBlbnRyeTogXCJvbiBzdWNjZXNzXCJcbiAgICB9LFxuICAgIGFib3J0ZWQ6IHtcbiAgICAgIHR5cGU6IFwiZmluYWxcIixcbiAgICAgIGVudHJ5OiBcIm9uIGFib3J0XCJcbiAgICB9XG4gIH0sXG4gIG91dHB1dDogKHsgY29udGV4dCwgc2VsZiB9KSA9PiAoe1xuICAgIHJlcXVlc3RJZDogc2VsZi5pZCxcbiAgICByZXNwb25zZTogY29udGV4dC5yZXNwb25zZSxcbiAgICByZXNwb25zZVRvOiBjb250ZXh0LnJlc3BvbnNlVG9cbiAgfSlcbn0pLCBzZW5kQmFja0F0SW50ZXJ2YWwgPSBmcm9tQ2FsbGJhY2soKHsgc2VuZEJhY2ssIGlucHV0IH0pID0+IHtcbiAgY29uc3Qgc2VuZCA9ICgpID0+IHtcbiAgICBzZW5kQmFjayhpbnB1dC5ldmVudCk7XG4gIH07XG4gIGlucHV0LmltbWVkaWF0ZSAmJiBzZW5kKCk7XG4gIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoc2VuZCwgaW5wdXQuaW50ZXJ2YWwpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9O1xufSksIGNyZWF0ZUNvbm5lY3Rpb25NYWNoaW5lID0gKCkgPT4gc2V0dXAoe1xuICB0eXBlczoge30sXG4gIGFjdG9yczoge1xuICAgIHJlcXVlc3RNYWNoaW5lOiBjcmVhdGVSZXF1ZXN0TWFjaGluZSgpLFxuICAgIGxpc3RlbjogY3JlYXRlTGlzdGVuTG9naWMoKSxcbiAgICBzZW5kQmFja0F0SW50ZXJ2YWxcbiAgfSxcbiAgYWN0aW9uczoge1xuICAgIFwiYnVmZmVyIG1lc3NhZ2VcIjogZW5xdWV1ZUFjdGlvbnMoKHsgZW5xdWV1ZSB9KSA9PiB7XG4gICAgICBlbnF1ZXVlLmFzc2lnbih7XG4gICAgICAgIGJ1ZmZlcjogKHsgZXZlbnQsIGNvbnRleHQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIFsuLi5jb250ZXh0LmJ1ZmZlciwgZXZlbnQuZGF0YV0pXG4gICAgICB9KSwgZW5xdWV1ZS5lbWl0KCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJwb3N0XCIpLCB7XG4gICAgICAgIHR5cGU6IFwiX2J1ZmZlci5hZGRlZFwiLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5kYXRhXG4gICAgICB9KSk7XG4gICAgfSksXG4gICAgXCJjcmVhdGUgcmVxdWVzdFwiOiBhc3NpZ24oe1xuICAgICAgcmVxdWVzdHM6ICh7IGNvbnRleHQsIGV2ZW50LCBzZWxmLCBzcGF3biB9KSA9PiB7XG4gICAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBcInJlcXVlc3RcIik7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gKEFycmF5LmlzQXJyYXkoZXZlbnQuZGF0YSkgPyBldmVudC5kYXRhIDogW2V2ZW50LmRhdGFdKS5tYXAoKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGByZXEtJHt2NCgpfWA7XG4gICAgICAgICAgcmV0dXJuIHNwYXduKFwicmVxdWVzdE1hY2hpbmVcIiwge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBpbnB1dDoge1xuICAgICAgICAgICAgICBjaGFubmVsSWQ6IGNvbnRleHQuY2hhbm5lbElkLFxuICAgICAgICAgICAgICBkYXRhOiByZXF1ZXN0LmRhdGEsXG4gICAgICAgICAgICAgIGRvbWFpbjogY29udGV4dC5kb21haW4sXG4gICAgICAgICAgICAgIGV4cGVjdFJlc3BvbnNlOiByZXF1ZXN0LmV4cGVjdFJlc3BvbnNlLFxuICAgICAgICAgICAgICBmcm9tOiBjb250ZXh0Lm5hbWUsXG4gICAgICAgICAgICAgIHBhcmVudFJlZjogc2VsZixcbiAgICAgICAgICAgICAgcmVzcG9uc2VUbzogcmVxdWVzdC5yZXNwb25zZVRvLFxuICAgICAgICAgICAgICBzb3VyY2VzOiBjb250ZXh0LnRhcmdldCxcbiAgICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBjb250ZXh0LnRhcmdldE9yaWdpbixcbiAgICAgICAgICAgICAgdG86IGNvbnRleHQuY29ubmVjdFRvLFxuICAgICAgICAgICAgICB0eXBlOiByZXF1ZXN0LnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4uY29udGV4dC5yZXF1ZXN0cywgLi4ucmVxdWVzdHNdO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFwiZW1pdCByZWNlaXZlZCBtZXNzYWdlXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5lbWl0KCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCB7XG4gICAgICAgIHR5cGU6IFwiX21lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZS5kYXRhXG4gICAgICB9KSksIGVucXVldWUuZW1pdCgoeyBldmVudCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibWVzc2FnZS5yZWNlaXZlZFwiKSwge1xuICAgICAgICB0eXBlOiBldmVudC5tZXNzYWdlLmRhdGEudHlwZSxcbiAgICAgICAgbWVzc2FnZTogZXZlbnQubWVzc2FnZS5kYXRhXG4gICAgICB9KSk7XG4gICAgfSksXG4gICAgXCJlbWl0IHN0YXR1c1wiOiBlbWl0KChfLCBwYXJhbXMpID0+ICh7XG4gICAgICB0eXBlOiBcIl9zdGF0dXNcIixcbiAgICAgIHN0YXR1czogcGFyYW1zLnN0YXR1c1xuICAgIH0pKSxcbiAgICBcImZsdXNoIGJ1ZmZlclwiOiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGVucXVldWUucmFpc2UoKHsgY29udGV4dCB9KSA9PiAoe1xuICAgICAgICB0eXBlOiBcInJlcXVlc3RcIixcbiAgICAgICAgZGF0YTogY29udGV4dC5idWZmZXIubWFwKCh7IGRhdGEsIHR5cGUgfSkgPT4gKHsgZGF0YSwgdHlwZSB9KSlcbiAgICAgIH0pKSwgZW5xdWV1ZS5lbWl0KCh7IGNvbnRleHQgfSkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJfYnVmZmVyLmZsdXNoZWRcIixcbiAgICAgICAgbWVzc2FnZXM6IGNvbnRleHQuYnVmZmVyXG4gICAgICB9KSksIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgYnVmZmVyOiBbXVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgcG9zdDogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV4cGVjdFJlc3BvbnNlOiAhMCxcbiAgICAgICAgdHlwZTogZXZlbnQuZGF0YS50eXBlXG4gICAgICB9XG4gICAgfSkpLFxuICAgIFwicmVtb3ZlIHJlcXVlc3RcIjogZW5xdWV1ZUFjdGlvbnMoKHsgY29udGV4dCwgZW5xdWV1ZSwgZXZlbnQgfSkgPT4ge1xuICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFtcInJlcXVlc3Quc3VjY2Vzc1wiLCBcInJlcXVlc3QuZmFpbGVkXCIsIFwicmVxdWVzdC5hYm9ydGVkXCJdKSwgc3RvcENoaWxkKGV2ZW50LnJlcXVlc3RJZCksIGVucXVldWUuYXNzaWduKHsgcmVxdWVzdHM6IGNvbnRleHQucmVxdWVzdHMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSBldmVudC5yZXF1ZXN0SWQpIH0pO1xuICAgIH0pLFxuICAgIHJlc3BvbmQ6IHJhaXNlKCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJyZXNwb25zZVwiKSwge1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgIHR5cGU6IE1TR19SRVNQT05TRSxcbiAgICAgICAgcmVzcG9uc2VUbzogZXZlbnQucmVzcG9uZFRvXG4gICAgICB9XG4gICAgfSkpLFxuICAgIFwic2VuZCBoYW5kc2hha2UgYWNrXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX0FDSyB9XG4gICAgfSksXG4gICAgXCJzZW5kIGRpc2Nvbm5lY3RcIjogcmFpc2UoKCkgPT4gKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfRElTQ09OTkVDVCB9XG4gICAgfSkpLFxuICAgIFwic2VuZCBoYW5kc2hha2Ugc3luXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX1NZTiB9XG4gICAgfSksXG4gICAgXCJzZXQgdGFyZ2V0XCI6IGFzc2lnbih7XG4gICAgICB0YXJnZXQ6ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJ0YXJnZXQuc2V0XCIpLCBldmVudC50YXJnZXQpXG4gICAgfSlcbiAgfSxcbiAgZ3VhcmRzOiB7XG4gICAgXCJoYXMgdGFyZ2V0XCI6ICh7IGNvbnRleHQgfSkgPT4gISFjb250ZXh0LnRhcmdldCxcbiAgICBcInNob3VsZCBzZW5kIGhlYXJ0YmVhdHNcIjogKHsgY29udGV4dCB9KSA9PiBjb250ZXh0LmhlYXJ0YmVhdFxuICB9XG59KS5jcmVhdGVNYWNoaW5lKHtcbiAgLyoqIEB4c3RhdGUtbGF5b3V0IE40SWdwZ0pnNW1ET0lDNVFHTUFXQkRBZHBzQWJBeEFDN29CT01oQWRMR0lRTm9BTUF1b3FBQTREMnNBbG9WKzVpeEFBUFJBSFpSQUpnb0FXQUJ6MEFySElDTXkyUUdaWkNnSndBYUVBRTlFRSt0SXJiNkFOZ2tMbDQ2ZlR1ajFBWHhmNjBXSEFSSmdBamdDdWNKU3dBY2pJY0xBTXpFZ2dITnk4LUlJaUNLTFMyaFFTNnFiMnl1cmlzckw2UmdqSzlMSXlDdXFxMGc3V3N0WnVIaGpZZVBpK2djRVVBR2JvWExpUTBZTHhQSHdDc1NtaUNnb3lrcGF5RHRxUzZ0cnF4WWpLRWswZ25xMjRGRndRQS1qSS1EaklkRXpEbktOSkV4dU9acFoxMmVxMjlPclNDdXVweXBZVW9qVWFUS0NubTVXazIxMjNnT1J6QStIaWx4aWJCdWlYR29CU0duVUFJVTRnVTlGV2FtVXRSK2xtVU0xRWxsQkVrc2xNVUVucGtKYTBKYUVGZ0dBQTFseE1GQjhMQURKZ2hyRVJxamtodHNoazNtVHRObzVPcHFwWWZxQ0toVHB0b3FwWTFXVXR1NGRreThCUVdXejBKenVlMS1FRllJanJna3hxTFN1cHFSUlBwb1BxSnRMSTBoSWlvWkVOSkpFN05uSjhaWUhWazFZeXZQckRSeXVUeUVZTGtUYTd1aXhWbE1oODFLR0ZoUzFqNkVQa1pscFZqVHBocjhta0kzc0RWaFdUSFRRQmJTTG9HQVVYd1JMZ0FOMEdWeUZLTnQ5MUtpbVVGRUtYdktDMnM5Uis2WCtqaXBuekplU3FFSjFVS2pOYU5KcDVFQzRzRk9yUXVDYmlmZVR3ZzJjZ295bTBSUHhEdHFrajBlYUI5QW84elNvbE1FaXZaVmNxNzErMzNjNUNFZ2VGT0N0WHNrelJNOEVEeEtScG1rU3czUUpiUXNtcEg1dEhtVjhKSFNiSnBEc2FrVjJhU01BTE9NQUxoQWpvTFhBeE5iaWdsSS1TeFd3MVZ3MFFORHcwUWZnOUtRN0VKU3hISHhBcEsyaFFDeU9BaUF6VmdEaE1Hb0k5aFg3Rk1FSFNGOGNXa2VscEhVUkNiQnNiNDgxeEFFZ1Q5QlFKQ21XUXNpRS1VUlBJOFRHMWdXQm16QVZzeUxBVHR1eVJZOUlMdFdvS21sTDgyS3FkMHRBVko5MUxNSEZaREtJa1Zsa05WWkhNa2lEekUtQWR6M1VqRHg3R2lSUUhDS25oZUQ1M2srSFNTa0RESXdwQlZUcVF3dUtLRXNzU0RUQVVoQ0FBSTNxeWcwRElyZDhGa2s4Nk1RVU1uVk0rUnlub2VnVERKSDQ4aEdwMHZSLUZEUnFxS3Fhc2dPcUd1YTlBUWpBVEFkMU5TaXVsNmZwWE90V2k3V3kxOWNzbEQ0dm5HN0lYM29WalZEVVZZRUpRcXJrc1c4U2RzdExxUEt5MHdLZ0cxUmh0TVdvZ3FLaG9NamtXcDZYeFV5RkJlM2MzdEF6NzB2Y282ZnErVjhQVGtHVUZ6ZFFxTm5FTEVNMnlDbHJ3d3pRNFpTaEtRSnFyN1VZVTk4QVMwVzlwVDR6NXBIRzB5WHdNa05OVHlHazNCMVRCMkFnT0JCRFhYQkRzeWhTRkc5RW92UXFONWkxSmVSY0txdzRCa2wrVG9NeDh4MGorRWFxUTlYTVNrQlVSTWdNa0V3UVdLcm8yTldOTmRQRkpBek4wbEpHTTRzbER4aEJFSmZYeXBsQmQwM3dXMUt4SWRuckJ4Qmg0SkF5Vzc1QzhySnBtRHFtSUdXa2dtcGFzUGpxVWNhSG9vTUxIQTB1VTFVa0pPZ0tXMUI2clQxYldvcjVBdDB6Z2NUQWtLN2hyejFpckIwRDhjVzBVdlJQTHl2MDdXcWdOcTJxQUcrbDlTblhVejBVT1hENXh1TXMzWTQrRFZKQlg3VWlLclY2UThnY2ZvSk81NHJGZWZMTHFmSllYMVdLWU5MeEw0Tk8xTndnQSAqL1xuICBpZDogXCJjb25uZWN0aW9uXCIsXG4gIGNvbnRleHQ6ICh7IGlucHV0IH0pID0+ICh7XG4gICAgaWQ6IGlucHV0LmlkIHx8IGAke2lucHV0Lm5hbWV9LSR7djQoKX1gLFxuICAgIGJ1ZmZlcjogW10sXG4gICAgY2hhbm5lbElkOiBgY2huLSR7djQoKX1gLFxuICAgIGNvbm5lY3RUbzogaW5wdXQuY29ubmVjdFRvLFxuICAgIGRvbWFpbjogaW5wdXQuZG9tYWluID8/IERPTUFJTixcbiAgICBoZWFydGJlYXQ6IGlucHV0LmhlYXJ0YmVhdCA/PyAhMSxcbiAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgIHJlcXVlc3RzOiBbXSxcbiAgICB0YXJnZXQ6IGlucHV0LnRhcmdldCxcbiAgICB0YXJnZXRPcmlnaW46IGlucHV0LnRhcmdldE9yaWdpblxuICB9KSxcbiAgb246IHtcbiAgICBcInRhcmdldC5zZXRcIjoge1xuICAgICAgYWN0aW9uczogXCJzZXQgdGFyZ2V0XCJcbiAgICB9LFxuICAgIFwicmVxdWVzdC5zdWNjZXNzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJyZXF1ZXN0LmZhaWxlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBcInJlbW92ZSByZXF1ZXN0XCJcbiAgICB9XG4gIH0sXG4gIGluaXRpYWw6IFwiaWRsZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBlbnRyeTogW3sgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImlkbGVcIiB9IH1dLFxuICAgICAgb246IHtcbiAgICAgICAgY29ubmVjdDoge1xuICAgICAgICAgIHRhcmdldDogXCJoYW5kc2hha2luZ1wiLFxuICAgICAgICAgIGd1YXJkOiBcImhhcyB0YXJnZXRcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRzaGFraW5nOiB7XG4gICAgICBpZDogXCJoYW5kc2hha2luZ1wiLFxuICAgICAgZW50cnk6IFt7IHR5cGU6IFwiZW1pdCBzdGF0dXNcIiwgcGFyYW1zOiB7IHN0YXR1czogXCJoYW5kc2hha2luZ1wiIH0gfV0sXG4gICAgICBpbnZva2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcInNlbmQgc3luXCIsXG4gICAgICAgICAgc3JjOiBcInNlbmRCYWNrQXRJbnRlcnZhbFwiLFxuICAgICAgICAgIGlucHV0OiAoKSA9PiAoe1xuICAgICAgICAgICAgZXZlbnQ6IHsgdHlwZTogXCJzeW5cIiB9LFxuICAgICAgICAgICAgaW50ZXJ2YWw6IEhBTkRTSEFLRV9JTlRFUlZBTCxcbiAgICAgICAgICAgIGltbWVkaWF0ZTogITBcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBoYW5kc2hha2VcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IChpbnB1dCkgPT4gbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0ssXG4gICAgICAgICAgICBjb3VudDogMVxuICAgICAgICAgIH0pKGlucHV0KVxuICAgICAgICAgIC8qIEJlbG93IHdvdWxkIG1heWJlIGJlIG1vcmUgcmVhZGFibGUgdGhhbiB0cmFuc2l0aW9uaW5nIHRvXG4gICAgICAgICAgJ2Nvbm5lY3RlZCcgb24gJ21lc3NhZ2UnLCBhbmQgJ2Fjaycgb24gZXhpdCBidXQgaGF2aW5nIG9uRG9uZSB3aGVuXG4gICAgICAgICAgdXNpbmcgcGFzc2luZyBpbnZvY2F0aW9ucyBjdXJyZW50bHkgYnJlYWtzIFhTdGF0ZSBFZGl0b3IgKi9cbiAgICAgICAgICAvLyBvbkRvbmU6IHtcbiAgICAgICAgICAvLyAgIHRhcmdldDogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgLy8gICBhY3Rpb25zOiAnYWNrJyxcbiAgICAgICAgICAvLyB9LFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb246IHtcbiAgICAgICAgc3luOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJzZW5kIGhhbmRzaGFrZSBzeW5cIlxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJjcmVhdGUgcmVxdWVzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcImJ1ZmZlciBtZXNzYWdlXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlLnJlY2VpdmVkXCI6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiY29ubmVjdGVkXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzY29ubmVjdDoge1xuICAgICAgICAgIHRhcmdldDogXCJkaXNjb25uZWN0ZWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhpdDogXCJzZW5kIGhhbmRzaGFrZSBhY2tcIlxuICAgIH0sXG4gICAgY29ubmVjdGVkOiB7XG4gICAgICBlbnRyeTogW1wiZmx1c2ggYnVmZmVyXCIsIHsgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImNvbm5lY3RlZFwiIH0gfV0sXG4gICAgICBpbnZva2U6IHtcbiAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBtZXNzYWdlc1wiLFxuICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgIGlucHV0OiBsaXN0ZW5JbnB1dEZyb21Db250ZXh0KHtcbiAgICAgICAgICBleGNsdWRlOiBbTVNHX1JFU1BPTlNFLCBNU0dfSEVBUlRCRUFUXVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcInBvc3RcIlxuICAgICAgICB9LFxuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJjcmVhdGUgcmVxdWVzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJyZXNwb25kXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZXNzYWdlLnJlY2VpdmVkXCI6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcImVtaXQgcmVjZWl2ZWQgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiZGlzY29ubmVjdGVkXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXRpYWw6IFwiaGVhcnRiZWF0XCIsXG4gICAgICBzdGF0ZXM6IHtcbiAgICAgICAgaGVhcnRiZWF0OiB7XG4gICAgICAgICAgaW5pdGlhbDogXCJjaGVja2luZ1wiLFxuICAgICAgICAgIHN0YXRlczoge1xuICAgICAgICAgICAgY2hlY2tpbmc6IHtcbiAgICAgICAgICAgICAgYWx3YXlzOiB7XG4gICAgICAgICAgICAgICAgZ3VhcmQ6IFwic2hvdWxkIHNlbmQgaGVhcnRiZWF0c1wiLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJzZW5kaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbmRpbmc6IHtcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcInJlcXVlc3QuZmFpbGVkXCI6IHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldDogXCIjaGFuZHNoYWtpbmdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW52b2tlOiB7XG4gICAgICAgICAgICAgICAgaWQ6IFwic2VuZCBoZWFydGJlYXRcIixcbiAgICAgICAgICAgICAgICBzcmM6IFwic2VuZEJhY2tBdEludGVydmFsXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICBldmVudDogeyB0eXBlOiBcInBvc3RcIiwgZGF0YTogeyB0eXBlOiBNU0dfSEVBUlRCRUFULCBkYXRhOiB2b2lkIDAgfSB9LFxuICAgICAgICAgICAgICAgICAgaW50ZXJ2YWw6IDJlMyxcbiAgICAgICAgICAgICAgICAgIGltbWVkaWF0ZTogITFcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNjb25uZWN0ZWQ6IHtcbiAgICAgIGlkOiBcImRpc2Nvbm5lY3RlZFwiLFxuICAgICAgZW50cnk6IFtcInNlbmQgZGlzY29ubmVjdFwiLCB7IHR5cGU6IFwiZW1pdCBzdGF0dXNcIiwgcGFyYW1zOiB7IHN0YXR1czogXCJkaXNjb25uZWN0ZWRcIiB9IH1dLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaGFuZHNoYWtpbmdcIixcbiAgICAgICAgICBndWFyZDogXCJoYXMgdGFyZ2V0XCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIGNyZWF0ZUNvbm5lY3Rpb24gPSAoaW5wdXQsIG1hY2hpbmUgPSBjcmVhdGVDb25uZWN0aW9uTWFjaGluZSgpKSA9PiB7XG4gIGNvbnN0IGlkID0gaW5wdXQuaWQgfHwgYCR7aW5wdXQubmFtZX0tJHt2NCgpfWAsIGFjdG9yID0gY3JlYXRlQWN0b3IobWFjaGluZSwge1xuICAgIGlucHV0OiB7IC4uLmlucHV0LCBpZCB9XG4gIH0pLCBvbiA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gYWN0b3Iub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0b2RvIGB0eXBlYCB0eXBpbmdcbiAgICAgIHR5cGUsXG4gICAgICBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGV2ZW50Lm1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIHJlc3BvbnNlICYmIGFjdG9yLnNlbmQoeyB0eXBlOiBcInJlc3BvbnNlXCIsIHJlc3BvbmRUbzogZXZlbnQubWVzc2FnZS5pZCwgZGF0YTogcmVzcG9uc2UgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIGNvbm5lY3QgPSAoKSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwiY29ubmVjdFwiIH0pO1xuICB9LCBkaXNjb25uZWN0ID0gKCkgPT4ge1xuICAgIGFjdG9yLnNlbmQoeyB0eXBlOiBcImRpc2Nvbm5lY3RcIiB9KTtcbiAgfSwgb25TdGF0dXMgPSAoaGFuZGxlciwgZmlsdGVyMikgPT4ge1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IGFjdG9yLm9uKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBAdG9kbyBSZWNlaXZlZEVtaXRFdmVudCBjYXVzZXMgdGhpc1xuICAgICAgXCJfc3RhdHVzXCIsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZmlsdGVyMiAmJiBldmVudC5zdGF0dXMgIT09IGZpbHRlcjIgfHwgaGFuZGxlcihldmVudC5zdGF0dXMpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBzZXRUYXJnZXQgPSAodGFyZ2V0KSA9PiB7XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwidGFyZ2V0LnNldFwiLCB0YXJnZXQgfSk7XG4gIH0sIHBvc3QgPSAodHlwZSwgZGF0YSkgPT4ge1xuICAgIGNvbnN0IF9kYXRhID0geyB0eXBlLCBkYXRhIH07XG4gICAgYWN0b3Iuc2VuZCh7IHR5cGU6IFwicG9zdFwiLCBkYXRhOiBfZGF0YSB9KTtcbiAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICBhY3Rvci5zdG9wKCk7XG4gIH0sIHN0YXJ0ID0gKCkgPT4gKGFjdG9yLnN0YXJ0KCksIHN0b3ApO1xuICByZXR1cm4ge1xuICAgIGFjdG9yLFxuICAgIGNvbm5lY3QsXG4gICAgZGlzY29ubmVjdCxcbiAgICBpZCxcbiAgICBuYW1lOiBpbnB1dC5uYW1lLFxuICAgIG1hY2hpbmUsXG4gICAgb24sXG4gICAgb25TdGF0dXMsXG4gICAgcG9zdCxcbiAgICBzZXRUYXJnZXQsXG4gICAgc3RhcnQsXG4gICAgc3RvcCxcbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIGFjdG9yLmdldFNuYXBzaG90KCkuY29udGV4dC50YXJnZXQ7XG4gICAgfVxuICB9O1xufSwgY2xlYW51cENvbm5lY3Rpb24gPSAoY29ubmVjdGlvbikgPT4ge1xuICBjb25uZWN0aW9uLmRpc2Nvbm5lY3QoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY29ubmVjdGlvbi5zdG9wKCk7XG4gIH0sIDApO1xufSwgbm9vcCA9ICgpID0+IHtcbn0sIGNyZWF0ZUNvbnRyb2xsZXIgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgeyB0YXJnZXRPcmlnaW4gfSA9IGlucHV0LCB0YXJnZXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgY2hhbm5lbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4ge1xuICAgIGFkZFRhcmdldDogKHRhcmdldCkgPT4ge1xuICAgICAgaWYgKHRhcmdldHMuaGFzKHRhcmdldCkpXG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgaWYgKCF0YXJnZXRzLnNpemUgfHwgIWNoYW5uZWxzLnNpemUpXG4gICAgICAgIHJldHVybiB0YXJnZXRzLmFkZCh0YXJnZXQpLCBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgY2hhbm5lbC5jb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnNldFRhcmdldCh0YXJnZXQpLCBjb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSksICgpID0+IHtcbiAgICAgICAgICB0YXJnZXRzLmRlbGV0ZSh0YXJnZXQpLCBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICBjaGFubmVsLmNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbi50YXJnZXQgPT09IHRhcmdldCAmJiBjb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgdGFyZ2V0cy5hZGQodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHRhcmdldENvbm5lY3Rpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHJldHVybiBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBjcmVhdGVDb25uZWN0aW9uKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNoYW5uZWwuaW5wdXQsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXRPcmlnaW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoYW5uZWwubWFjaGluZVxuICAgICAgICApO1xuICAgICAgICB0YXJnZXRDb25uZWN0aW9ucy5hZGQoY29ubmVjdGlvbiksIGNoYW5uZWwuY29ubmVjdGlvbnMuYWRkKGNvbm5lY3Rpb24pLCBjaGFubmVsLnN1YnNjcmliZXJzLmZvckVhY2goKHsgdHlwZSwgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9KSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNvbm5lY3Rpb24ub24odHlwZSwgaGFuZGxlcikpO1xuICAgICAgICB9KSwgY2hhbm5lbC5pbnRlcm5hbEV2ZW50U3Vic2NyaWJlcnMuZm9yRWFjaCgoeyB0eXBlLCBoYW5kbGVyLCB1bnN1YnNjcmliZXJzIH0pID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLnB1c2goY29ubmVjdGlvbi5hY3Rvci5vbih0eXBlLCBoYW5kbGVyKS51bnN1YnNjcmliZSk7XG4gICAgICAgIH0pLCBjaGFubmVsLnN0YXR1c1N1YnNjcmliZXJzLmZvckVhY2goKHsgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9KSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblN0YXR1cygoc3RhdHVzKSA9PiBoYW5kbGVyKHsgY29ubmVjdGlvbjogY29ubmVjdGlvbi5pZCwgc3RhdHVzIH0pKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pLCBjb25uZWN0aW9uLnN0YXJ0KCksIGNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgfSksICgpID0+IHtcbiAgICAgICAgdGFyZ2V0cy5kZWxldGUodGFyZ2V0KSwgdGFyZ2V0Q29ubmVjdGlvbnMuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgIGNsZWFudXBDb25uZWN0aW9uKGNvbm5lY3Rpb24pLCBjaGFubmVscy5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICBjaGFubmVsLmNvbm5lY3Rpb25zLmRlbGV0ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlQ2hhbm5lbDogKGlucHV0MiwgbWFjaGluZSA9IGNyZWF0ZUNvbm5lY3Rpb25NYWNoaW5lKCkpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSB7XG4gICAgICAgIGNvbm5lY3Rpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBpbnB1dDogaW5wdXQyLFxuICAgICAgICBpbnRlcm5hbEV2ZW50U3Vic2NyaWJlcnM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIG1hY2hpbmUsXG4gICAgICAgIHN0YXR1c1N1YnNjcmliZXJzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIGNoYW5uZWxzLmFkZChjaGFubmVsKTtcbiAgICAgIGNvbnN0IHsgY29ubmVjdGlvbnMsIGludGVybmFsRXZlbnRTdWJzY3JpYmVycywgc3RhdHVzU3Vic2NyaWJlcnMsIHN1YnNjcmliZXJzIH0gPSBjaGFubmVsO1xuICAgICAgaWYgKHRhcmdldHMuc2l6ZSlcbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gY3JlYXRlQ29ubmVjdGlvbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uaW5wdXQyLFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHRhcmdldE9yaWdpblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hY2hpbmVcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbm5lY3Rpb25zLmFkZChjb25uZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGNyZWF0ZUNvbm5lY3Rpb24oeyAuLi5pbnB1dDIsIHRhcmdldE9yaWdpbiB9LCBtYWNoaW5lKTtcbiAgICAgICAgY29ubmVjdGlvbnMuYWRkKGNvbm5lY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zdCA9ICguLi5wYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgW3R5cGUsIGRhdGFdID0gcGFyYW1zO1xuICAgICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5wb3N0KHR5cGUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIG9uID0gKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKGNvbm5lY3Rpb24ub24odHlwZSwgaGFuZGxlcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IHsgdHlwZSwgaGFuZGxlciwgdW5zdWJzY3JpYmVycyB9O1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpLCAoKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5mb3JFYWNoKCh1bnN1YikgPT4gdW5zdWIoKSksIHN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIG9uSW50ZXJuYWxFdmVudCA9ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgY29ubmVjdGlvbnMuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlcnMucHVzaChjb25uZWN0aW9uLmFjdG9yLm9uKHR5cGUsIGhhbmRsZXIpLnVuc3Vic2NyaWJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB7IHR5cGUsIGhhbmRsZXIsIHVuc3Vic2NyaWJlcnMgfTtcbiAgICAgICAgcmV0dXJuIGludGVybmFsRXZlbnRTdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlciksICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKSwgaW50ZXJuYWxFdmVudFN1YnNjcmliZXJzLmRlbGV0ZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIG9uU3RhdHVzID0gKGhhbmRsZXIpID0+IHtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICBjb25uZWN0aW9ucy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgdW5zdWJzY3JpYmVycy5wdXNoKFxuICAgICAgICAgICAgY29ubmVjdGlvbi5vblN0YXR1cygoc3RhdHVzKSA9PiBoYW5kbGVyKHsgY29ubmVjdGlvbjogY29ubmVjdGlvbi5pZCwgc3RhdHVzIH0pKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0geyBoYW5kbGVyLCB1bnN1YnNjcmliZXJzIH07XG4gICAgICAgIHJldHVybiBzdGF0dXNTdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlciksICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZXJzLmZvckVhY2goKHVuc3ViKSA9PiB1bnN1YigpKSwgc3RhdHVzU3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuICAgICAgICB9O1xuICAgICAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbnMyID0gY2hhbm5lbC5jb25uZWN0aW9ucztcbiAgICAgICAgY29ubmVjdGlvbnMyLmZvckVhY2goY2xlYW51cENvbm5lY3Rpb24pLCBjb25uZWN0aW9uczIuY2xlYXIoKSwgY2hhbm5lbHMuZGVsZXRlKGNoYW5uZWwpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uLFxuICAgICAgICBvbkludGVybmFsRXZlbnQsXG4gICAgICAgIG9uU3RhdHVzLFxuICAgICAgICBwb3N0LFxuICAgICAgICBzdGFydDogKCkgPT4gKGNvbm5lY3Rpb25zLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnN0YXJ0KCksIGNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICB9KSwgc3RvcCksXG4gICAgICAgIHN0b3BcbiAgICAgIH07XG4gICAgfSxcbiAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICBjaGFubmVscy5mb3JFYWNoKCh7IGNvbm5lY3Rpb25zIH0pID0+IHtcbiAgICAgICAgY29ubmVjdGlvbnMuZm9yRWFjaChjbGVhbnVwQ29ubmVjdGlvbiksIGNvbm5lY3Rpb25zLmNsZWFyKCk7XG4gICAgICB9KSwgY2hhbm5lbHMuY2xlYXIoKSwgdGFyZ2V0cy5jbGVhcigpO1xuICAgIH1cbiAgfTtcbn0sIGNyZWF0ZU5vZGVNYWNoaW5lID0gKCkgPT4gc2V0dXAoe1xuICB0eXBlczoge30sXG4gIGFjdG9yczoge1xuICAgIHJlcXVlc3RNYWNoaW5lOiBjcmVhdGVSZXF1ZXN0TWFjaGluZSgpLFxuICAgIGxpc3RlbjogY3JlYXRlTGlzdGVuTG9naWMoKVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgXCJidWZmZXIgaW5jb21pbmcgbWVzc2FnZVwiOiBhc3NpZ24oe1xuICAgICAgaGFuZHNoYWtlQnVmZmVyOiAoeyBldmVudCwgY29udGV4dCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwibWVzc2FnZS5yZWNlaXZlZFwiKSwgWy4uLmNvbnRleHQuaGFuZHNoYWtlQnVmZmVyLCBldmVudF0pXG4gICAgfSksXG4gICAgXCJidWZmZXIgbWVzc2FnZVwiOiBlbnF1ZXVlQWN0aW9ucygoeyBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgYnVmZmVyOiAoeyBldmVudCwgY29udGV4dCB9KSA9PiAoYXNzZXJ0RXZlbnQoZXZlbnQsIFwicG9zdFwiKSwgW1xuICAgICAgICAgIC4uLmNvbnRleHQuYnVmZmVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRhdGE6IGV2ZW50LmRhdGEsXG4gICAgICAgICAgICByZXNvbHZhYmxlOiBldmVudC5yZXNvbHZhYmxlLFxuICAgICAgICAgICAgb3B0aW9uczogZXZlbnQub3B0aW9uc1xuICAgICAgICAgIH1cbiAgICAgICAgXSlcbiAgICAgIH0pLCBlbnF1ZXVlLmVtaXQoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgICAgdHlwZTogXCJfYnVmZmVyLmFkZGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50LmRhdGFcbiAgICAgIH0pKTtcbiAgICB9KSxcbiAgICBcImNyZWF0ZSByZXF1ZXN0XCI6IGFzc2lnbih7XG4gICAgICByZXF1ZXN0czogKHsgY29udGV4dCwgZXZlbnQsIHNlbGYsIHNwYXduIH0pID0+IHtcbiAgICAgICAgYXNzZXJ0RXZlbnQoZXZlbnQsIFwicmVxdWVzdFwiKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSAoQXJyYXkuaXNBcnJheShldmVudC5kYXRhKSA/IGV2ZW50LmRhdGEgOiBbZXZlbnQuZGF0YV0pLm1hcCgocmVxdWVzdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gYHJlcS0ke3Y0KCl9YDtcbiAgICAgICAgICByZXR1cm4gc3Bhd24oXCJyZXF1ZXN0TWFjaGluZVwiLCB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGlucHV0OiB7XG4gICAgICAgICAgICAgIGNoYW5uZWxJZDogY29udGV4dC5jaGFubmVsSWQsXG4gICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3QuZGF0YSxcbiAgICAgICAgICAgICAgZG9tYWluOiBjb250ZXh0LmRvbWFpbixcbiAgICAgICAgICAgICAgZXhwZWN0UmVzcG9uc2U6IHJlcXVlc3QuZXhwZWN0UmVzcG9uc2UsXG4gICAgICAgICAgICAgIGZyb206IGNvbnRleHQubmFtZSxcbiAgICAgICAgICAgICAgcGFyZW50UmVmOiBzZWxmLFxuICAgICAgICAgICAgICByZXNvbHZhYmxlOiByZXF1ZXN0LnJlc29sdmFibGUsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVGltZW91dDogcmVxdWVzdC5vcHRpb25zPy5yZXNwb25zZVRpbWVvdXQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVG86IHJlcXVlc3QucmVzcG9uc2VUbyxcbiAgICAgICAgICAgICAgc2lnbmFsOiByZXF1ZXN0Lm9wdGlvbnM/LnNpZ25hbCxcbiAgICAgICAgICAgICAgc291cmNlczogY29udGV4dC50YXJnZXQsXG4gICAgICAgICAgICAgIHN1cHByZXNzV2FybmluZ3M6IHJlcXVlc3Qub3B0aW9ucz8uc3VwcHJlc3NXYXJuaW5ncyxcbiAgICAgICAgICAgICAgdGFyZ2V0T3JpZ2luOiBjb250ZXh0LnRhcmdldE9yaWdpbixcbiAgICAgICAgICAgICAgdG86IGNvbnRleHQuY29ubmVjdFRvLFxuICAgICAgICAgICAgICB0eXBlOiByZXF1ZXN0LnR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4uY29udGV4dC5yZXF1ZXN0cywgLi4ucmVxdWVzdHNdO1xuICAgICAgfVxuICAgIH0pLFxuICAgIFwiZW1pdCBoZWFydGJlYXRcIjogZW1pdCgoKSA9PiAoe1xuICAgICAgdHlwZTogXCJfaGVhcnRiZWF0XCJcbiAgICB9KSksXG4gICAgXCJlbWl0IHJlY2VpdmVkIG1lc3NhZ2VcIjogZW5xdWV1ZUFjdGlvbnMoKHsgZW5xdWV1ZSB9KSA9PiB7XG4gICAgICBlbnF1ZXVlLmVtaXQoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcIm1lc3NhZ2UucmVjZWl2ZWRcIiksIHtcbiAgICAgICAgdHlwZTogXCJfbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLmRhdGFcbiAgICAgIH0pKSwgZW5xdWV1ZS5lbWl0KCh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJtZXNzYWdlLnJlY2VpdmVkXCIpLCB7XG4gICAgICAgIHR5cGU6IGV2ZW50Lm1lc3NhZ2UuZGF0YS50eXBlLFxuICAgICAgICBtZXNzYWdlOiBldmVudC5tZXNzYWdlLmRhdGFcbiAgICAgIH0pKTtcbiAgICB9KSxcbiAgICBcImVtaXQgc3RhdHVzXCI6IGVtaXQoKF8sIHBhcmFtcykgPT4gKHtcbiAgICAgIHR5cGU6IFwiX3N0YXR1c1wiLFxuICAgICAgc3RhdHVzOiBwYXJhbXMuc3RhdHVzXG4gICAgfSkpLFxuICAgIFwiZmx1c2ggYnVmZmVyXCI6IGVucXVldWVBY3Rpb25zKCh7IGVucXVldWUgfSkgPT4ge1xuICAgICAgZW5xdWV1ZS5yYWlzZSgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICBkYXRhOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSwgcmVzb2x2YWJsZSwgb3B0aW9ucyB9KSA9PiAoe1xuICAgICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICAgICAgZXhwZWN0UmVzcG9uc2U6ICEhcmVzb2x2YWJsZSxcbiAgICAgICAgICByZXNvbHZhYmxlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSkpXG4gICAgICB9KSksIGVucXVldWUuZW1pdCgoeyBjb250ZXh0IH0pID0+ICh7XG4gICAgICAgIHR5cGU6IFwiX2J1ZmZlci5mbHVzaGVkXCIsXG4gICAgICAgIG1lc3NhZ2VzOiBjb250ZXh0LmJ1ZmZlci5tYXAoKHsgZGF0YSB9KSA9PiBkYXRhKVxuICAgICAgfSkpLCBlbnF1ZXVlLmFzc2lnbih7XG4gICAgICAgIGJ1ZmZlcjogW11cbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIFwiZmx1c2ggaGFuZHNoYWtlIGJ1ZmZlclwiOiBlbnF1ZXVlQWN0aW9ucygoeyBjb250ZXh0LCBlbnF1ZXVlIH0pID0+IHtcbiAgICAgIGNvbnRleHQuaGFuZHNoYWtlQnVmZmVyLmZvckVhY2goKGV2ZW50KSA9PiBlbnF1ZXVlLnJhaXNlKGV2ZW50KSksIGVucXVldWUuYXNzaWduKHtcbiAgICAgICAgaGFuZHNoYWtlQnVmZmVyOiBbXVxuICAgICAgfSk7XG4gICAgfSksXG4gICAgcG9zdDogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcInBvc3RcIiksIHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhOiBldmVudC5kYXRhLmRhdGEsXG4gICAgICAgIGV4cGVjdFJlc3BvbnNlOiAhIWV2ZW50LnJlc29sdmFibGUsXG4gICAgICAgIHR5cGU6IGV2ZW50LmRhdGEudHlwZSxcbiAgICAgICAgcmVzb2x2YWJsZTogZXZlbnQucmVzb2x2YWJsZSxcbiAgICAgICAgb3B0aW9uczogZXZlbnQub3B0aW9uc1xuICAgICAgfVxuICAgIH0pKSxcbiAgICBcInJlbW92ZSByZXF1ZXN0XCI6IGVucXVldWVBY3Rpb25zKCh7IGNvbnRleHQsIGVucXVldWUsIGV2ZW50IH0pID0+IHtcbiAgICAgIGFzc2VydEV2ZW50KGV2ZW50LCBbXCJyZXF1ZXN0LnN1Y2Nlc3NcIiwgXCJyZXF1ZXN0LmZhaWxlZFwiLCBcInJlcXVlc3QuYWJvcnRlZFwiXSksIHN0b3BDaGlsZChldmVudC5yZXF1ZXN0SWQpLCBlbnF1ZXVlLmFzc2lnbih7IHJlcXVlc3RzOiBjb250ZXh0LnJlcXVlc3RzLmZpbHRlcigoeyBpZCB9KSA9PiBpZCAhPT0gZXZlbnQucmVxdWVzdElkKSB9KTtcbiAgICB9KSxcbiAgICBcInNlbmQgcmVzcG9uc2VcIjogcmFpc2UoKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBbXCJtZXNzYWdlLnJlY2VpdmVkXCIsIFwiaGVhcnRiZWF0LnJlY2VpdmVkXCJdKSwge1xuICAgICAgdHlwZTogXCJyZXF1ZXN0XCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IE1TR19SRVNQT05TRSxcbiAgICAgICAgcmVzcG9uc2VUbzogZXZlbnQubWVzc2FnZS5kYXRhLmlkLFxuICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgIH1cbiAgICB9KSksXG4gICAgXCJzZW5kIGhhbmRzaGFrZSBzeW4gYWNrXCI6IHJhaXNlKHtcbiAgICAgIHR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgZGF0YTogeyB0eXBlOiBNU0dfSEFORFNIQUtFX1NZTl9BQ0sgfVxuICAgIH0pLFxuICAgIFwic2V0IGNvbm5lY3Rpb24gY29uZmlnXCI6IGFzc2lnbih7XG4gICAgICBjaGFubmVsSWQ6ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJoYW5kc2hha2Uuc3luXCIpLCBldmVudC5tZXNzYWdlLmRhdGEuY2hhbm5lbElkKSxcbiAgICAgIHRhcmdldDogKHsgZXZlbnQgfSkgPT4gKGFzc2VydEV2ZW50KGV2ZW50LCBcImhhbmRzaGFrZS5zeW5cIiksIGV2ZW50Lm1lc3NhZ2Uuc291cmNlIHx8IHZvaWQgMCksXG4gICAgICB0YXJnZXRPcmlnaW46ICh7IGV2ZW50IH0pID0+IChhc3NlcnRFdmVudChldmVudCwgXCJoYW5kc2hha2Uuc3luXCIpLCBldmVudC5tZXNzYWdlLm9yaWdpbilcbiAgICB9KVxuICB9LFxuICBndWFyZHM6IHtcbiAgICBoYXNTb3VyY2U6ICh7IGNvbnRleHQgfSkgPT4gY29udGV4dC50YXJnZXQgIT09IG51bGxcbiAgfVxufSkuY3JlYXRlTWFjaGluZSh7XG4gIC8qKiBAeHN0YXRlLWxheW91dCBONElncGdKZzVtRE9JQzVRRHNEMkV3R0lCT1lDT0FybkFDNEIwc0JBeHBYTEFOb0FNQXVvcUFBNnF3Q1d4WHF5ckVBQTlFQVZnWUFXVWdFWUpEVVFBNEpBWm1VU0pDMGNvRHNBR2hBQlBSTklZTFNFcmRPa0JPQUd6YngyMjdZVUJmVi1yUVljK0lyRElBWmdDR1hBQTJrSXdzU0NBYzNMejhnaUlJb2lha3FnQk1ES2JwMnRZUzBzcnAra1lJMHVudW51aGdwRndRNFpnUS1OVmN5QUJ1cUFEVzFWN05kV0FJTGUyVVFmSElrWkdDc1R4OEF0Rko2YUtpcEF6V090cnBDN1o1QlVXR2lOb0s2YVMyNlJMVzJ0TGFxa3FxRlNBOU5YMllBTGEwUVRDa3VEUmNyUkhNazV4cGdrNW9nSkxaU05aSVZEb1ZDRkxaaW9oYklWU0xrWExaUkhaRGd4YkhjSHJWNnJGaUJOb2xOUm9sRVZKYkNzZEdVenNveWhpRWNsbE9DMURvd2VsVm1Wck9VUFBjcXFRQUJaQlpBUVdEQ2pvdEtBTkpvMU5xZGJvQzRXaThWQlNYSUtBRGVYRFViamY0a3dGa2tFSUxiZzhSWk1IS096V0t6S0prSEphMDg2WGE0cVpTNHBVaXNVU3FVK1Fna1luc1EwemNuSmFSTERicFp3S05RU0JZc3BtMk1FeUM1S1RuYURTU2QxOGg3SzcxcTMyRXdNeFlQQTBCSkZMS1k1eVp4SXJLU1VSTTBSbkZIU0JUclFxUTliYWJRZWpCQ3IycTlYU2lCY1dDVWZqSU1DVUluNm9OeEVQR3RUV0ZGUjBSVXk3aUd6dCszSXAwWFVSWFZaS1B2VkNmSUtjenlCK3Z5enFMem9HemN1SUcwTUdUeUN6dGpSdGphSmpiSFZNTkFVVGR1MVBVaHowdllocnlMT2NTd1hNdGhCZkswWkdzTFFHQlpla0NpMEpzbzFJZEkyM1dHMDR6T0U0d0lnNmNvSWdCb3gzSW1kaTFKUmRueE5PeFNITlNRa1d0VzBtVGpNeE1RN2ZEemdjYk5LbjdXaktKZU40UGkrTUFmaitlODRNZlVNRkhiWlp3eE9IWk5EeU8wOWdRT1FqbUFoWkpDTTlJTWpJeWNLT3ZRVXdDQ2JCaUFBSTJzc2hwTmtpQjZOTEo5RUlRQlFiV09kSmxNaFlDVWpiSmtjaFhHc0Ztc0pRTVZzV2wzQnpLcDRHaUhvQVhnanlrZ0FXbWtaWjZ4eTNMWkYyRW9iQ3k2eHNRV0pRNDJrRTRGakEtRXdCU3hUalNSVWhEZ3FremdPMkJ4ZHlrVTRBdlhGUS1Lak1DOHlIS1Y2cU5KaTZXT2RjeXBjWnNYR3hlMEpHMFh5U0tqTTVsS3NNeUx3c2lBeHNZenlsRGZPTnpuVUVxcm1pKzFUaGtIcVhET05iVUxpMXdnQSAqL1xuICBpZDogXCJub2RlXCIsXG4gIGNvbnRleHQ6ICh7IGlucHV0IH0pID0+ICh7XG4gICAgYnVmZmVyOiBbXSxcbiAgICBjaGFubmVsSWQ6IG51bGwsXG4gICAgY29ubmVjdFRvOiBpbnB1dC5jb25uZWN0VG8sXG4gICAgZG9tYWluOiBpbnB1dC5kb21haW4gPz8gRE9NQUlOLFxuICAgIGhhbmRzaGFrZUJ1ZmZlcjogW10sXG4gICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICByZXF1ZXN0czogW10sXG4gICAgdGFyZ2V0OiB2b2lkIDAsXG4gICAgdGFyZ2V0T3JpZ2luOiBudWxsXG4gIH0pLFxuICAvLyBBbHdheXMgbGlzdGVuIGZvciBoYW5kc2hha2Ugc3luIG1lc3NhZ2VzLiBUaGUgY2hhbm5lbCBjb3VsZCBoYXZlXG4gIC8vIGRpc2Nvbm5lY3RlZCB3aXRob3V0IGJlaW5nIGFibGUgdG8gbm90aWZ5IHRoZSBub2RlLCBhbmQgc28gbmVlZCB0b1xuICAvLyByZS1lc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24uXG4gIGludm9rZToge1xuICAgIGlkOiBcImxpc3RlbiBmb3IgaGFuZHNoYWtlIHN5blwiLFxuICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICBpbmNsdWRlOiBNU0dfSEFORFNIQUtFX1NZTixcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJoYW5kc2hha2Uuc3luXCJcbiAgICB9KVxuICB9LFxuICBvbjoge1xuICAgIFwicmVxdWVzdC5zdWNjZXNzXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJyZXF1ZXN0LmZhaWxlZFwiOiB7XG4gICAgICBhY3Rpb25zOiBcInJlbW92ZSByZXF1ZXN0XCJcbiAgICB9LFxuICAgIFwicmVxdWVzdC5hYm9ydGVkXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwicmVtb3ZlIHJlcXVlc3RcIlxuICAgIH0sXG4gICAgXCJoYW5kc2hha2Uuc3luXCI6IHtcbiAgICAgIGFjdGlvbnM6IFwic2V0IGNvbm5lY3Rpb24gY29uZmlnXCIsXG4gICAgICB0YXJnZXQ6IFwiLmhhbmRzaGFraW5nXCJcbiAgICB9XG4gIH0sXG4gIGluaXRpYWw6IFwiaWRsZVwiLFxuICBzdGF0ZXM6IHtcbiAgICBpZGxlOiB7XG4gICAgICBlbnRyeTogW3sgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImlkbGVcIiB9IH1dLFxuICAgICAgb246IHtcbiAgICAgICAgcG9zdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiYnVmZmVyIG1lc3NhZ2VcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kc2hha2luZzoge1xuICAgICAgZ3VhcmQ6IFwiaGFzU291cmNlXCIsXG4gICAgICBlbnRyeTogW1wic2VuZCBoYW5kc2hha2Ugc3luIGFja1wiLCB7IHR5cGU6IFwiZW1pdCBzdGF0dXNcIiwgcGFyYW1zOiB7IHN0YXR1czogXCJoYW5kc2hha2luZ1wiIH0gfV0sXG4gICAgICBpbnZva2U6IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgaGFuZHNoYWtlIGFja1wiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfSEFORFNIQUtFX0FDSyxcbiAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYG1lc3NhZ2UucmVjZWl2ZWRgIHJlc3BvbnNlVHlwZSB0byBwcmV2ZW50XG4gICAgICAgICAgICAvLyBidWZmZXJpbmcgdGhlIGFjayBtZXNzYWdlLiBXZSB0cmFuc2l0aW9uIHRvIHRoZSBjb25uZWN0ZWQgc3RhdGVcbiAgICAgICAgICAgIC8vIHVzaW5nIG9uRG9uZSBpbnN0ZWFkIG9mIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50IHVzaW5nIGBvbmBcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJoYW5kc2hha2UuY29tcGxldGVcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG9uRG9uZTogXCJjb25uZWN0ZWRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBkaXNjb25uZWN0XCIsXG4gICAgICAgICAgc3JjOiBcImxpc3RlblwiLFxuICAgICAgICAgIGlucHV0OiBsaXN0ZW5JbnB1dEZyb21Db250ZXh0KHtcbiAgICAgICAgICAgIGluY2x1ZGU6IE1TR19ESVNDT05ORUNULFxuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IFwiZGlzY29ubmVjdFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgbWVzc2FnZXNcIixcbiAgICAgICAgICBzcmM6IFwibGlzdGVuXCIsXG4gICAgICAgICAgaW5wdXQ6IGxpc3RlbklucHV0RnJvbUNvbnRleHQoe1xuICAgICAgICAgICAgZXhjbHVkZTogW1xuICAgICAgICAgICAgICBNU0dfRElTQ09OTkVDVCxcbiAgICAgICAgICAgICAgTVNHX0hBTkRTSEFLRV9TWU4sXG4gICAgICAgICAgICAgIE1TR19IQU5EU0hBS0VfQUNLLFxuICAgICAgICAgICAgICBNU0dfSEVBUlRCRUFULFxuICAgICAgICAgICAgICBNU0dfUkVTUE9OU0VcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb246IHtcbiAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgIGFjdGlvbnM6IFwiY3JlYXRlIHJlcXVlc3RcIlxuICAgICAgICB9LFxuICAgICAgICBwb3N0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWVzc2FnZS5yZWNlaXZlZFwiOiB7XG4gICAgICAgICAgYWN0aW9uczogXCJidWZmZXIgaW5jb21pbmcgbWVzc2FnZVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2Nvbm5lY3Q6IHtcbiAgICAgICAgICB0YXJnZXQ6IFwiaWRsZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbm5lY3RlZDoge1xuICAgICAgZW50cnk6IFtcbiAgICAgICAgXCJmbHVzaCBoYW5kc2hha2UgYnVmZmVyXCIsXG4gICAgICAgIFwiZmx1c2ggYnVmZmVyXCIsXG4gICAgICAgIHsgdHlwZTogXCJlbWl0IHN0YXR1c1wiLCBwYXJhbXM6IHsgc3RhdHVzOiBcImNvbm5lY3RlZFwiIH0gfVxuICAgICAgXSxcbiAgICAgIGludm9rZTogW1xuICAgICAgICB7XG4gICAgICAgICAgaWQ6IFwibGlzdGVuIGZvciBtZXNzYWdlc1wiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBleGNsdWRlOiBbXG4gICAgICAgICAgICAgIE1TR19ESVNDT05ORUNULFxuICAgICAgICAgICAgICBNU0dfSEFORFNIQUtFX1NZTixcbiAgICAgICAgICAgICAgTVNHX0hBTkRTSEFLRV9BQ0ssXG4gICAgICAgICAgICAgIE1TR19IRUFSVEJFQVQsXG4gICAgICAgICAgICAgIE1TR19SRVNQT05TRVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJsaXN0ZW4gZm9yIGhlYXJ0YmVhdFwiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfSEVBUlRCRUFULFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImhlYXJ0YmVhdC5yZWNlaXZlZFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcImxpc3RlbiBmb3IgZGlzY29ubmVjdFwiLFxuICAgICAgICAgIHNyYzogXCJsaXN0ZW5cIixcbiAgICAgICAgICBpbnB1dDogbGlzdGVuSW5wdXRGcm9tQ29udGV4dCh7XG4gICAgICAgICAgICBpbmNsdWRlOiBNU0dfRElTQ09OTkVDVCxcbiAgICAgICAgICAgIGNvdW50OiAxLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImRpc2Nvbm5lY3RcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBvbjoge1xuICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgYWN0aW9uczogXCJjcmVhdGUgcmVxdWVzdFwiXG4gICAgICAgIH0sXG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICBhY3Rpb25zOiBcInBvc3RcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNjb25uZWN0OiB7XG4gICAgICAgICAgdGFyZ2V0OiBcImlkbGVcIlxuICAgICAgICB9LFxuICAgICAgICBcIm1lc3NhZ2UucmVjZWl2ZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtcInNlbmQgcmVzcG9uc2VcIiwgXCJlbWl0IHJlY2VpdmVkIG1lc3NhZ2VcIl1cbiAgICAgICAgfSxcbiAgICAgICAgXCJoZWFydGJlYXQucmVjZWl2ZWRcIjoge1xuICAgICAgICAgIGFjdGlvbnM6IFtcInNlbmQgcmVzcG9uc2VcIiwgXCJlbWl0IGhlYXJ0YmVhdFwiXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgY3JlYXRlTm9kZSA9IChpbnB1dCwgbWFjaGluZSA9IGNyZWF0ZU5vZGVNYWNoaW5lKCkpID0+IHtcbiAgY29uc3QgYWN0b3IgPSBjcmVhdGVBY3RvcihtYWNoaW5lLCB7XG4gICAgaW5wdXRcbiAgfSksIG9uID0gKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICBjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBhY3Rvci5vbihcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQHRvZG8gUmVjZWl2ZWRFbWl0RXZlbnQgY2F1c2VzIHRoaXNcbiAgICAgIHR5cGUsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgaGFuZGxlcihldmVudC5tZXNzYWdlLmRhdGEpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9O1xuICBsZXQgY2FjaGVkU3RhdHVzO1xuICBjb25zdCBvblN0YXR1cyA9IChoYW5kbGVyLCBmaWx0ZXIyKSA9PiB7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gYWN0b3Iub24oXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEB0b2RvIFJlY2VpdmVkRW1pdEV2ZW50IGNhdXNlcyB0aGlzXG4gICAgICBcIl9zdGF0dXNcIixcbiAgICAgIChldmVudCkgPT4ge1xuICAgICAgICBjYWNoZWRTdGF0dXMgPSBldmVudC5zdGF0dXMsICEoZmlsdGVyMiAmJiBldmVudC5zdGF0dXMgIT09IGZpbHRlcjIpICYmIGhhbmRsZXIoZXZlbnQuc3RhdHVzKTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjYWNoZWRTdGF0dXMgJiYgaGFuZGxlcihjYWNoZWRTdGF0dXMpLCB1bnN1YnNjcmliZTtcbiAgfSwgcG9zdCA9ICh0eXBlLCBkYXRhKSA9PiB7XG4gICAgY29uc3QgX2RhdGEgPSB7IHR5cGUsIGRhdGEgfTtcbiAgICBhY3Rvci5zZW5kKHsgdHlwZTogXCJwb3N0XCIsIGRhdGE6IF9kYXRhIH0pO1xuICB9LCBmZXRjaCA9ICh0eXBlLCBkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyByZXNwb25zZVRpbWVvdXQgPSBGRVRDSF9USU1FT1VUX0RFRkFVTFQsIHNpZ25hbCwgc3VwcHJlc3NXYXJuaW5ncyB9ID0gb3B0aW9ucyB8fCB7fSwgcmVzb2x2YWJsZSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpLCBfZGF0YSA9IHsgdHlwZSwgZGF0YSB9O1xuICAgIHJldHVybiBhY3Rvci5zZW5kKHtcbiAgICAgIHR5cGU6IFwicG9zdFwiLFxuICAgICAgZGF0YTogX2RhdGEsXG4gICAgICByZXNvbHZhYmxlLFxuICAgICAgb3B0aW9uczogeyByZXNwb25zZVRpbWVvdXQsIHNpZ25hbCwgc3VwcHJlc3NXYXJuaW5ncyB9XG4gICAgfSksIHJlc29sdmFibGUucHJvbWlzZTtcbiAgfSwgc3RvcCA9ICgpID0+IHtcbiAgICBhY3Rvci5zdG9wKCk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgYWN0b3IsXG4gICAgZmV0Y2gsXG4gICAgbWFjaGluZSxcbiAgICBvbixcbiAgICBvblN0YXR1cyxcbiAgICBwb3N0LFxuICAgIHN0YXJ0OiAoKSA9PiAoYWN0b3Iuc3RhcnQoKSwgc3RvcCksXG4gICAgc3RvcFxuICB9O1xufTtcbmV4cG9ydCB7XG4gIERPTUFJTixcbiAgRkVUQ0hfVElNRU9VVF9ERUZBVUxULFxuICBIQU5EU0hBS0VfSU5URVJWQUwsXG4gIEhBTkRTSEFLRV9NU0dfVFlQRVMsXG4gIEhFQVJUQkVBVF9JTlRFUlZBTCxcbiAgSU5URVJOQUxfTVNHX1RZUEVTLFxuICBNU0dfRElTQ09OTkVDVCxcbiAgTVNHX0hBTkRTSEFLRV9BQ0ssXG4gIE1TR19IQU5EU0hBS0VfU1lOLFxuICBNU0dfSEFORFNIQUtFX1NZTl9BQ0ssXG4gIE1TR19IRUFSVEJFQVQsXG4gIE1TR19SRVNQT05TRSxcbiAgUkVTUE9OU0VfVElNRU9VVF9ERUZBVUxULFxuICBjcmVhdGVDb25uZWN0aW9uLFxuICBjcmVhdGVDb25uZWN0aW9uTWFjaGluZSxcbiAgY3JlYXRlQ29udHJvbGxlcixcbiAgY3JlYXRlTGlzdGVuTG9naWMsXG4gIGNyZWF0ZU5vZGUsXG4gIGNyZWF0ZU5vZGVNYWNoaW5lLFxuICBjcmVhdGVSZXF1ZXN0TWFjaGluZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbInY0IiwiZnJvbUV2ZW50T2JzZXJ2YWJsZSIsInNldHVwIiwic2VuZFRvIiwiYXNzaWduIiwiZnJvbUNhbGxiYWNrIiwiZW5xdWV1ZUFjdGlvbnMiLCJhc3NlcnRFdmVudCIsImVtaXQiLCJyYWlzZSIsInN0b3BDaGlsZCIsImNyZWF0ZUFjdG9yIiwiZGVmZXIiLCJmcm9tRXZlbnQiLCJtYXAiLCJwaXBlIiwiZmlsdGVyIiwiYnVmZmVyQ291bnQiLCJjb25jYXRNYXAiLCJ0YWtlIiwiRU1QVFkiLCJ0YWtlVW50aWwiLCJsaXN0ZW5JbnB1dEZyb21Db250ZXh0IiwiY29uZmlnIiwiY29udGV4dCIsImNvdW50IiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJyZXNwb25zZVR5cGUiLCJkb21haW4iLCJmcm9tIiwiY29ubmVjdFRvIiwiQXJyYXkiLCJpc0FycmF5IiwidGFyZ2V0IiwidG8iLCJuYW1lIiwibGlzdGVuRmlsdGVyIiwiaW5wdXQiLCJldmVudCIsImRhdGEiLCJsZW5ndGgiLCJpbmNsdWRlcyIsInR5cGUiLCJzb3VyY2UiLCJldmVudFRvTWVzc2FnZSIsIm1lc3NhZ2UiLCJtZXNzYWdlRXZlbnRzJCIsIndpbmRvdyIsImNyZWF0ZUxpc3RlbkxvZ2ljIiwiY29tcGF0TWFwIiwiYXJyIiwiRE9NQUlOIiwiUkVTUE9OU0VfVElNRU9VVF9ERUZBVUxUIiwiRkVUQ0hfVElNRU9VVF9ERUZBVUxUIiwiSEVBUlRCRUFUX0lOVEVSVkFMIiwiSEFORFNIQUtFX0lOVEVSVkFMIiwiTVNHX1JFU1BPTlNFIiwiTVNHX0hFQVJUQkVBVCIsIk1TR19ESVNDT05ORUNUIiwiTVNHX0hBTkRTSEFLRV9TWU4iLCJNU0dfSEFORFNIQUtFX1NZTl9BQ0siLCJNU0dfSEFORFNIQUtFX0FDSyIsIkhBTkRTSEFLRV9NU0dfVFlQRVMiLCJJTlRFUk5BTF9NU0dfVFlQRVMiLCJ0aHJvd09uRXZlbnQiLCJFcnJvciIsImNyZWF0ZVJlcXVlc3RNYWNoaW5lIiwidHlwZXMiLCJhY3RvcnMiLCJsaXN0ZW4iLCJhYm9ydFNpZ25hbCQiLCJzaWduYWwiLCJyZXF1ZXN0SWQiLCJtZXNzYWdlRmlsdGVyIiwicmVzcG9uc2VUbyIsInNvdXJjZXMiLCJoYXMiLCJzaXplIiwiYWN0aW9ucyIsInBhcmFtcyIsInRhcmdldE9yaWdpbiIsImZvckVhY2giLCJwb3N0TWVzc2FnZSIsInBhcmVudFJlZiIsInNlbGYiLCJyZXNwb25zZSIsInJlc29sdmFibGUiLCJyZXNvbHZlIiwiaWQiLCJzdXBwcmVzc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJyZWplY3QiLCJndWFyZHMiLCJleHBlY3RzUmVzcG9uc2UiLCJleHBlY3RSZXNwb25zZSIsImRlbGF5cyIsImluaXRpYWxUaW1lb3V0IiwicmVzcG9uc2VUaW1lb3V0IiwiY3JlYXRlTWFjaGluZSIsImNoYW5uZWxJZCIsIlNldCIsImluaXRpYWwiLCJvbiIsImFib3J0Iiwic3RhdGVzIiwiaWRsZSIsImFmdGVyIiwic2VuZGluZyIsImVudHJ5IiwiYWx3YXlzIiwiZ3VhcmQiLCJhd2FpdGluZyIsImludm9rZSIsInNyYyIsIm9uRXJyb3IiLCJmYWlsZWQiLCJzdWNjZXNzIiwiYWJvcnRlZCIsIm91dHB1dCIsInNlbmRCYWNrQXRJbnRlcnZhbCIsInNlbmRCYWNrIiwic2VuZCIsImltbWVkaWF0ZSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY3JlYXRlQ29ubmVjdGlvbk1hY2hpbmUiLCJyZXF1ZXN0TWFjaGluZSIsImVucXVldWUiLCJidWZmZXIiLCJyZXF1ZXN0cyIsInNwYXduIiwicmVxdWVzdCIsIl8iLCJzdGF0dXMiLCJtZXNzYWdlcyIsInBvc3QiLCJyZXNwb25kIiwicmVzcG9uZFRvIiwiaGVhcnRiZWF0IiwiY29ubmVjdCIsImhhbmRzaGFraW5nIiwic3luIiwiZGlzY29ubmVjdCIsImV4aXQiLCJjb25uZWN0ZWQiLCJjaGVja2luZyIsImRpc2Nvbm5lY3RlZCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJtYWNoaW5lIiwiYWN0b3IiLCJoYW5kbGVyIiwidW5zdWJzY3JpYmUiLCJvblN0YXR1cyIsImZpbHRlcjIiLCJzZXRUYXJnZXQiLCJfZGF0YSIsInN0b3AiLCJzdGFydCIsImdldFNuYXBzaG90IiwiY2xlYW51cENvbm5lY3Rpb24iLCJjb25uZWN0aW9uIiwic2V0VGltZW91dCIsIm5vb3AiLCJjcmVhdGVDb250cm9sbGVyIiwidGFyZ2V0cyIsImNoYW5uZWxzIiwiYWRkVGFyZ2V0IiwiYWRkIiwiY2hhbm5lbCIsImNvbm5lY3Rpb25zIiwiZGVsZXRlIiwidGFyZ2V0Q29ubmVjdGlvbnMiLCJzdWJzY3JpYmVycyIsInVuc3Vic2NyaWJlcnMiLCJwdXNoIiwiaW50ZXJuYWxFdmVudFN1YnNjcmliZXJzIiwic3RhdHVzU3Vic2NyaWJlcnMiLCJjcmVhdGVDaGFubmVsIiwiaW5wdXQyIiwic3Vic2NyaWJlciIsInVuc3ViIiwib25JbnRlcm5hbEV2ZW50IiwiY29ubmVjdGlvbnMyIiwiY2xlYXIiLCJkZXN0cm95IiwiY3JlYXRlTm9kZU1hY2hpbmUiLCJoYW5kc2hha2VCdWZmZXIiLCJvcHRpb25zIiwib3JpZ2luIiwiaGFzU291cmNlIiwib25Eb25lIiwiY3JlYXRlTm9kZSIsImNhY2hlZFN0YXR1cyIsImZldGNoIiwiUHJvbWlzZSIsIndpdGhSZXNvbHZlcnMiLCJwcm9taXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/@sanity/comlink/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/native.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/native.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst randomUUID = typeof crypto !== \"undefined\" && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    randomUUID\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNQSxhQUFhLE9BQU9DLFdBQVcsZUFBZUEsT0FBT0QsVUFBVSxJQUFJQyxPQUFPRCxVQUFVLENBQUNFLElBQUksQ0FBQ0Q7QUFDaEcsK0RBQWU7SUFBRUQ7QUFBVyxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uYXRpdmUuanM/ZDk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByYW5kb21VVUlEID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQgJiYgY3J5cHRvLnJhbmRvbVVVSUQuYmluZChjcnlwdG8pO1xuZXhwb3J0IGRlZmF1bHQgeyByYW5kb21VVUlEIH07XG4iXSwibmFtZXMiOlsicmFuZG9tVVVJRCIsImNyeXB0byIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/native.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/regex.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/regex.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLDBKQUEwSixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanM/NzNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/rng.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/rng.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rng; }\n/* harmony export */ });\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === \"undefined\" || !crypto.getRandomValues) {\n            throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQTtBQUNKLE1BQU1DLFFBQVEsSUFBSUMsV0FBVztBQUNkLFNBQVNDO0lBQ3BCLElBQUksQ0FBQ0gsaUJBQWlCO1FBQ2xCLElBQUksT0FBT0ksV0FBVyxlQUFlLENBQUNBLE9BQU9KLGVBQWUsRUFBRTtZQUMxRCxNQUFNLElBQUlLLE1BQU07UUFDcEI7UUFDQUwsa0JBQWtCSSxPQUFPSixlQUFlLENBQUNNLElBQUksQ0FBQ0Y7SUFDbEQ7SUFDQSxPQUFPSixnQkFBZ0JDO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzPzNiMDQiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGdldFJhbmRvbVZhbHVlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRSYW5kb21WYWx1ZXMiLCJybmRzOCIsIlVpbnQ4QXJyYXkiLCJybmciLCJjcnlwdG8iLCJFcnJvciIsImJpbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/stringify.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/stringify.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unsafeStringify: function() { return /* binding */ unsafeStringify; }\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/validate.js\");\n\nconst byteToHex = [];\nfor(let i = 0; i < 256; ++i){\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr) {\n    let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError(\"Stringified UUID is invalid\");\n    }\n    return uuid;\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBQ3JDLE1BQU1DLFlBQVksRUFBRTtBQUNwQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLLEVBQUVBLEVBQUc7SUFDMUJELFVBQVVFLElBQUksQ0FBQyxDQUFDRCxJQUFJLEtBQUksRUFBR0UsUUFBUSxDQUFDLElBQUlDLEtBQUssQ0FBQztBQUNsRDtBQUNPLFNBQVNDLGdCQUFnQkMsR0FBRztRQUFFQyxTQUFBQSxpRUFBUztJQUMxQyxPQUFPLENBQUNQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUM5QlAsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQzFCUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FDMUJQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUMxQixNQUNBUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FDMUJQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUMxQixNQUNBUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FDMUJQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUMxQixNQUNBUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FDMUJQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUMxQixNQUNBUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUMsR0FDM0JQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxHQUMzQlAsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsR0FBRyxDQUFDLEdBQzNCUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUMsR0FDM0JQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxHQUMzQlAsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsR0FBRyxDQUFDLEVBQUVDLFdBQVc7QUFDaEQ7QUFDQSxTQUFTQyxVQUFVSCxHQUFHO1FBQUVDLFNBQUFBLGlFQUFTO0lBQzdCLE1BQU1HLE9BQU9MLGdCQUFnQkMsS0FBS0M7SUFDbEMsSUFBSSxDQUFDUix3REFBUUEsQ0FBQ1csT0FBTztRQUNqQixNQUFNQyxVQUFVO0lBQ3BCO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBLCtEQUFlRCxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzPzQzYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gICAgcmV0dXJuIChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gK1xuICAgICAgICAnLScgK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICtcbiAgICAgICAgJy0nICtcbiAgICAgICAgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gK1xuICAgICAgICBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArXG4gICAgICAgICctJyArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArXG4gICAgICAgIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTtcbiAgICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiB1dWlkO1xufVxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5O1xuIl0sIm5hbWVzIjpbInZhbGlkYXRlIiwiYnl0ZVRvSGV4IiwiaSIsInB1c2giLCJ0b1N0cmluZyIsInNsaWNlIiwidW5zYWZlU3RyaW5naWZ5IiwiYXJyIiwib2Zmc2V0IiwidG9Mb3dlckNhc2UiLCJzdHJpbmdpZnkiLCJ1dWlkIiwiVHlwZUVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/v4.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/v4.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    rnds[6] = rnds[6] & 0x0f | 0x40;\n    rnds[8] = rnds[8] & 0x3f | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for(let i = 0; i < 16; ++i){\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pELFNBQVNHLEdBQUdDLE9BQU8sRUFBRUMsR0FBRyxFQUFFQyxNQUFNO0lBQzVCLElBQUlOLGtEQUFNQSxDQUFDTyxVQUFVLElBQUksQ0FBQ0YsT0FBTyxDQUFDRCxTQUFTO1FBQ3ZDLE9BQU9KLGtEQUFNQSxDQUFDTyxVQUFVO0lBQzVCO0lBQ0FILFVBQVVBLFdBQVcsQ0FBQztJQUN0QixNQUFNSSxPQUFPSixRQUFRSyxNQUFNLElBQUksQ0FBQ0wsUUFBUUgsR0FBRyxJQUFJQSwrQ0FBRTtJQUNqRE8sSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFLLENBQUMsRUFBRSxHQUFHLE9BQVE7SUFDN0JBLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSyxDQUFDLEVBQUUsR0FBRyxPQUFRO0lBQzdCLElBQUlILEtBQUs7UUFDTEMsU0FBU0EsVUFBVTtRQUNuQixJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQUVBLEVBQUc7WUFDekJMLEdBQUcsQ0FBQ0MsU0FBU0ksRUFBRSxHQUFHRixJQUFJLENBQUNFLEVBQUU7UUFDN0I7UUFDQSxPQUFPTDtJQUNYO0lBQ0EsT0FBT0gsOERBQWVBLENBQUNNO0FBQzNCO0FBQ0EsK0RBQWVMLEVBQUVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvbmV4dC1sb2FkZXIvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NC5qcz8xODM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBuYXRpdmUgZnJvbSAnLi9uYXRpdmUuanMnO1xuaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIGlmIChuYXRpdmUucmFuZG9tVVVJRCAmJiAhYnVmICYmICFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcbiAgICBybmRzWzZdID0gKHJuZHNbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGlmIChidWYpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuZXhwb3J0IGRlZmF1bHQgdjQ7XG4iXSwibmFtZXMiOlsibmF0aXZlIiwicm5nIiwidW5zYWZlU3RyaW5naWZ5IiwidjQiLCJvcHRpb25zIiwiYnVmIiwib2Zmc2V0IiwicmFuZG9tVVVJRCIsInJuZHMiLCJyYW5kb20iLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/validate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/validate.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === \"string\" && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L25leHQtbG9hZGVyL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7QUFDL0IsU0FBU0MsU0FBU0MsSUFBSTtJQUNsQixPQUFPLE9BQU9BLFNBQVMsWUFBWUYsaURBQUtBLENBQUNHLElBQUksQ0FBQ0Q7QUFDbEQ7QUFDQSwrREFBZUQsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9uZXh0LWxvYWRlci9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzPzFlNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICAgIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlO1xuIl0sIm5hbWVzIjpbIlJFR0VYIiwidmFsaWRhdGUiLCJ1dWlkIiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/next-loader/node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ })

}]);