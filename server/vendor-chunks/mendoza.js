"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mendoza";
exports.ids = ["vendor-chunks/mendoza"];
exports.modules = {

/***/ "(ssr)/./node_modules/mendoza/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/mendoza/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPatch: () => (/* binding */ applyPatch),\n/* harmony export */   incremental: () => (/* binding */ incrementalPatcher)\n/* harmony export */ });\nconst OPS = [\n    \"Value\",\n    \"Copy\",\n    \"Blank\",\n    \"ReturnIntoArray\",\n    \"ReturnIntoObject\",\n    \"ReturnIntoObjectSameKey\",\n    \"PushField\",\n    \"PushElement\",\n    \"PushParent\",\n    \"Pop\",\n    \"PushFieldCopy\",\n    \"PushFieldBlank\",\n    \"PushElementCopy\",\n    \"PushElementBlank\",\n    \"ReturnIntoObjectPop\",\n    \"ReturnIntoObjectSameKeyPop\",\n    \"ReturnIntoArrayPop\",\n    \"ObjectSetFieldValue\",\n    \"ObjectCopyField\",\n    \"ObjectDeleteField\",\n    \"ArrayAppendValue\",\n    \"ArrayAppendSlice\",\n    \"StringAppendString\",\n    \"StringAppendSlice\"\n];\nclass Patcher {\n    constructor(model, root, patch){\n        this.model = model, this.root = root, this.patch = patch, this.i = 0, this.inputStack = [], this.outputStack = [];\n    }\n    read() {\n        return this.patch[this.i++];\n    }\n    process() {\n        for(this.inputStack.push({\n            value: this.root\n        }), this.outputStack.push({\n            value: this.root\n        }); this.i < this.patch.length;){\n            let opcode = this.read(), op = OPS[opcode];\n            if (!op) throw new Error(`Unknown opcode: ${opcode}`);\n            let processor = `process${op}`;\n            this[processor].apply(this);\n        }\n        let entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    }\n    inputEntry() {\n        return this.inputStack[this.inputStack.length - 1];\n    }\n    inputKey(entry, idx) {\n        return entry.keys || (entry.keys = this.model.objectGetKeys(entry.value).sort()), entry.keys[idx];\n    }\n    outputEntry() {\n        return this.outputStack[this.outputStack.length - 1];\n    }\n    outputArray() {\n        let entry = this.outputEntry();\n        return entry.writeValue || (entry.writeValue = this.model.copyArray(entry.value)), entry.writeValue;\n    }\n    outputObject() {\n        let entry = this.outputEntry();\n        return entry.writeValue || (entry.writeValue = this.model.copyObject(entry.value)), entry.writeValue;\n    }\n    outputString() {\n        let entry = this.outputEntry();\n        return entry.writeValue || (entry.writeValue = this.model.copyString(entry.value)), entry.writeValue;\n    }\n    finalizeOutput(entry) {\n        return entry.writeValue ? this.model.finalize(entry.writeValue) : entry.value;\n    }\n    // Processors:\n    processValue() {\n        let value = this.model.wrap(this.read());\n        this.outputStack.push({\n            value\n        });\n    }\n    processCopy() {\n        let input = this.inputEntry();\n        this.outputStack.push({\n            value: input.value\n        });\n    }\n    processBlank() {\n        this.outputStack.push({\n            value: null\n        });\n    }\n    processReturnIntoArray() {\n        let entry = this.outputStack.pop(), result = this.finalizeOutput(entry), arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    }\n    processReturnIntoObject() {\n        let key = this.read(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        let obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    }\n    processReturnIntoObjectSameKey() {\n        let input = this.inputEntry(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry), obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    }\n    processPushField() {\n        let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({\n            value,\n            key\n        });\n    }\n    processPushElement() {\n        let idx = this.read(), entry = this.inputEntry(), value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({\n            value\n        });\n    }\n    processPop() {\n        this.inputStack.pop();\n    }\n    processPushFieldCopy() {\n        this.processPushField(), this.processCopy();\n    }\n    processPushFieldBlank() {\n        this.processPushField(), this.processBlank();\n    }\n    processPushElementCopy() {\n        this.processPushElement(), this.processCopy();\n    }\n    processPushElementBlank() {\n        this.processPushElement(), this.processBlank();\n    }\n    processReturnIntoObjectPop() {\n        this.processReturnIntoObject(), this.processPop();\n    }\n    processReturnIntoObjectSameKeyPop() {\n        this.processReturnIntoObjectSameKey(), this.processPop();\n    }\n    processReturnIntoArrayPop() {\n        this.processReturnIntoArray(), this.processPop();\n    }\n    processObjectSetFieldValue() {\n        this.processValue(), this.processReturnIntoObject();\n    }\n    processObjectCopyField() {\n        this.processPushField(), this.processCopy(), this.processReturnIntoObjectSameKey(), this.processPop();\n    }\n    processObjectDeleteField() {\n        let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    }\n    processArrayAppendValue() {\n        let value = this.model.wrap(this.read()), arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    }\n    processArrayAppendSlice() {\n        let left = this.read(), right = this.read(), str = this.outputArray(), val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    }\n    processStringAppendString() {\n        let value = this.model.wrap(this.read()), str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    }\n    processStringAppendSlice() {\n        let left = this.read(), right = this.read(), str = this.outputString(), val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    }\n}\nfunction utf8charSize(code) {\n    return code >> 16 ? 4 : code >> 11 ? 3 : code >> 7 ? 2 : 1;\n}\nfunction utf8stringSize(str) {\n    let b = 0;\n    for(let i = 0; i < str.length; i++){\n        let code = str.codePointAt(i), size = utf8charSize(code);\n        size == 4 && i++, b += size;\n    }\n    return b;\n}\nfunction utf8resolveIndex(str, idx, start = 0) {\n    let byteCount = start, ucsIdx = 0;\n    for(ucsIdx = start; byteCount < idx; ucsIdx++){\n        let code = str.codePointAt(ucsIdx), size = utf8charSize(code);\n        size === 4 && ucsIdx++, byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    let len = Math.min(str.length, str2.length), b = 0;\n    for(let i = 0; i < len;){\n        let aPoint = str.codePointAt(i), bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint) return b;\n        let size = utf8charSize(aPoint);\n        b += size, i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2, prefix = 0) {\n    let len = Math.min(str.length, str2.length) - prefix, b = 0;\n    for(let i = 0; i < len;){\n        let aPoint = str.codePointAt(str.length - 1 - i), bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint) return b;\n        let size = utf8charSize(aPoint);\n        b += size, i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nclass IncrementalModel {\n    constructor(meta){\n        this.meta = meta;\n    }\n    wrap(data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    }\n    wrapWithMeta(data, startMeta, endMeta = this.meta) {\n        return {\n            data,\n            startMeta,\n            endMeta\n        };\n    }\n    asObject(value) {\n        if (!value.content) {\n            let fields = {};\n            for (let [key, val] of Object.entries(value.data))fields[key] = this.wrapWithMeta(val, value.startMeta);\n            value.content = {\n                type: \"object\",\n                fields\n            };\n        }\n        return value.content;\n    }\n    asArray(value) {\n        if (!value.content) {\n            let elements = value.data.map((item)=>this.wrapWithMeta(item, value.startMeta)), metas = elements.map(()=>this.meta);\n            value.content = {\n                type: \"array\",\n                elements,\n                metas\n            };\n        }\n        return value.content;\n    }\n    asString(value) {\n        if (!value.content) {\n            let str = value.data, part = {\n                value: str,\n                utf8size: utf8stringSize(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([\n                part\n            ]);\n        }\n        return value.content;\n    }\n    stringFromParts(parts) {\n        let str = {\n            type: \"string\",\n            parts\n        };\n        for (let part of parts)part.uses.push(str);\n        return str;\n    }\n    objectGetKeys(value) {\n        return value.content ? Object.keys(value.content.fields) : Object.keys(value.data);\n    }\n    objectGetField(value, key) {\n        return this.asObject(value).fields[key];\n    }\n    arrayGetElement(value, idx) {\n        return this.asArray(value).elements[idx];\n    }\n    finalize(content) {\n        return this.updateEndMeta(content), {\n            content,\n            startMeta: this.meta,\n            endMeta: this.meta\n        };\n    }\n    markChanged(value) {\n        return this.wrap(unwrap(value));\n    }\n    updateEndMeta(content) {\n        if (content.type == \"string\") for (let part of content.parts)part.endMeta = this.meta;\n        else if (content.type === \"array\") for (let val of content.elements)val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;\n        else for (let val of Object.values(content.fields))val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;\n    }\n    copyString(value) {\n        if (value) {\n            let other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        } else return {\n            type: \"string\",\n            parts: []\n        };\n    }\n    copyObject(value) {\n        let obj = {\n            type: \"object\",\n            fields: {}\n        };\n        if (value) {\n            let other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    }\n    copyArray(value) {\n        let arr = value ? this.asArray(value) : null, elements = arr ? arr.elements : [], metas = arr ? arr.metas : [];\n        return {\n            type: \"array\",\n            elements,\n            metas\n        };\n    }\n    objectSetField(target, key, value) {\n        target.fields[key] = value;\n    }\n    objectDeleteField(target, key) {\n        delete target.fields[key];\n    }\n    arrayAppendValue(target, value) {\n        target.elements.push(value), target.metas.push(this.meta);\n    }\n    arrayAppendSlice(target, source, left, right) {\n        let arr = this.asArray(source), samePosition = arr.elements.length === left;\n        if (target.elements.push(...arr.elements.slice(left, right)), samePosition) target.metas.push(...arr.metas.slice(left, right));\n        else for(let i = left; i < right; i++)target.metas.push(this.meta);\n    }\n    stringAppendValue(target, value) {\n        let str = this.asString(value);\n        for (let part of str.parts)this.stringAppendPart(target, part);\n    }\n    stringAppendPart(target, part) {\n        target.parts.push(part), part.uses.push(target);\n    }\n    resolveStringPart(str, from, len) {\n        if (len === 0) return from;\n        for(let i = from; i < str.parts.length; i++){\n            let part = str.parts[i];\n            if (len === part.utf8size) return i + 1;\n            if (len < part.utf8size) return this.splitString(part, len), i + 1;\n            len -= part.utf8size;\n        }\n        throw new Error(\"splitting string out of bounds\");\n    }\n    splitString(part, idx) {\n        let leftValue, rightValue, leftSize = idx, rightSize = part.utf8size - leftSize;\n        if (part.utf8size !== part.value.length) {\n            let byteCount = 0;\n            for(idx = 0; byteCount < leftSize; idx++){\n                let code = part.value.codePointAt(idx), size = utf8charSize(code);\n                size === 4 && idx++, byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx), rightValue = part.value.slice(idx);\n        let newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue, part.utf8size = leftSize;\n        for (let use of part.uses){\n            let ndx = use.parts.indexOf(part);\n            if (ndx === -1) throw new Error(\"bug: mismatch between string parts and use.\");\n            use.parts.splice(ndx + 1, 0, newPart);\n        }\n    }\n    stringAppendSlice(target, source, left, right) {\n        let str = this.asString(source), firstPart = this.resolveStringPart(str, 0, left), lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for(let i = firstPart; i < lastPart; i++){\n            let part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    }\n}\nfunction wrap(data, meta) {\n    return {\n        data,\n        startMeta: meta,\n        endMeta: meta\n    };\n}\nfunction unwrap(value) {\n    if (typeof value.data < \"u\") return value.data;\n    let result, content = value.content;\n    switch(content.type){\n        case \"string\":\n            result = content.parts.map((part)=>part.value).join(\"\");\n            break;\n        case \"array\":\n            result = content.elements.map((val)=>unwrap(val));\n            break;\n        case \"object\":\n            {\n                result = {};\n                for (let [key, val] of Object.entries(content.fields))result[key] = unwrap(val);\n            }\n    }\n    return value.data = result, result;\n}\nfunction getType(value) {\n    return value.content ? value.content.type : Array.isArray(value.data) ? \"array\" : value.data === null ? \"null\" : typeof value.data;\n}\nfunction rebaseValue(left, right) {\n    let leftType = getType(left), rightType = getType(right);\n    if (leftType !== rightType) return right;\n    let leftModel = new IncrementalModel(left.endMeta), rightModel = new IncrementalModel(right.endMeta);\n    switch(leftType){\n        case \"object\":\n            {\n                let leftObj = leftModel.asObject(left), rightObj = rightModel.asObject(right), identicalFieldCount = 0, leftFieldCount = Object.keys(leftObj.fields).length, rightFieldCount = Object.keys(rightObj.fields).length;\n                for (let [key, rightVal] of Object.entries(rightObj.fields)){\n                    let leftVal = leftObj.fields[key];\n                    leftVal && (rightObj.fields[key] = rebaseValue(leftVal, rightVal), rightObj.fields[key] === leftVal && identicalFieldCount++);\n                }\n                return leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount ? left : right;\n            }\n        case \"array\":\n            {\n                let leftArr = leftModel.asArray(left), rightArr = rightModel.asArray(right);\n                if (leftArr.elements.length !== rightArr.elements.length) break;\n                let numRebased = 0;\n                for(let i = 0; i < rightArr.elements.length; i++)rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]), rightArr.elements[i] !== leftArr.elements[i] && numRebased++;\n                return numRebased === 0 ? left : right;\n            }\n        case \"null\":\n        case \"boolean\":\n        case \"number\":\n            {\n                if (unwrap(left) === unwrap(right)) return left;\n                break;\n            }\n        case \"string\":\n            {\n                let leftRaw = unwrap(left), rightRaw = unwrap(right);\n                if (leftRaw === rightRaw) return left;\n                let result = rightModel.copyString(null), prefix = commonPrefix(leftRaw, rightRaw), suffix = commonSuffix(leftRaw, rightRaw, prefix), rightLen = utf8stringSize(rightRaw), leftLen = utf8stringSize(leftRaw);\n                0 < prefix && rightModel.stringAppendSlice(result, left, 0, prefix), prefix < rightLen - suffix && rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix), leftLen - suffix < leftLen && rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n                let value = rightModel.finalize(result);\n                if (unwrap(value) !== rightRaw) throw new Error(\"incorrect string rebase\");\n                return value;\n            }\n    }\n    return right;\n}\nfunction applyPatch$1(left, patch, startMeta) {\n    let model = new IncrementalModel(startMeta);\n    return new Patcher(model, left, patch).process();\n}\nvar incrementalPatcher = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    applyPatch: applyPatch$1,\n    getType,\n    rebaseValue,\n    unwrap,\n    wrap\n});\nclass SimpleModel {\n    wrap(data) {\n        return data;\n    }\n    finalize(b) {\n        return Array.isArray(b) ? b : b.data;\n    }\n    markChanged(value) {\n        return value;\n    }\n    objectGetKeys(value) {\n        return Object.keys(value);\n    }\n    objectGetField(value, key) {\n        return value[key];\n    }\n    arrayGetElement(value, idx) {\n        return value[idx];\n    }\n    copyObject(value) {\n        let res = {\n            type: \"object\",\n            data: {}\n        };\n        if (value !== null) for (let [key, val] of Object.entries(value))res.data[key] = val;\n        return res;\n    }\n    copyArray(value) {\n        return value === null ? [] : value.slice();\n    }\n    copyString(value) {\n        return {\n            type: \"string\",\n            data: value === null ? \"\" : value\n        };\n    }\n    objectSetField(target, key, value) {\n        target.data[key] = value;\n    }\n    objectDeleteField(target, key) {\n        delete target.data[key];\n    }\n    arrayAppendValue(target, value) {\n        target.push(value);\n    }\n    arrayAppendSlice(target, source, left, right) {\n        target.push(...source.slice(left, right));\n    }\n    stringAppendSlice(target, source, left, right) {\n        const sourceString = source, leftPos = utf8resolveIndex(sourceString, left), rightPos = utf8resolveIndex(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    }\n    stringAppendValue(target, value) {\n        target.data += value;\n    }\n}\nfunction applyPatch(left, patch) {\n    let root = left;\n    return new Patcher(new SimpleModel(), root, patch).process();\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsTUFBTUEsTUFBTTtJQUNWO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBQ0QsTUFBTUM7SUFPSkMsWUFBWUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssQ0FBRTtRQUM5QixJQUFJLENBQUNGLEtBQUssR0FBR0EsT0FBTyxJQUFJLENBQUNDLElBQUksR0FBR0EsTUFBTSxJQUFJLENBQUNDLEtBQUssR0FBR0EsT0FBTyxJQUFJLENBQUNDLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQ0MsVUFBVSxHQUFHLEVBQUUsRUFBRSxJQUFJLENBQUNDLFdBQVcsR0FBRyxFQUFFO0lBQ25IO0lBQ0FDLE9BQU87UUFDTCxPQUFPLElBQUksQ0FBQ0osS0FBSyxDQUFDLElBQUksQ0FBQ0MsQ0FBQyxHQUFHO0lBQzdCO0lBQ0FJLFVBQVU7UUFDUixJQUFLLElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxJQUFJLENBQUM7WUFBRUMsT0FBTyxJQUFJLENBQUNSLElBQUk7UUFBQyxJQUFJLElBQUksQ0FBQ0ksV0FBVyxDQUFDRyxJQUFJLENBQUM7WUFBRUMsT0FBTyxJQUFJLENBQUNSLElBQUk7UUFBQyxJQUFJLElBQUksQ0FBQ0UsQ0FBQyxHQUFHLElBQUksQ0FBQ0QsS0FBSyxDQUFDUSxNQUFNLEVBQUk7WUFDMUgsSUFBSUMsU0FBUyxJQUFJLENBQUNMLElBQUksSUFBSU0sS0FBS2YsR0FBRyxDQUFDYyxPQUFPO1lBQzFDLElBQUksQ0FBQ0MsSUFDSCxNQUFNLElBQUlDLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRUYsT0FBTyxDQUFDO1lBQzdDLElBQUlHLFlBQVksQ0FBQyxPQUFPLEVBQUVGLEdBQUcs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SUFBSXJFLFFBQVEsSUFBSTZLLGVBQWUxSyxNQUFNQyxPQUFPSyxPQUFPO0FBQzVEO0FBSUUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaW1wbGUtYmxvZy1zdHlsZWQtdGVtcGxhdGUtZm9yLWhlYWRsZXNzLWNtcy8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2Rpc3QvaW5kZXguanM/OWFhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBPUFMgPSBbXG4gIFwiVmFsdWVcIixcbiAgXCJDb3B5XCIsXG4gIFwiQmxhbmtcIixcbiAgXCJSZXR1cm5JbnRvQXJyYXlcIixcbiAgXCJSZXR1cm5JbnRvT2JqZWN0XCIsXG4gIFwiUmV0dXJuSW50b09iamVjdFNhbWVLZXlcIixcbiAgXCJQdXNoRmllbGRcIixcbiAgXCJQdXNoRWxlbWVudFwiLFxuICBcIlB1c2hQYXJlbnRcIixcbiAgXCJQb3BcIixcbiAgXCJQdXNoRmllbGRDb3B5XCIsXG4gIFwiUHVzaEZpZWxkQmxhbmtcIixcbiAgXCJQdXNoRWxlbWVudENvcHlcIixcbiAgXCJQdXNoRWxlbWVudEJsYW5rXCIsXG4gIFwiUmV0dXJuSW50b09iamVjdFBvcFwiLFxuICBcIlJldHVybkludG9PYmplY3RTYW1lS2V5UG9wXCIsXG4gIFwiUmV0dXJuSW50b0FycmF5UG9wXCIsXG4gIFwiT2JqZWN0U2V0RmllbGRWYWx1ZVwiLFxuICBcIk9iamVjdENvcHlGaWVsZFwiLFxuICBcIk9iamVjdERlbGV0ZUZpZWxkXCIsXG4gIFwiQXJyYXlBcHBlbmRWYWx1ZVwiLFxuICBcIkFycmF5QXBwZW5kU2xpY2VcIixcbiAgXCJTdHJpbmdBcHBlbmRTdHJpbmdcIixcbiAgXCJTdHJpbmdBcHBlbmRTbGljZVwiXG5dO1xuY2xhc3MgUGF0Y2hlciB7XG4gIG1vZGVsO1xuICByb290O1xuICBwYXRjaDtcbiAgaTtcbiAgaW5wdXRTdGFjaztcbiAgb3V0cHV0U3RhY2s7XG4gIGNvbnN0cnVjdG9yKG1vZGVsLCByb290LCBwYXRjaCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbCwgdGhpcy5yb290ID0gcm9vdCwgdGhpcy5wYXRjaCA9IHBhdGNoLCB0aGlzLmkgPSAwLCB0aGlzLmlucHV0U3RhY2sgPSBbXSwgdGhpcy5vdXRwdXRTdGFjayA9IFtdO1xuICB9XG4gIHJlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0Y2hbdGhpcy5pKytdO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgZm9yICh0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSksIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7IHRoaXMuaSA8IHRoaXMucGF0Y2gubGVuZ3RoOyApIHtcbiAgICAgIGxldCBvcGNvZGUgPSB0aGlzLnJlYWQoKSwgb3AgPSBPUFNbb3Bjb2RlXTtcbiAgICAgIGlmICghb3ApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGNvZGU6ICR7b3Bjb2RlfWApO1xuICAgICAgbGV0IHByb2Nlc3NvciA9IGBwcm9jZXNzJHtvcH1gO1xuICAgICAgdGhpc1twcm9jZXNzb3JdLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgfVxuICBpbnB1dEVudHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0U3RhY2tbdGhpcy5pbnB1dFN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlucHV0S2V5KGVudHJ5LCBpZHgpIHtcbiAgICByZXR1cm4gZW50cnkua2V5cyB8fCAoZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpKSwgZW50cnkua2V5c1tpZHhdO1xuICB9XG4gIG91dHB1dEVudHJ5KCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0YWNrW3RoaXMub3V0cHV0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgb3V0cHV0QXJyYXkoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlIHx8IChlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5QXJyYXkoZW50cnkudmFsdWUpKSwgZW50cnkud3JpdGVWYWx1ZTtcbiAgfVxuICBvdXRwdXRPYmplY3QoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlIHx8IChlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5T2JqZWN0KGVudHJ5LnZhbHVlKSksIGVudHJ5LndyaXRlVmFsdWU7XG4gIH1cbiAgb3V0cHV0U3RyaW5nKCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZSB8fCAoZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSkpLCBlbnRyeS53cml0ZVZhbHVlO1xuICB9XG4gIGZpbmFsaXplT3V0cHV0KGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWUgPyB0aGlzLm1vZGVsLmZpbmFsaXplKGVudHJ5LndyaXRlVmFsdWUpIDogZW50cnkudmFsdWU7XG4gIH1cbiAgLy8gUHJvY2Vzc29yczpcbiAgcHJvY2Vzc1ZhbHVlKCkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWUgfSk7XG4gIH1cbiAgcHJvY2Vzc0NvcHkoKSB7XG4gICAgbGV0IGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IGlucHV0LnZhbHVlIH0pO1xuICB9XG4gIHByb2Nlc3NCbGFuaygpIHtcbiAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogbnVsbCB9KTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b0FycmF5KCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCksIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpLCBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgcmVzdWx0KTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdCgpIHtcbiAgICBsZXQga2V5ID0gdGhpcy5yZWFkKCksIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKSwgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5tYXJrQ2hhbmdlZChyZXN1bHQpO1xuICAgIGxldCBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5KCkge1xuICAgIGxldCBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpLCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCksIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpLCBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBpbnB1dC5rZXksIHJlc3VsdCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZCgpIHtcbiAgICBsZXQgaWR4ID0gdGhpcy5yZWFkKCksIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCksIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCksIHZhbHVlID0gdGhpcy5tb2RlbC5vYmplY3RHZXRGaWVsZChlbnRyeS52YWx1ZSwga2V5KTtcbiAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlLCBrZXkgfSk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50KCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKSwgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKSwgdmFsdWUgPSB0aGlzLm1vZGVsLmFycmF5R2V0RWxlbWVudChlbnRyeS52YWx1ZSwgaWR4KTtcbiAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlIH0pO1xuICB9XG4gIHByb2Nlc3NQb3AoKSB7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnBvcCgpO1xuICB9XG4gIHByb2Nlc3NQdXNoRmllbGRDb3B5KCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpLCB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZEJsYW5rKCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpLCB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICB9XG4gIHByb2Nlc3NQdXNoRWxlbWVudENvcHkoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKSwgdGhpcy5wcm9jZXNzQ29weSgpO1xuICB9XG4gIHByb2Nlc3NQdXNoRWxlbWVudEJsYW5rKCkge1xuICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCksIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3RQb3AoKSB7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpLCB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AoKSB7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKSwgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9BcnJheVBvcCgpIHtcbiAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKSwgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdFNldEZpZWxkVmFsdWUoKSB7XG4gICAgdGhpcy5wcm9jZXNzVmFsdWUoKSwgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICB9XG4gIHByb2Nlc3NPYmplY3RDb3B5RmllbGQoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCksIHRoaXMucHJvY2Vzc0NvcHkoKSwgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKSwgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdERlbGV0ZUZpZWxkKCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKSwgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKSwga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KSwgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdERlbGV0ZUZpZWxkKG9iaiwga2V5KTtcbiAgfVxuICBwcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpLCBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICB9XG4gIHByb2Nlc3NBcnJheUFwcGVuZFNsaWNlKCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yZWFkKCksIHJpZ2h0ID0gdGhpcy5yZWFkKCksIHN0ciA9IHRoaXMub3V0cHV0QXJyYXkoKSwgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZygpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpLCBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xuICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0FwcGVuZFNsaWNlKCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yZWFkKCksIHJpZ2h0ID0gdGhpcy5yZWFkKCksIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCksIHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgfVxufVxuZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj4gMTYgPyA0IDogY29kZSA+PiAxMSA/IDMgOiBjb2RlID4+IDcgPyAyIDogMTtcbn1cbmZ1bmN0aW9uIHV0ZjhzdHJpbmdTaXplKHN0cikge1xuICBsZXQgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSksIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgc2l6ZSA9PSA0ICYmIGkrKywgYiArPSBzaXplO1xuICB9XG4gIHJldHVybiBiO1xufVxuZnVuY3Rpb24gdXRmOHJlc29sdmVJbmRleChzdHIsIGlkeCwgc3RhcnQgPSAwKSB7XG4gIGxldCBieXRlQ291bnQgPSBzdGFydCwgdWNzSWR4ID0gMDtcbiAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xuICAgIGxldCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KHVjc0lkeCksIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgc2l6ZSA9PT0gNCAmJiB1Y3NJZHgrKywgYnl0ZUNvdW50ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIHVjc0lkeDtcbn1cbmZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcbiAgbGV0IGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSwgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcbiAgICBsZXQgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpLCBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcbiAgICAgIHJldHVybiBiO1xuICAgIGxldCBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XG4gICAgYiArPSBzaXplLCBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIGNvbW1vblN1ZmZpeChzdHIsIHN0cjIsIHByZWZpeCA9IDApIHtcbiAgbGV0IGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSAtIHByZWZpeCwgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcbiAgICBsZXQgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHN0ci5sZW5ndGggLSAxIC0gaSksIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoc3RyMi5sZW5ndGggLSAxIC0gaSk7XG4gICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KVxuICAgICAgcmV0dXJuIGI7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICBiICs9IHNpemUsIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xuICB9XG4gIHJldHVybiBiO1xufVxuY2xhc3MgSW5jcmVtZW50YWxNb2RlbCB7XG4gIG1ldGE7XG4gIGNvbnN0cnVjdG9yKG1ldGEpIHtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIHdyYXAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLndyYXBXaXRoTWV0YShkYXRhLCB0aGlzLm1ldGEsIHRoaXMubWV0YSk7XG4gIH1cbiAgd3JhcFdpdGhNZXRhKGRhdGEsIHN0YXJ0TWV0YSwgZW5kTWV0YSA9IHRoaXMubWV0YSkge1xuICAgIHJldHVybiB7IGRhdGEsIHN0YXJ0TWV0YSwgZW5kTWV0YSB9O1xuICB9XG4gIGFzT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlLmRhdGEpKVxuICAgICAgICBmaWVsZHNba2V5XSA9IHRoaXMud3JhcFdpdGhNZXRhKHZhbCwgdmFsdWUuc3RhcnRNZXRhKTtcbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6IFwib2JqZWN0XCIsIGZpZWxkcyB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgfVxuICBhc0FycmF5KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgZWxlbWVudHMgPSB2YWx1ZS5kYXRhLm1hcChcbiAgICAgICAgKGl0ZW0pID0+IHRoaXMud3JhcFdpdGhNZXRhKGl0ZW0sIHZhbHVlLnN0YXJ0TWV0YSlcbiAgICAgICksIG1ldGFzID0gZWxlbWVudHMubWFwKCgpID0+IHRoaXMubWV0YSk7XG4gICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiBcImFycmF5XCIsIGVsZW1lbnRzLCBtZXRhcyB9O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgfVxuICBhc1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgbGV0IHN0ciA9IHZhbHVlLmRhdGEsIHBhcnQgPSB7XG4gICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgIHV0ZjhzaXplOiB1dGY4c3RyaW5nU2l6ZShzdHIpLFxuICAgICAgICB1c2VzOiBbXSxcbiAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXG4gICAgICAgIGVuZE1ldGE6IHZhbHVlLmVuZE1ldGFcbiAgICAgIH07XG4gICAgICB2YWx1ZS5jb250ZW50ID0gdGhpcy5zdHJpbmdGcm9tUGFydHMoW3BhcnRdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gIH1cbiAgc3RyaW5nRnJvbVBhcnRzKHBhcnRzKSB7XG4gICAgbGV0IHN0ciA9IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBwYXJ0c1xuICAgIH07XG4gICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cylcbiAgICAgIHBhcnQudXNlcy5wdXNoKHN0cik7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBvYmplY3RHZXRLZXlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQgPyBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcykgOiBPYmplY3Qua2V5cyh2YWx1ZS5kYXRhKTtcbiAgfVxuICBvYmplY3RHZXRGaWVsZCh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuYXNPYmplY3QodmFsdWUpLmZpZWxkc1trZXldO1xuICB9XG4gIGFycmF5R2V0RWxlbWVudCh2YWx1ZSwgaWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuYXNBcnJheSh2YWx1ZSkuZWxlbWVudHNbaWR4XTtcbiAgfVxuICBmaW5hbGl6ZShjb250ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlRW5kTWV0YShjb250ZW50KSwgeyBjb250ZW50LCBzdGFydE1ldGE6IHRoaXMubWV0YSwgZW5kTWV0YTogdGhpcy5tZXRhIH07XG4gIH1cbiAgbWFya0NoYW5nZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xuICB9XG4gIHVwZGF0ZUVuZE1ldGEoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIGZvciAobGV0IHBhcnQgb2YgY29udGVudC5wYXJ0cylcbiAgICAgICAgcGFydC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgIGVsc2UgaWYgKGNvbnRlbnQudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgZm9yIChsZXQgdmFsIG9mIGNvbnRlbnQuZWxlbWVudHMpXG4gICAgICAgIHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEgJiYgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KSwgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgdmFsIG9mIE9iamVjdC52YWx1ZXMoY29udGVudC5maWVsZHMpKVxuICAgICAgICB2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhICYmIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCksIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICB9XG4gIGNvcHlTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGxldCBvdGhlciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgcGFydHM6IFtdXG4gICAgICB9O1xuICB9XG4gIGNvcHlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgb2JqID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGZpZWxkczoge31cbiAgICB9O1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgbGV0IG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgICBPYmplY3QuYXNzaWduKG9iai5maWVsZHMsIG90aGVyLmZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29weUFycmF5KHZhbHVlKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGwsIGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW10sIG1ldGFzID0gYXJyID8gYXJyLm1ldGFzIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWV0YXNcbiAgICB9O1xuICB9XG4gIG9iamVjdFNldEZpZWxkKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIHRhcmdldC5maWVsZHNba2V5XSA9IHZhbHVlO1xuICB9XG4gIG9iamVjdERlbGV0ZUZpZWxkKHRhcmdldCwga2V5KSB7XG4gICAgZGVsZXRlIHRhcmdldC5maWVsZHNba2V5XTtcbiAgfVxuICBhcnJheUFwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSksIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gIH1cbiAgYXJyYXlBcHBlbmRTbGljZSh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICBsZXQgYXJyID0gdGhpcy5hc0FycmF5KHNvdXJjZSksIHNhbWVQb3NpdGlvbiA9IGFyci5lbGVtZW50cy5sZW5ndGggPT09IGxlZnQ7XG4gICAgaWYgKHRhcmdldC5lbGVtZW50cy5wdXNoKC4uLmFyci5lbGVtZW50cy5zbGljZShsZWZ0LCByaWdodCkpLCBzYW1lUG9zaXRpb24pXG4gICAgICB0YXJnZXQubWV0YXMucHVzaCguLi5hcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8IHJpZ2h0OyBpKyspXG4gICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gIH1cbiAgc3RyaW5nQXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIGxldCBzdHIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICBmb3IgKGxldCBwYXJ0IG9mIHN0ci5wYXJ0cylcbiAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICB9XG4gIHN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KSB7XG4gICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCksIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XG4gIH1cbiAgcmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCBmcm9tLCBsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKVxuICAgICAgcmV0dXJuIGZyb207XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCBzdHIucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgaWYgKGxlbiA9PT0gcGFydC51dGY4c2l6ZSlcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgaWYgKGxlbiA8IHBhcnQudXRmOHNpemUpXG4gICAgICAgIHJldHVybiB0aGlzLnNwbGl0U3RyaW5nKHBhcnQsIGxlbiksIGkgKyAxO1xuICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0dGluZyBzdHJpbmcgb3V0IG9mIGJvdW5kc1wiKTtcbiAgfVxuICBzcGxpdFN0cmluZyhwYXJ0LCBpZHgpIHtcbiAgICBsZXQgbGVmdFZhbHVlLCByaWdodFZhbHVlLCBsZWZ0U2l6ZSA9IGlkeCwgcmlnaHRTaXplID0gcGFydC51dGY4c2l6ZSAtIGxlZnRTaXplO1xuICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgICBmb3IgKGlkeCA9IDA7IGJ5dGVDb3VudCA8IGxlZnRTaXplOyBpZHgrKykge1xuICAgICAgICBsZXQgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KSwgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICAgICAgc2l6ZSA9PT0gNCAmJiBpZHgrKywgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIGxlZnRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoMCwgaWR4KSwgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcbiAgICBsZXQgbmV3UGFydCA9IHtcbiAgICAgIHZhbHVlOiByaWdodFZhbHVlLFxuICAgICAgdXRmOHNpemU6IHJpZ2h0U2l6ZSxcbiAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxuICAgICAgc3RhcnRNZXRhOiBwYXJ0LnN0YXJ0TWV0YSxcbiAgICAgIGVuZE1ldGE6IHBhcnQuZW5kTWV0YVxuICAgIH07XG4gICAgcGFydC52YWx1ZSA9IGxlZnRWYWx1ZSwgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xuICAgIGZvciAobGV0IHVzZSBvZiBwYXJ0LnVzZXMpIHtcbiAgICAgIGxldCBuZHggPSB1c2UucGFydHMuaW5kZXhPZihwYXJ0KTtcbiAgICAgIGlmIChuZHggPT09IC0xKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuXCIpO1xuICAgICAgdXNlLnBhcnRzLnNwbGljZShuZHggKyAxLCAwLCBuZXdQYXJ0KTtcbiAgICB9XG4gIH1cbiAgc3RyaW5nQXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IHN0ciA9IHRoaXMuYXNTdHJpbmcoc291cmNlKSwgZmlyc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIDAsIGxlZnQpLCBsYXN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCBmaXJzdFBhcnQsIHJpZ2h0IC0gbGVmdCk7XG4gICAgZm9yIChsZXQgaSA9IGZpcnN0UGFydDsgaSA8IGxhc3RQYXJ0OyBpKyspIHtcbiAgICAgIGxldCBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xuICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3cmFwKGRhdGEsIG1ldGEpIHtcbiAgcmV0dXJuIHsgZGF0YSwgc3RhcnRNZXRhOiBtZXRhLCBlbmRNZXRhOiBtZXRhIH07XG59XG5mdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhIDwgXCJ1XCIpXG4gICAgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIGxldCByZXN1bHQsIGNvbnRlbnQgPSB2YWx1ZS5jb250ZW50O1xuICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LnZhbHVlKS5qb2luKFwiXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcCgodmFsKSA9PiB1bndyYXAodmFsKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcykpXG4gICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZS5kYXRhID0gcmVzdWx0LCByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5jb250ZW50ID8gdmFsdWUuY29udGVudC50eXBlIDogQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSA/IFwiYXJyYXlcIiA6IHZhbHVlLmRhdGEgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB2YWx1ZS5kYXRhO1xufVxuZnVuY3Rpb24gcmViYXNlVmFsdWUobGVmdCwgcmlnaHQpIHtcbiAgbGV0IGxlZnRUeXBlID0gZ2V0VHlwZShsZWZ0KSwgcmlnaHRUeXBlID0gZ2V0VHlwZShyaWdodCk7XG4gIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKVxuICAgIHJldHVybiByaWdodDtcbiAgbGV0IGxlZnRNb2RlbCA9IG5ldyBJbmNyZW1lbnRhbE1vZGVsKGxlZnQuZW5kTWV0YSksIHJpZ2h0TW9kZWwgPSBuZXcgSW5jcmVtZW50YWxNb2RlbChyaWdodC5lbmRNZXRhKTtcbiAgc3dpdGNoIChsZWZ0VHlwZSkge1xuICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgbGV0IGxlZnRPYmogPSBsZWZ0TW9kZWwuYXNPYmplY3QobGVmdCksIHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCksIGlkZW50aWNhbEZpZWxkQ291bnQgPSAwLCBsZWZ0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKGxlZnRPYmouZmllbGRzKS5sZW5ndGgsIHJpZ2h0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKHJpZ2h0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgW2tleSwgcmlnaHRWYWxdIG9mIE9iamVjdC5lbnRyaWVzKHJpZ2h0T2JqLmZpZWxkcykpIHtcbiAgICAgICAgbGV0IGxlZnRWYWwgPSBsZWZ0T2JqLmZpZWxkc1trZXldO1xuICAgICAgICBsZWZ0VmFsICYmIChyaWdodE9iai5maWVsZHNba2V5XSA9IHJlYmFzZVZhbHVlKGxlZnRWYWwsIHJpZ2h0VmFsKSwgcmlnaHRPYmouZmllbGRzW2tleV0gPT09IGxlZnRWYWwgJiYgaWRlbnRpY2FsRmllbGRDb3VudCsrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0RmllbGRDb3VudCA9PT0gcmlnaHRGaWVsZENvdW50ICYmIGxlZnRGaWVsZENvdW50ID09PSBpZGVudGljYWxGaWVsZENvdW50ID8gbGVmdCA6IHJpZ2h0O1xuICAgIH1cbiAgICBjYXNlIFwiYXJyYXlcIjoge1xuICAgICAgbGV0IGxlZnRBcnIgPSBsZWZ0TW9kZWwuYXNBcnJheShsZWZ0KSwgcmlnaHRBcnIgPSByaWdodE1vZGVsLmFzQXJyYXkocmlnaHQpO1xuICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgbGV0IG51bVJlYmFzZWQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaWdodEFyci5lbGVtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSksIHJpZ2h0QXJyLmVsZW1lbnRzW2ldICE9PSBsZWZ0QXJyLmVsZW1lbnRzW2ldICYmIG51bVJlYmFzZWQrKztcbiAgICAgIHJldHVybiBudW1SZWJhc2VkID09PSAwID8gbGVmdCA6IHJpZ2h0O1xuICAgIH1cbiAgICBjYXNlIFwibnVsbFwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgY2FzZSBcIm51bWJlclwiOiB7XG4gICAgICBpZiAodW53cmFwKGxlZnQpID09PSB1bndyYXAocmlnaHQpKVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgIGxldCBsZWZ0UmF3ID0gdW53cmFwKGxlZnQpLCByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XG4gICAgICBpZiAobGVmdFJhdyA9PT0gcmlnaHRSYXcpXG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgbGV0IHJlc3VsdCA9IHJpZ2h0TW9kZWwuY29weVN0cmluZyhudWxsKSwgcHJlZml4ID0gY29tbW9uUHJlZml4KGxlZnRSYXcsIHJpZ2h0UmF3KSwgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpLCByaWdodExlbiA9IHV0ZjhzdHJpbmdTaXplKHJpZ2h0UmF3KSwgbGVmdExlbiA9IHV0ZjhzdHJpbmdTaXplKGxlZnRSYXcpO1xuICAgICAgMCA8IHByZWZpeCAmJiByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KSwgcHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXggJiYgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIHJpZ2h0LCBwcmVmaXgsIHJpZ2h0TGVuIC0gc3VmZml4KSwgbGVmdExlbiAtIHN1ZmZpeCA8IGxlZnRMZW4gJiYgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIGxlZnRMZW4gLSBzdWZmaXgsIGxlZnRMZW4pO1xuICAgICAgbGV0IHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xuICAgICAgaWYgKHVud3JhcCh2YWx1ZSkgIT09IHJpZ2h0UmF3KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmNvcnJlY3Qgc3RyaW5nIHJlYmFzZVwiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJpZ2h0O1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaCQxKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcbiAgbGV0IG1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwoc3RhcnRNZXRhKTtcbiAgcmV0dXJuIG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCkucHJvY2VzcygpO1xufVxudmFyIGluY3JlbWVudGFsUGF0Y2hlciA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcHBseVBhdGNoOiBhcHBseVBhdGNoJDEsXG4gIGdldFR5cGUsXG4gIHJlYmFzZVZhbHVlLFxuICB1bndyYXAsXG4gIHdyYXBcbn0pO1xuY2xhc3MgU2ltcGxlTW9kZWwge1xuICB3cmFwKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBmaW5hbGl6ZShiKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgPyBiIDogYi5kYXRhO1xuICB9XG4gIG1hcmtDaGFuZ2VkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIG9iamVjdEdldEtleXModmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICB9XG4gIG9iamVjdEdldEZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgfVxuICBhcnJheUdldEVsZW1lbnQodmFsdWUsIGlkeCkge1xuICAgIHJldHVybiB2YWx1ZVtpZHhdO1xuICB9XG4gIGNvcHlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpXG4gICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSlcbiAgICAgICAgcmVzLmRhdGFba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGNvcHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IFtdIDogdmFsdWUuc2xpY2UoKTtcbiAgfVxuICBjb3B5U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkYXRhOiB2YWx1ZSA9PT0gbnVsbCA/IFwiXCIgOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgb2JqZWN0U2V0RmllbGQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmRhdGFba2V5XSA9IHZhbHVlO1xuICB9XG4gIG9iamVjdERlbGV0ZUZpZWxkKHRhcmdldCwga2V5KSB7XG4gICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XG4gIH1cbiAgYXJyYXlBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdGFyZ2V0LnB1c2godmFsdWUpO1xuICB9XG4gIGFycmF5QXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgdGFyZ2V0LnB1c2goLi4uc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XG4gIH1cbiAgc3RyaW5nQXBwZW5kU2xpY2UodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3Qgc291cmNlU3RyaW5nID0gc291cmNlLCBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpLCByaWdodFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCByaWdodCwgbGVmdFBvcyk7XG4gICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcbiAgfVxuICBzdHJpbmdBcHBlbmRWYWx1ZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgdGFyZ2V0LmRhdGEgKz0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2gobGVmdCwgcGF0Y2gpIHtcbiAgbGV0IHJvb3QgPSBsZWZ0O1xuICByZXR1cm4gbmV3IFBhdGNoZXIobmV3IFNpbXBsZU1vZGVsKCksIHJvb3QsIHBhdGNoKS5wcm9jZXNzKCk7XG59XG5leHBvcnQge1xuICBhcHBseVBhdGNoLFxuICBpbmNyZW1lbnRhbFBhdGNoZXIgYXMgaW5jcmVtZW50YWxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPUFMiLCJQYXRjaGVyIiwiY29uc3RydWN0b3IiLCJtb2RlbCIsInJvb3QiLCJwYXRjaCIsImkiLCJpbnB1dFN0YWNrIiwib3V0cHV0U3RhY2siLCJyZWFkIiwicHJvY2VzcyIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsIm9wY29kZSIsIm9wIiwiRXJyb3IiLCJwcm9jZXNzb3IiLCJhcHBseSIsImVudHJ5IiwicG9wIiwiZmluYWxpemVPdXRwdXQiLCJpbnB1dEVudHJ5IiwiaW5wdXRLZXkiLCJpZHgiLCJrZXlzIiwib2JqZWN0R2V0S2V5cyIsInNvcnQiLCJvdXRwdXRFbnRyeSIsIm91dHB1dEFycmF5Iiwid3JpdGVWYWx1ZSIsImNvcHlBcnJheSIsIm91dHB1dE9iamVjdCIsImNvcHlPYmplY3QiLCJvdXRwdXRTdHJpbmciLCJjb3B5U3RyaW5nIiwiZmluYWxpemUiLCJwcm9jZXNzVmFsdWUiLCJ3cmFwIiwicHJvY2Vzc0NvcHkiLCJpbnB1dCIsInByb2Nlc3NCbGFuayIsInByb2Nlc3NSZXR1cm5JbnRvQXJyYXkiLCJyZXN1bHQiLCJhcnIiLCJhcnJheUFwcGVuZFZhbHVlIiwicHJvY2Vzc1JldHVybkludG9PYmplY3QiLCJrZXkiLCJtYXJrQ2hhbmdlZCIsIm9iaiIsIm9iamVjdFNldEZpZWxkIiwicHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5IiwicHJvY2Vzc1B1c2hGaWVsZCIsIm9iamVjdEdldEZpZWxkIiwicHJvY2Vzc1B1c2hFbGVtZW50IiwiYXJyYXlHZXRFbGVtZW50IiwicHJvY2Vzc1BvcCIsInByb2Nlc3NQdXNoRmllbGRDb3B5IiwicHJvY2Vzc1B1c2hGaWVsZEJsYW5rIiwicHJvY2Vzc1B1c2hFbGVtZW50Q29weSIsInByb2Nlc3NQdXNoRWxlbWVudEJsYW5rIiwicHJvY2Vzc1JldHVybkludG9PYmplY3RQb3AiLCJwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AiLCJwcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wIiwicHJvY2Vzc09iamVjdFNldEZpZWxkVmFsdWUiLCJwcm9jZXNzT2JqZWN0Q29weUZpZWxkIiwicHJvY2Vzc09iamVjdERlbGV0ZUZpZWxkIiwib2JqZWN0RGVsZXRlRmllbGQiLCJwcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSIsInByb2Nlc3NBcnJheUFwcGVuZFNsaWNlIiwibGVmdCIsInJpZ2h0Iiwic3RyIiwidmFsIiwiYXJyYXlBcHBlbmRTbGljZSIsInByb2Nlc3NTdHJpbmdBcHBlbmRTdHJpbmciLCJzdHJpbmdBcHBlbmRWYWx1ZSIsInByb2Nlc3NTdHJpbmdBcHBlbmRTbGljZSIsInN0cmluZ0FwcGVuZFNsaWNlIiwidXRmOGNoYXJTaXplIiwiY29kZSIsInV0ZjhzdHJpbmdTaXplIiwiYiIsImNvZGVQb2ludEF0Iiwic2l6ZSIsInV0ZjhyZXNvbHZlSW5kZXgiLCJzdGFydCIsImJ5dGVDb3VudCIsInVjc0lkeCIsImNvbW1vblByZWZpeCIsInN0cjIiLCJsZW4iLCJNYXRoIiwibWluIiwiYVBvaW50IiwiYlBvaW50IiwiY29tbW9uU3VmZml4IiwicHJlZml4IiwiSW5jcmVtZW50YWxNb2RlbCIsIm1ldGEiLCJkYXRhIiwid3JhcFdpdGhNZXRhIiwic3RhcnRNZXRhIiwiZW5kTWV0YSIsImFzT2JqZWN0IiwiY29udGVudCIsImZpZWxkcyIsIk9iamVjdCIsImVudHJpZXMiLCJ0eXBlIiwiYXNBcnJheSIsImVsZW1lbnRzIiwibWFwIiwiaXRlbSIsIm1ldGFzIiwiYXNTdHJpbmciLCJwYXJ0IiwidXRmOHNpemUiLCJ1c2VzIiwic3RyaW5nRnJvbVBhcnRzIiwicGFydHMiLCJ1cGRhdGVFbmRNZXRhIiwidW53cmFwIiwidmFsdWVzIiwib3RoZXIiLCJzbGljZSIsImFzc2lnbiIsInRhcmdldCIsInNvdXJjZSIsInNhbWVQb3NpdGlvbiIsInN0cmluZ0FwcGVuZFBhcnQiLCJyZXNvbHZlU3RyaW5nUGFydCIsImZyb20iLCJzcGxpdFN0cmluZyIsImxlZnRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJsZWZ0U2l6ZSIsInJpZ2h0U2l6ZSIsIm5ld1BhcnQiLCJ1c2UiLCJuZHgiLCJpbmRleE9mIiwic3BsaWNlIiwiZmlyc3RQYXJ0IiwibGFzdFBhcnQiLCJqb2luIiwiZ2V0VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsInJlYmFzZVZhbHVlIiwibGVmdFR5cGUiLCJyaWdodFR5cGUiLCJsZWZ0TW9kZWwiLCJyaWdodE1vZGVsIiwibGVmdE9iaiIsInJpZ2h0T2JqIiwiaWRlbnRpY2FsRmllbGRDb3VudCIsImxlZnRGaWVsZENvdW50IiwicmlnaHRGaWVsZENvdW50IiwicmlnaHRWYWwiLCJsZWZ0VmFsIiwibGVmdEFyciIsInJpZ2h0QXJyIiwibnVtUmViYXNlZCIsImxlZnRSYXciLCJyaWdodFJhdyIsInN1ZmZpeCIsInJpZ2h0TGVuIiwibGVmdExlbiIsImFwcGx5UGF0Y2gkMSIsImluY3JlbWVudGFsUGF0Y2hlciIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImFwcGx5UGF0Y2giLCJTaW1wbGVNb2RlbCIsInJlcyIsInNvdXJjZVN0cmluZyIsImxlZnRQb3MiLCJyaWdodFBvcyIsImluY3JlbWVudGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mendoza/dist/index.js\n");

/***/ })

};
;